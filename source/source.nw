% -*- mode: Noweb; noweb-code-mode: c-mode -*-
@

The source structure contains all the data associated with a remote optical emitter: its location, wavefront, irradiance, ...

\subsection{The files}

\subsubsection{Header}

<<source.h>>=
#ifndef __SOURCE_H__
#define __SOURCE_H__

#ifndef __CEO_H__
#include "ceo.h"
#endif

<<complex amplitude structure>>

struct source {

  <<source parameters>>

  void setup(float zenith, float azimuth, float height);
  void setup(float zenith, float azimuth, float height, int resolution);
  void setup(float *_zenith, float *_azimuth, float _height, int _N_SRC);
  void setup(float *_zenith, float *_azimuth, float _height, int _N_SRC, int resolution);
  void cleanup(void);

  void info(void);

  float wavelength(void);

  float n_photon(void);
};
#endif // __SOURCE_H__
@
\subsubsection{Source}

<<source.cu>>=
#include "source.h"

<<square geometry>>

<<complex amplitude setup>>
<<complex amplitude cleanup>>
<<phase to file>>

<<setup>>
<<setup with wavefront resolution>>
<<setup for multiple sources>>
<<setup for multiple sources with wavefront resolution>>
<<cleanup>>

<<info>>

<<wavelength>>
   
<<number of photons>>
@
\subsection{Parameters}
\label{sec:params}

The source structure is a collection of [[N_SRC]] light sources.
<<source parameters>>=
int N_SRC;
@ 
The source locations are given by their [[zenith]] and [[azimuth]] angles, all the sources share the same height.
<<source parameters>>=
float zenith, azimuth, height, theta_x, theta_y;
@ The coordinates of the unit vector pointing towards the sources are given by [[theta_x]] and [[theta_y]].
The wavefront is the complex amplitude of the light beam.
It is given by its amplitude and phase, both are arrays of [[N_PX]] values.
The complex amplitude is defined in a new structure:
<<complex amplitude structure>>=
struct complex_amplitude {

  <<complex amplitude parameters>>

  void setup(int n_pixel);
  void cleanup(void);

  void phase2file(const char *filename);

};
@ with the parameters: 
<<complex amplitude parameters>>=
int N_PX;
float *amplitude, *phase;
@ The physical extent of the amplitude is set by the pupil mask:
<<complex amplitude parameters>>=
char *pupil_mask;
@ The magnitude at a given photometric band are set with:
<<source parameters>>=
char *photometric_band;float magnitude;
@ If the source is resolved by the  optical system, one must define its normalized irradiance map
<<source parameters>>=
float *irradiance, *irradiance_ft;
@ The irradiance is normalized such as is sum is equal to 1. The Fourier transform of the irradiance map must be given too.
The wavefront is added to the source
<<source parameters>>=
complex_amplitude wavefront;
@ Source structures will be allocated on the device:
<<source parameters>>=
source *dev_ptr;
@ 
\subsection{Functions}
\label{sec:functions}

The main parameters of the  atmosphere are displayed with the [[info]] routine:
<<info>>=
  void source::info(void)
{
  printf("\n\x1B[1;42m@(CEO)>source\x1B[;42m\n");
  printf(" zen[arcsec] azim[deg]  height[m]  lambda[micron] magnitude\n");
  printf(" %5.2f      %6.2f    %8.2f\n",
	 zenith*RADIAN2ARCSEC,
	 azimuth*180.0/PI,height);
  if (wavefront.N_PX>0)
    printf(" wavefront pixel sampling: %d\n",wavefront.N_PX);
  printf("----------------------------------------------------\x1B[0m\n");
}

@  The [[wavelength]] in \textsl{micron} corresponding to the photometric band is given by
<<wavelength>>=
float source::wavelength(void) {
  if (strcmp(photometric_band,"V")==0)
    return 0.550;
  if (strcmp(photometric_band,"R")==0)
    return 0.640;
  if (strcmp(photometric_band,"I")==0)
    return 0.790;
  if (strcmp(photometric_band,"J")==0)
    return 1.215;
  if (strcmp(photometric_band,"H")==0)
    return 1.654;
  if (strcmp(photometric_band,"K")==0)
    return 2.179;
  if (strcmp(photometric_band,"Ks")==0)
    return 2.157;
  if (strcmp(photometric_band,"Na")==0)
    return 0.589;
  return 0;
}
@ The number of photon in $m^{-2}.s^{-1}$ is derived with
<<number of photons>>=
float source::n_photon(void) {
  float zero_point;
  if (strcmp(photometric_band,"V")==0)
    zero_point = 3.3e12;
  if (strcmp(photometric_band,"R")==0)
    zero_point = 4.0e12 ;
  if (strcmp(photometric_band,"I")==0)
    zero_point = 2.7e12;
  if (strcmp(photometric_band,"J")==0)
    zero_point = 1.9e12;
  if (strcmp(photometric_band,"H")==0)
    zero_point = 1.1e12;
  if (strcmp(photometric_band,"K")==0)
    zero_point = 7.0e11;
  if (strcmp(photometric_band,"Ks")==0)
    zero_point = 5.5e11;
  if (strcmp(photometric_band,"Na")==0)
    zero_point =3.3e12 ;
  return zero_point*powf(10 , -0.4*magnitude );
}
@ Sources are initialized with the setup function:
\begin{itemize}
\item for a single source:
<<setup>>=
void source::setup(float _zenith, float _azimuth, float _height) {
  N_SRC   = 1;
  zenith  = _zenith;
  azimuth = _azimuth;
  height  = _height;
  theta_x = tanf(zenith)*cosf(azimuth);
  theta_y = tanf(zenith)*sinf(azimuth);
  info();
  /*
  for (int k=0;k<_SOURCE_N_PX_;k++) {
    amplitude[k] = 1.0;
    phase[k]     = 0.0;    
  }
  */
  source __src;
  __src.zenith  = zenith;
  __src.azimuth = azimuth;
  __src.height  = height;
  __src.theta_x = theta_x;
  __src.theta_y = theta_y;
  HANDLE_ERROR( cudaMalloc( (void**)&dev_ptr, sizeof(source) ) );
  HANDLE_ERROR( cudaMemcpy( dev_ptr, &__src,
			    sizeof(source) ,
			    cudaMemcpyHostToDevice ) );
  wavefront.setup(_SOURCE_N_PX_);
}
@ \item for a single source with wavefront resolution:
<<setup with wavefront resolution>>=
void source::setup(float _zenith, float _azimuth, float _height, int resolution) {
  N_SRC   = 1;
  zenith  = _zenith;
  azimuth = _azimuth;
  height  = _height;
  theta_x = tanf(zenith)*cosf(azimuth);
  theta_y = tanf(zenith)*sinf(azimuth);
  /*
  for (int k=0;k<_SOURCE_N_PX_;k++) {
    amplitude[k] = 1.0;
    phase[k]     = 0.0;    
  }
  */
  source __src;
  __src.zenith  = zenith;
  __src.azimuth = azimuth;
  __src.height  = height;
  __src.theta_x = theta_x;
  __src.theta_y = theta_y;
  HANDLE_ERROR( cudaMalloc( (void**)&dev_ptr, sizeof(source) ) );
  HANDLE_ERROR( cudaMemcpy( dev_ptr, &__src,
			    sizeof(source) ,
			    cudaMemcpyHostToDevice ) );
  wavefront.setup(resolution);
  info();
}
@ \item for multiple sources:
<<setup for multiple sources>>=
void source::setup(float *_zenith, float *_azimuth, float _height, int _N_SRC) {
  N_SRC = _N_SRC;
  height = _height;
  source __src;
  HANDLE_ERROR( cudaMalloc( (void**)&dev_ptr, sizeof(source)*N_SRC ) );
  printf("\n\x1B[1;42m@(CEO)>source\x1B[;42m\n");
  printf(" zen[arcsec] azim[deg]  height[m]  lambda[micron] magnitude\n");
  for (int i_SRC=0;i_SRC<N_SRC;i_SRC++) {
    __src.zenith  = _zenith[i_SRC];
    __src.azimuth = _azimuth[i_SRC];
    __src.height  = _height;
    __src.theta_x = tanf(_zenith[i_SRC])*cosf(_azimuth[i_SRC]);
    __src.theta_y = tanf(_zenith[i_SRC])*sinf(_azimuth[i_SRC]);
    HANDLE_ERROR( cudaMemcpy( dev_ptr + i_SRC, &__src,
			      sizeof(source) ,
			      cudaMemcpyHostToDevice ) );
    printf(" %5.2f      %6.2f    %8.2f\n",
                        _zenith[i_SRC]*RADIAN2ARCSEC,
                        _azimuth[i_SRC]*180/PI,_height);
  }
  printf("----------------------------------------------------\x1B[0m\n");
  wavefront.setup(_SOURCE_N_PX_*N_SRC);
}
@  \item for multiple sourcese with wavefront resolution:
<<setup for multiple sources with wavefront resolution>>=
void source::setup(float *_zenith, float *_azimuth, float _height, int _N_SRC, int resolution) {
  N_SRC = _N_SRC;
  height = _height;
  source __src;
  HANDLE_ERROR( cudaMalloc( (void**)&dev_ptr, sizeof(source)*N_SRC ) );
  printf("\n\x1B[1;42m@(CEO)>source\x1B[;42m\n");
  printf(" zen[arcsec] azim[deg]  height[m]  lambda[micron] magnitude\n");
  for (int i_SRC=0;i_SRC<N_SRC;i_SRC++) {
    __src.zenith  = _zenith[i_SRC];
    __src.azimuth = _azimuth[i_SRC];
    __src.height  = _height;
    __src.theta_x = tanf(_zenith[i_SRC])*cosf(_azimuth[i_SRC]);
    __src.theta_y = tanf(_zenith[i_SRC])*sinf(_azimuth[i_SRC]);
    HANDLE_ERROR( cudaMemcpy( dev_ptr + i_SRC, &__src,
			      sizeof(source) ,
			      cudaMemcpyHostToDevice ) );
    printf(" %5.2f      %6.2f    %8.2f\n",
                        _zenith[i_SRC]*RADIAN2ARCSEC,
                        _azimuth[i_SRC]*180/PI,_height);
  }
  printf("----------------------------------------------------\x1B[0m\n");
  wavefront.setup(resolution*N_SRC);
}
@ \end{itemize}
The complex amplitude structure is initialized with
<<complex amplitude setup>>=
void complex_amplitude::setup(int n_pixel) {
  N_PX = n_pixel;
  if (N_PX>0) {
    HANDLE_ERROR( cudaMalloc( (void**)&amplitude,  sizeof(float)*N_PX ) );
    HANDLE_ERROR( cudaMalloc( (void**)&phase,      sizeof(float)*N_PX ) );
    HANDLE_ERROR( cudaMalloc( (void**)&pupil_mask, sizeof(char)*N_PX ) );
  }
}
@ and memory is de--allocated with:
<<complex amplitude cleanup>>=
void complex_amplitude::cleanup(void) {
  if (N_PX>0) {
    HANDLE_ERROR( cudaFree( amplitude ) );
    HANDLE_ERROR( cudaFree( phase ) );
    HANDLE_ERROR( cudaFree( pupil_mask ) );
  }
}
@ Allocated variable are freed with the [[cleanup]] routine
<<cleanup>>=
void source::cleanup(void) {
  fprintf(stderr,"@(CEO)>source: freeing memory!\n");
  HANDLE_ERROR( cudaFree( dev_ptr) );
  wavefront.cleanup();
}
@ 
The amplitude and phase are initialized to respectively 1 and 0:
<<square geometry>>=
__global__ void squarePupil(float* amplitude, float *phase) {
  int id;
  id = blockIdx.x * blockDim.x + threadIdx.x;
  if (id<_SOURCE_N_PX_) {
    amplitude[id] = 1.0;
    phase[id]     = 0.0;
  }
}
@ The wavefront phase is save to a file with
<<phase to file>>=
void complex_amplitude::phase2file(const char *filename) {
  dev2file(filename,phase,N_PX);
}
