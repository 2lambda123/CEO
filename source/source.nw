% -*- mode: Noweb; noweb-code-mode: c-mode -*-
The source structure is written in the header:
<<source.h>>=
#ifndef __SOURCE_H__
#define __SOURCE_H__

#ifndef __CEO_H__
#include "ceo.h"
#endif

struct complex_amplitude {

  <<complex_amplitude parameters>>

  void setup(int n_pixel);
  void cleanup(void);
};

struct source {

  <<source parameters>>

  void setup(float zenith, float azimuth, float height);
  void cleanup(void);

  void info(void);

  float wavelength(void);

  float n_photon(void);
};
#endif // __SOURCE_H__
@ The routines are expanded in the source:
<<source.cu>>=
#include "source.h"

<<square geometry>>

<<complex_amplitude setup>>
<<complex_amplitude cleanup>>

<<setup>>
<<cleanup>>

<<info>>

<<wavelength>>
   
<<number of photons>>
@
The wavefront descibes the wave complex amplitude of the light source.
The complex amplitude consists of the amplitude and the phase of the wave:
<<complex_amplitude parameters>>=
int N_PX;
float *amplitude, *phase;
@ The physical extent of the amplitude is set by the pupil mask:
<<complex_amplitude parameters>>=
char *pupil_mask;

@
The source specify a celestial object by its coordinates:
<<source parameters>>=
float zenith, azimuth, height;
@  and magnitude at a given photometric band.
<<source parameters>>=
char *photometric_band;float magnitude;
@ 
The main parameters of the  atmosphere are displayed with the [[info]] routine:
<<info>>=
void source::info(void)
{
printf("\n\x1B[1;42m@(CEO)>source\x1B[;42m\n");
printf(" zen[arcsec] azim[deg]  height[m]  lambda[micron] magnitude\n");
printf(" %5.2f      %6.2f    %8.2f\n",
                        zenith*RADIAN2ARCSEC,
                        azimuth*180/PI,height);
printf("----------------------------------------------------\x1B[0m\n");
}

@  The [[wavelength]] in \textsl{micron} corresponding to the photometric band is given by
<<wavelength>>=
float source::wavelength(void) {
  if (strcmp(photometric_band,"V")==0)
    return 0.550;
  if (strcmp(photometric_band,"R")==0)
    return 0.640;
  if (strcmp(photometric_band,"I")==0)
    return 0.790;
  if (strcmp(photometric_band,"J")==0)
    return 1.215;
  if (strcmp(photometric_band,"H")==0)
    return 1.654;
  if (strcmp(photometric_band,"K")==0)
    return 2.179;
  if (strcmp(photometric_band,"Ks")==0)
    return 2.157;
  if (strcmp(photometric_band,"Na")==0)
    return 0.589;
  return 0;
}
@ The number of photon in $m^{-2}.s^{-1}$ is derived with
<<number of photons>>=
float source::n_photon(void) {
  float zero_point;
  if (strcmp(photometric_band,"V")==0)
    zero_point = 3.3e12;
  if (strcmp(photometric_band,"R")==0)
    zero_point = 4.0e12 ;
  if (strcmp(photometric_band,"I")==0)
    zero_point = 2.7e12;
  if (strcmp(photometric_band,"J")==0)
    zero_point = 1.9e12;
  if (strcmp(photometric_band,"H")==0)
    zero_point = 1.1e12;
  if (strcmp(photometric_band,"K")==0)
    zero_point = 7.0e11;
  if (strcmp(photometric_band,"Ks")==0)
    zero_point = 5.5e11;
  if (strcmp(photometric_band,"Na")==0)
    zero_point =3.3e12 ;
  return zero_point*powf(10 , -0.4*magnitude );
}
@ If the source is resolved by the  optical system, one must define its normalized irradiance map
<<source parameters>>=
float *irradiance, *irradiance_ft;
@ The irradiance is normalized such as is sum is equal to 1. The Fourier transform of the irradiance map must be given too.
 The last parameter is the complex amplitude of the wavefront associated with the source,
<<source parameters>>=
float amplitude[_SOURCE_N_PX_], phase[_SOURCE_N_PX_];
@ that is given as amplitude and phase.
The direction  towards the source from the origin of coordinates is given by the components $\theta_x,\theta_y$ of the direction vector:
<<source parameters>>=
float theta_x, theta_y;
@ The wavefront is finally added to the source
<<source parameters>>=
complex_amplitude wavefront;
source *dev_ptr;
@ This components are computed with the setup function
<<setup>>=
void source::setup(float _zenith, float _azimuth, float _height) {
  zenith  = _zenith;
  azimuth = _azimuth;
  height  = _height;
  theta_x = tanf(zenith)*cosf(azimuth);
  theta_y = tanf(zenith)*sinf(azimuth);
  info();
  /*
  for (int k=0;k<_SOURCE_N_PX_;k++) {
    amplitude[k] = 1.0;
    phase[k]     = 0.0;    
  }
  */
  source __src;
  __src.zenith  = zenith;
  __src.azimuth = azimuth;
  __src.height  = height;
  __src.theta_x = theta_x;
  __src.theta_y = theta_y;
  HANDLE_ERROR( cudaMalloc( (void**)&dev_ptr, sizeof(source) ) );
  HANDLE_ERROR( cudaMemcpy( dev_ptr, &__src,
			    sizeof(source) ,
			    cudaMemcpyHostToDevice ) );
  wavefront.setup(_SOURCE_N_PX_);
}
<<complex_amplitude setup>>=
void complex_amplitude::setup(int n_pixel) {
  N_PX = n_pixel;
  HANDLE_ERROR( cudaMalloc( (void**)&amplitude,  sizeof(float)*N_PX ) );
  HANDLE_ERROR( cudaMalloc( (void**)&phase,      sizeof(float)*N_PX ) );
  HANDLE_ERROR( cudaMalloc( (void**)&pupil_mask, sizeof(char)*N_PX ) );
}
<<complex_amplitude cleanup>>=
void complex_amplitude::cleanup(void) {
  HANDLE_ERROR( cudaFree( amplitude ) );
  HANDLE_ERROR( cudaFree( phase ) );
  HANDLE_ERROR( cudaFree( pupil_mask ) );
}
@ Allocated variable are freed with the [[cleanup]] routine
<<cleanup>>=
void source::cleanup(void) {
  printf("\n@(CEO)>source: freeing memory!\n");
  HANDLE_ERROR( cudaFree( dev_ptr) );
  wavefront.cleanup();
}
@ 
The amplitude and phase are initialized to respectively 1 and 0:
<<square geometry>>=
__global__ void squarePupil(float* amplitude, float *phase) {
  int id;
  id = blockIdx.x * blockDim.x + threadIdx.x;
  if (id<_SOURCE_N_PX_) {
    amplitude[id] = 1.0;
    phase[id]     = 0.0;
  }
}
