% -*- mode: Noweb; noweb-code-mode: python-mode -*-
@

The source structure contains all the data associated with a remote optical emitter: its location, wavefront, irradiance, ...

\section{The files}

\subsection{Header}

<<source.h>>=
#ifndef __SOURCE_H__
#define __SOURCE_H__

#ifndef __UTILITIES_H__
#include "utilities.h"
#endif

#ifndef __PLOTLY_H__
#include "plotly.h"
#endif

#ifndef __RAYTRACING_H__
#include "rayTracing.h"
#endif

<<complex amplitude structure>>

struct source {

  <<source parameters>>

  void setup(char *_photometric_band, 
	     float zenith, float azimuth, float height);
  void setup(char *_photometric_band, 
	     float zenith, float azimuth, float height, 
	     int resolution);
  void setup(char *_photometric_band, 
	     float zenith, float azimuth, float height, 
	     char *tag_in);
  void setup(char *_photometric_band, 
	     float zenith, float azimuth, float height, 
	     int resolution, char *tag_in);
  void setup(char *_photometric_band, 
	     float *_zenith, float *_azimuth, float _height, 
	     int _N_SRC);
  void setup(char *_photometric_band, 
	     float *_zenith, float *_azimuth, float _height, 
	     int _N_SRC, int resolution);
  void setup(char *_photometric_band, 
	     float *_zenith, float *_azimuth, float _height, 
	     int _N_SRC, int resolution,
	     rtd _L_, int _N_L_, vector origin);
  void cleanup(void);

  void reset_rays(void);

  void trace(gmt_m1 *M1);
  void trace(gmt_m2 *M2);
  void block(gmt_m2 *M2);
  void opd2phase(void);
   
  void info(void);

  void phase2file(const char *filename);

  float wavelength(void);
  float n_photon(void);
  float wavenumber(void);

};
#endif // __SOURCE_H__
@
\subsection{Source}

<<source.cu>>=
#include "source.h"

<<square geometry>>
<<apply mask>>
<<piston removal>>

<<complex amplitude setup I>>
<<complex amplitude setup II>>
<<complex amplitude cleanup>>
<<resetting the wavefront>>
<<resetting the wavefront to new wavefront>>
<<adding wavefront phase>>
<<masking wavefront amplitude I>>
<<masking wavefront amplitude II>>

<<phase to file>>

<<bundle coordinates kernel>>
<<bundle coordinates kernel (box)>>
<<gathering wavefront kernel>>

<<setup>>
<<setup with wavefront resolution>>
<<setup with tag>>
<<setup with wavefront resolution and tag>>
<<setup for multiple sources>>
<<setup for multiple sources with wavefront resolution>>
<<setup for multiple sources with wavefront resolution and ray bundle>>
<<cleanup>>

<<reset rays>>
<<ray tracing>>

<<info>>

<<wavelength>>
<<number of photons>>
<<wavenumber>>
<<plot phase>>
<<plot amplitude I>>
<<plot amplitude II>>
@
\subsection{Python}
\label{sec:python}

<<ceo.pxd>>=
cdef extern from "rayTracing.h":
    ctypedef double rtd
cdef extern from "source.h":
    cdef cppclass complex_amplitude:
        float *phase
        void reset()
        void masked(mask *)
        void masked()
        void add_phase(float , float *)
    cdef cppclass source:
        int N_SRC
        char *photometric_band
        float fwhm, magnitude
        complex_amplitude wavefront
        bundle rays
        void setup(char *,float , float , float )
	void setup(char *,float , float , float , int )
        void setup(char *,float *, float *, float , int , int )
        void setup(char *,float *, float *, float , int , int , rtd, int, vector)
        void cleanup()
        void reset_rays()
        void trace(gmt_m1 *)
        void trace(gmt_m2 *)
        void block(gmt_m2 *)
        void opd2phase()
        void info()
        float n_photon()
@ 
<<ceo.pyx>>=
@cython.boundscheck(False)
@cython.wraparound(False)
cdef class Source:
    """ 
    A class to represent an astronomical source

    Parameters
    ----------
    photometric_band: char
        The sources photometric band
    zenith: an object
        The sources zenith angles [rd].
    azimuth: an object
        The sources azimuth angles [rd].
    height: number
        The sources altitude [m].
    resolution: a list or tuple with 2 arguments
        The sampling [n,m] in pixel of the source wavefront complex amplitude.
    
    Returns
    -------
    out: Source
        A Source object.

    Examples
    --------
    import numpy as np
    import ceo

    n   = 1024
    src = ceo.Source("K",resolution=(n,n))

    zen = np.arange(3,dtype=np.float32)*1e-6*25
    azi = np.arange(3,dtype=np.float32)*3.14
    lgs = ceo.Source("R",zenith=zen,azimuth=azi,height=90e3,resolution=(n,n)) 

    """
    cdef ceo.source *_c_source
    cdef int n, m
    cdef public int size
    cdef public np.ndarray zenith, azimuth
    cdef public float height
    cdef public object rays

    def __cinit__(self,char *_photometric_band,  
		  zenith=0, azimuth=0, 
                  magnitude=None,
		  height=float("inf"), 
		  resolution = (0,0),
		  fwhm = None,
                  rays_box_size=None, 
		  rays_box_sampling=None, 
		  rays_origin=None):
        """
        Instanciates a Source object
        """
	self._c_source = new ceo.source()
        self.n = resolution[0]
        self.m = resolution[1]
        self.zenith  = np.array( zenith,  dtype=np.float32)
        self.azimuth = np.array( azimuth, dtype=np.float32)
        self.height  = float(height);
        self.size = self.zenith.size
        cdef vector _origin_
        if rays_box_size is None:
            self._c_source.setup(_photometric_band, 
                                 <float *>self.zenith.data, 
                                 <float *>self.azimuth.data, height, 
                                 self.size, np.prod(resolution))
        else:
            _origin_.x = <float>rays_origin[0]
            _origin_.y = <float>rays_origin[1]
            _origin_.z = <float>rays_origin[2]
            self._c_source.setup(_photometric_band, 
                                 <float *>self.zenith.data, 
                                 <float *>self.azimuth.data, height, 
                                 self.size, np.prod(resolution),
                                 rays_box_size, 
				 rays_box_sampling, 
				 _origin_)
        if magnitude is not None:
            self._c_source.magnitude = magnitude
        if fwhm is not None:
            self._c_source.fwhm = fwhm
        self.rays = ceo.Bundle(self)

    def __dealloc__(self):
        self._c_source.cleanup()

    def trace(self, optics):
        optics.trace(self.rays)

    def stop(self, optics):
        optics.blocking(self.rays)

    def opd2phase(self):
        self._c_source.opd2phase()
            

    property phase:
        def __get__(self):
            """
            Returns the wavefront phase as a cuFloatArray object
            
            See also
            --------
            cuFloatArray
            """
            x = cuFloatArray(shape=(self.n*self.size,self.m))
            x._c_gpu.dev_data = self._c_source.wavefront.phase
            return x
        def __set__(self,cuFloatArray val):
            self._c_source.wavefront.add_phase(1,val._c_gpu.dev_data)

    property nPhoton:
        def __get__(self):
            """
            Returns the number of photon per second
            """
            return self._c_source.n_photon()

    property magnitude:
        def __set__(self,value):
            """
            Sets the source magnitude
            """
            self._c_source.magnitude = value
           
    def masked(self, MaskAbstract tel):
        """
        Apply the binary mask of the telescope pupil to the source wavefront

        Parameters
        ----------
        mask: Mask structure
            The binary mask structure
        """
        self._c_source.wavefront.masked(tel._c_mask)

    def masked(self):
        """
        Apply the binary mask of the telescope pupil to the source wavefront
        """    
        self._c_source.wavefront.masked()
    
    def reset(self):
        """
        Reset the wavefront amplitude to 1 and phase to 0
        """
        self._c_source.wavefront.reset()
        self._c_source.reset_rays()
@

\section{Parameters}
\label{sec:params}

The source structure is a collection of [[N_SRC]] light sources.
<<source parameters>>=
int N_SRC;
@ 
The source locations are given by their [[zenith]] and [[azimuth]] angles, all the sources share the same height.
<<source parameters>>=
float zenith, azimuth, height, theta_x, theta_y;
@ The coordinates of the unit vector pointing towards the sources are given by [[theta_x]] and [[theta_y]].
The wavefront is the complex amplitude of the light beam.
It is given by its amplitude and phase, both are arrays of [[N_PX]] values.
The complex amplitude is defined in a new structure:
<<complex amplitude structure>>=
struct complex_amplitude {

  <<complex amplitude parameters>>

  void setup(int n_pixel);
  void setup(int n_pixel, int n_src);
  void cleanup(void);
  void reset(void);
  void reset(complex_amplitude wavefront_prime);
  void add_phase(float alpha, float *phase_prime);
  void masked(void);
  void masked(mask *M_in);
  void show_phase(char *filename);
  void show_phase(char *filename, int N_SRC);
  void show_amplitude(char *filename);
  void show_amplitude(char *filename, int N, int M);
};
@ with the parameters: 
<<complex amplitude parameters>>=
int N_PX, N;
float *amplitude, *phase;
@ The physical extent of the amplitude is set by the pupil mask:
<<complex amplitude parameters>>=
mask *M;
@ The magnitude at a given photometric band are set with:
<<source parameters>>=
char *photometric_band;
float magnitude;
@ If the source is resolved by the  optical system, the irradiance is assumed to have a Gaussian shape of full width a half maximum [[fwhm]]
<<source parameters>>=
float fwhm;
@  The wavefront is added to the source
<<source parameters>>=
complex_amplitude wavefront;
@ Source structures will be allocated on the device:
<<source parameters>>=
source *dev_ptr;
@ and the source can be tagged with
<<source parameters>>=
char tag[8];
@ A source can also be propagated geometrically through optical components
<<source parameters>>=
bundle rays; 
@
\section{Functions}
\label{sec:functions}

@
\subsection{Setup \& cleanup}
\label{sec:setup--cleanup}

Sources are initialized with the setup function:
\begin{itemize}
\item for a single source:
<<setup>>=
void source::setup(char *_photometric_band, 
		   float _zenith, float _azimuth, 
		   float _height) {
  <<setup single source contents>>
  wavefront.setup(0);
  strcpy(tag,"source");
  info();
}
@ \item for a single source with wavefront resolution:
<<setup with wavefront resolution>>=
void source::setup(char *_photometric_band, 
		   float _zenith, float _azimuth, 
		   float _height, int resolution) {
  <<setup single source contents>>
  wavefront.setup(resolution);
  strcpy(tag,"source");
  info();
}
@ \item for a single source with tag:
<<setup with tag>>=
void source::setup(char *_photometric_band, 
		   float _zenith, float _azimuth, 
		   float _height, char *tag_in) {
  <<setup single source contents>>
  wavefront.setup(0);
  strcpy(tag,tag_in);
  info();
}
@ \item for a single source with wavefront resolution and tag:
<<setup with wavefront resolution and tag>>=
void source::setup(char *_photometric_band, 
		   float _zenith, float _azimuth, float _height, 
		   int resolution, char *tag_in) {
  <<setup single source contents>>
  wavefront.setup(resolution);
  strcpy(tag,tag_in);
  info();
}
@ with
<<setup single source contents>>=
N_SRC   = 1;
zenith  = _zenith;
azimuth = _azimuth;
height  = _height;
theta_x = tanf(zenith)*cosf(azimuth);
theta_y = tanf(zenith)*sinf(azimuth);
photometric_band = _photometric_band;
magnitude = 0.0;
fwhm = 0.0;
source __src;
__src.zenith  = zenith;
__src.azimuth = azimuth;
__src.height  = height;
__src.theta_x = theta_x;
__src.theta_y = theta_y;
HANDLE_ERROR( cudaMalloc( (void**)&dev_ptr, sizeof(source) ) );
HANDLE_ERROR( cudaMemcpy( dev_ptr, &__src,
                          sizeof(source) ,
                          cudaMemcpyHostToDevice ) );

@ \item for multiple sources:
<<setup for multiple sources>>=
void source::setup(char *_photometric_band, 
		   float *_zenith, float *_azimuth, 
		   float _height, int _N_SRC) {
  N_SRC = _N_SRC;
  height = _height;
  photometric_band = _photometric_band;
  magnitude = 0.0;
  fwhm = 0.0;
  source __src;
  HANDLE_ERROR( cudaMalloc( (void**)&dev_ptr, sizeof(source)*N_SRC ) );
  strcpy(tag,"sources");
  fprintf(stdout,"\n\x1B[1;42m@(CEO)>%s:\x1B[;42m\n",tag);
  fprintf(stdout," zen[arcsec] azim[deg]  height[m]  lambda[micron] magnitude\n");
  for (int i_SRC=0;i_SRC<N_SRC;i_SRC++) {
    __src.zenith  = _zenith[i_SRC];
    __src.azimuth = _azimuth[i_SRC];
    __src.height  = _height;
    __src.theta_x = tanf(_zenith[i_SRC])*cosf(_azimuth[i_SRC]);
    __src.theta_y = tanf(_zenith[i_SRC])*sinf(_azimuth[i_SRC]);
    HANDLE_ERROR( cudaMemcpy( dev_ptr + i_SRC, &__src,
			      sizeof(source) ,
			      cudaMemcpyHostToDevice ) );
    fprintf(stdout," %5.2f      %6.2f    %8.2f       %5.3f    %4.1f\n",
	    _zenith[i_SRC]*RADIAN2ARCSEC,
	    _azimuth[i_SRC]*180/PI,_height,
	    wavelength(),magnitude);
  }
  fprintf(stdout,"----------------------------------------------------\x1B[0m\n");
  wavefront.setup(0);
}
@  \item for multiple sources with wavefront resolution:
<<setup for multiple sources with wavefront resolution>>=
void source::setup(char *_photometric_band, 
		   float *_zenith, float *_azimuth, float _height, 
		   int _N_SRC, int resolution) {
  N_SRC = _N_SRC;
  height = _height;
  photometric_band = _photometric_band;
  magnitude = 0.0;
  fwhm = 0.0;
  source __src;
  HANDLE_ERROR( cudaMalloc( (void**)&dev_ptr, sizeof(source)*N_SRC ) );
  strcpy(tag,"sources");
  fprintf(stdout,"\n\x1B[1;42m@(CEO)>%s:\x1B[;42m\n",tag);
  fprintf(stdout," zen[arcsec] azim[deg]  height[m]  lambda[micron] magnitude\n");
  for (int i_SRC=0;i_SRC<N_SRC;i_SRC++) {
    __src.zenith  = _zenith[i_SRC];
    __src.azimuth = _azimuth[i_SRC];
    __src.height  = _height;
    __src.theta_x = tanf(_zenith[i_SRC])*cosf(_azimuth[i_SRC]);
    __src.theta_y = tanf(_zenith[i_SRC])*sinf(_azimuth[i_SRC]);
    HANDLE_ERROR( cudaMemcpy( dev_ptr + i_SRC, &__src,
			      sizeof(source) ,
			      cudaMemcpyHostToDevice ) );
    fprintf(stdout," %5.2f      %6.2f    %8.2f       %5.3f    %4.1f\n",
	    _zenith[i_SRC]*RADIAN2ARCSEC,
	    _azimuth[i_SRC]*180/PI,_height,
	    wavelength(),magnitude);
  }
  wavefront.setup(resolution,N_SRC);
  fprintf(stdout," wavefront pixel sampling: %d\n",wavefront.N_PX);
  fprintf(stdout,"----------------------------------------------------\x1B[0m\n");
}
@  \item for multiple sources with wavefront resolution and with ray bundle:
<<setup for multiple sources with wavefront resolution and ray bundle>>=
void source::setup(char *_photometric_band, 
		   float *_zenith, float *_azimuth, float _height, 
		   int _N_SRC, int resolution,
                   rtd L, int N_L, vector origin) {
  N_SRC = _N_SRC;
  height = _height;
  photometric_band = _photometric_band;
  magnitude = 0.0;
  fwhm = 0.0;
  source __src;
  HANDLE_ERROR( cudaMalloc( (void**)&dev_ptr, sizeof(source)*N_SRC ) );
  strcpy(tag,"sources");
  fprintf(stdout,"\n\x1B[1;42m@(CEO)>%s:\x1B[;42m\n",tag);
  fprintf(stdout," zen[arcsec] azim[deg]  height[m]  lambda[micron] magnitude\n");
  for (int i_SRC=0;i_SRC<N_SRC;i_SRC++) {
    __src.zenith  = _zenith[i_SRC];
    __src.azimuth = _azimuth[i_SRC];
    __src.height  = _height;
    __src.theta_x = tanf(_zenith[i_SRC])*cosf(_azimuth[i_SRC]);
    __src.theta_y = tanf(_zenith[i_SRC])*sinf(_azimuth[i_SRC]);
    HANDLE_ERROR( cudaMemcpy( dev_ptr + i_SRC, &__src,
			      sizeof(source) ,
			      cudaMemcpyHostToDevice ) );
    fprintf(stdout," %5.2f      %6.2f    %8.2f       %5.3f    %4.1f\n",
	    _zenith[i_SRC]*RADIAN2ARCSEC,
	    _azimuth[i_SRC]*180/PI,_height,
	    wavelength(),magnitude);
  }
  wavefront.setup(resolution,N_SRC);
  fprintf(stdout," wavefront pixel sampling: %d\n",wavefront.N_PX);
  rays.setup(L, N_L, origin, N_SRC);
  reset_rays();
  fprintf(stdout,"----------------------------------------------------\x1B[0m\n");
}
@ with
<<reset rays>>=
void source::reset_rays(void)
{
  dim3 blockDim(1,1);
  dim3 gridDim(1,1, rays.N_BUNDLE);
  ray_coordinates LLL gridDim , blockDim RRR (rays.d__chief_ray, 1, 
                                              dev_ptr,
                                              0.0, 2, 1, rays.d__origin);
  blockDim = dim3(16,16);
  gridDim  = dim3(rays.N_L/16+1,rays.N_L/16+1, rays.N_BUNDLE);
  ray_coordinates_box LLL gridDim , blockDim RRR (rays.d__ray, rays.N_RAY, 
                                                  dev_ptr,
                                                  rays.L, rays.N_L, 
                                                  rays.d__origin);    
}
@ and
<<bundle coordinates kernel>>=
__global__ void ray_coordinates(ray *d__ray, int N_RAY, source *src,
                                rtd RADIUS, int N_RADIUS, int N_THETA, 
                                vector *origin)
{
  int i, j, k, iSource;
  rtd rho, theta;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  iSource = blockIdx.z;
  //k = j * gridDim.x * blockDim.x + i;
  if ( (i<N_RADIUS) && (j<N_THETA) )
  {
    rho   = RADIUS*i/(N_RADIUS-1);
    if (i==0) {
      j = 0;
      k = 0;
    } else
      k = j + (i - 1)*N_THETA + 1;
    k += iSource*N_RAY;
    theta = 2*PI*j/N_THETA; 
    d__ray[k].coordinates.x = rho*cos(theta) + origin->x; 
    d__ray[k].coordinates.y = rho*sin(theta) + origin->y; 
    d__ray[k].coordinates.z = origin->z;
    d__ray[k].directions.x  = sin(src[iSource].zenith)*cos(src[iSource].azimuth);
    d__ray[k].directions.y  = sin(src[iSource].zenith)*sin(src[iSource].azimuth);
    d__ray[k].directions.z  = cos(src[iSource].zenith);
    d__ray[k].optical_path_length = 0.0;
    d__ray[k].optical_path_difference = 0.0;
    d__ray[k].coordinates.x -= d__ray[k].coordinates.z*d__ray[k].directions.x;
    d__ray[k].coordinates.y -= d__ray[k].coordinates.z*d__ray[k].directions.y;
    d__ray[k].v = 1;
  }
}
@ and
<<bundle coordinates kernel (box)>>=
__global__ void ray_coordinates_box(ray *d__ray, int N_RAY, source *src,
                                    rtd L, int N_L, vector *origin)
{
  int i, j, k, iSource;
  rtd x, y;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  iSource = blockIdx.z;
  if ( (i<N_L) && (j<N_L) )
  {
    x   = L*(i - (N_L-1)*0.5)/(N_L-1);
    y   = L*(j - (N_L-1)*0.5)/(N_L-1);
    k = i + j*N_L + iSource*N_RAY;
    d__ray[k].coordinates.x = x + origin->x; 
    d__ray[k].coordinates.y = y + origin->y; 
    d__ray[k].coordinates.z = origin->z;
    d__ray[k].directions.x  = sin(src[iSource].zenith)*cos(src[iSource].azimuth);
    d__ray[k].directions.y  = sin(src[iSource].zenith)*sin(src[iSource].azimuth);
    d__ray[k].directions.z  = cos(src[iSource].zenith);
    d__ray[k].optical_path_length = 0.0;
    d__ray[k].optical_path_difference = 0.0;
    d__ray[k].coordinates.x -= d__ray[k].coordinates.z*d__ray[k].directions.x;
    d__ray[k].coordinates.y -= d__ray[k].coordinates.z*d__ray[k].directions.y;
    d__ray[k].v = 1;
  }
}
@ \end{itemize}
@ 
The complex amplitude structure is initialized with
<<complex amplitude setup I>>=
void complex_amplitude::setup(int n_pixel) {
  N = 1;
  <<complex amplitude setup common>>
}
<<complex amplitude setup II>>=
void complex_amplitude::setup(int n_pixel, int n_src) {
  N = n_src;
  <<complex amplitude setup common>>
}
<<complex amplitude setup common>>=
N_PX = n_pixel*N;
M = NULL;
if (N_PX>0) {
  HANDLE_ERROR( cudaMalloc( (void**)&amplitude,  sizeof(float)*N_PX ) );
  HANDLE_ERROR( cudaMalloc( (void**)&phase,      sizeof(float)*N_PX ) );
  reset();
} else {
  amplitude  = NULL;
  phase      = NULL;
}

@ and memory is de--allocated with:
<<complex amplitude cleanup>>=
void complex_amplitude::cleanup(void) {
  if (N_PX>0) {
    HANDLE_ERROR( cudaFree( amplitude ) );
    HANDLE_ERROR( cudaFree( phase ) );
  }
}
@ Allocated variable are freed with the [[cleanup]] routine
<<cleanup>>=
void source::cleanup(void) {
  fprintf(stdout,"@(CEO)>%s: freeing memory!\n",tag);
//  fprintf(stdout," |-");
  wavefront.cleanup();
  fprintf(stdout," |-");
  rays.cleanup();
  HANDLE_ERROR( cudaFree( dev_ptr) );
}

@ 
The amplitude and phase are initialized to respectively 1 and 0:
<<square geometry>>=
  __global__ void squarePupil(float* amplitude, float *phase, const int N) {
  int id;
  id = blockIdx.x * blockDim.x + threadIdx.x;
  if (id<N) {
    amplitude[id] = 1.0;
    phase[id]     = 0.0;
  }
}

@

\subsection{Photometry}
\label{sec:photometry}

The [[wavelength]] in \textsl{micron} corresponding to the photometric band is given by
<<wavelength>>=
float source::wavelength(void) {
  float lambda;
  if (strcmp(photometric_band,"V")==0)
    lambda = 0.550;
  if (strcmp(photometric_band,"R")==0)
    lambda = 0.640;
  if (strcmp(photometric_band,"I")==0)
    lambda = 0.790;
  if (strcmp(photometric_band,"J")==0)
    lambda = 1.215;
  if (strcmp(photometric_band,"H")==0)
    lambda = 1.654;
  if (strcmp(photometric_band,"K")==0)
    lambda = 2.179;
  if (strcmp(photometric_band,"Ks")==0)
    lambda = 2.157;
  return lambda;
}
@ The number of photon in $m^{-2}.s^{-1}$ is derived with
<<number of photons>>=
float source::n_photon(void) {
  float zero_point;
  if (strcmp(photometric_band,"V")==0)
    zero_point = 8.97e9;
  if (strcmp(photometric_band,"R")==0)
    zero_point = 10.87e9 ;
  if (strcmp(photometric_band,"I")==0)
    zero_point = 7.34e9;
  if (strcmp(photometric_band,"J")==0)
    zero_point = 5.16e9;
  if (strcmp(photometric_band,"H")==0)
    zero_point = 2.99e9;
  if (strcmp(photometric_band,"K")==0)
    zero_point = 1.90e9;
  if (strcmp(photometric_band,"Ks")==0)
    zero_point = 1.49e19;
  return zero_point*powf(10 , -0.4*magnitude );
}
@ The wave number is given by
<<wavenumber>>=
float source::wavenumber(void) {
  float lambda;
  if (strcmp(photometric_band,"V")==0)
    lambda = 0.550;
  if (strcmp(photometric_band,"R")==0)
    lambda = 0.640;
  if (strcmp(photometric_band,"I")==0)
    lambda = 0.790;
  if (strcmp(photometric_band,"J")==0)
    lambda = 1.215;
  if (strcmp(photometric_band,"H")==0)
    lambda = 1.654;
  if (strcmp(photometric_band,"K")==0)
    lambda = 2.179;
  if (strcmp(photometric_band,"Ks")==0)
    lambda = 2.157;
  return 1E6*2*PI/lambda;
}

@
\subsection{Wavefront manipulation}
\label{sec:wavefr-manip}

\subsubsection{Resetting the wavefront}
\label{sec:resetting-wavefront}
The following resets the wavefront amplitude to zero and phase to 1:
<<resetting the wavefront>>=
void complex_amplitude::reset(void)
{
  dim3 blockDim(16,1);
  dim3 gridDim(N_PX/16+1,1);
  squarePupil LLL gridDim,blockDim RRR (amplitude, phase, N_PX);
  if (M!=NULL)
    apply_mask LLL gridDim,blockDim RRR (amplitude, phase, M->m, N_PX);  
}
@  masked following resets the wavefront phase to the phase of the new wavefront:
<<resetting the wavefront to new wavefront>>=
void complex_amplitude::reset(complex_amplitude wavefront_prime)
{
  reset();
  add_phase(1, wavefront_prime.phase);
}

@ 
\subsubsection{Adding wavefront phase}
\label{sec:adding-wavefr-phase}
The following adds a phase aberration to the wavefront phase $$\varphi = \varphi + \alpha \varphi^\prime$$:
<<adding wavefront phase>>=
void complex_amplitude::add_phase(float alpha, float *phase_prime)
{
  cublasHandle_t handle;
  cublasCreate(&handle);
  CUBLAS_ERROR( cublasSaxpy(handle, N_PX, &alpha, phase_prime, 1, phase, 1) );
  cublasDestroy(handle);
}

@
\subsubsection{Masking wavefront amplitude}
\label{sec:mask-wavefr-ampl}
The following applies the pupil mask to the wavefront:
<<masking wavefront amplitude I>>=
void complex_amplitude::masked(void)
{
<<masking wavefront common>>
}
@ 
<<masking wavefront amplitude II>>=
void complex_amplitude::masked(mask *M_in)
{
M = M_in;
<<masking wavefront common>>
}
@ with
<<masking wavefront common>>=
dim3 blockDim(16,1);
dim3 gridDim(N_PX/16+1,N);
apply_mask LLL gridDim,blockDim RRR (amplitude, phase, M->m, N_PX/N);  
@ and with the kernel:
<<apply mask>>=
__global__ void apply_mask(float* amplitude, float* phase, const char *pupil_mask, const int N) {
  int id;
  id = blockIdx.x * blockDim.x + threadIdx.x;
  if ( (id<N) && (pupil_mask[id]==0) ) {
    amplitude[id + blockIdx.y*N] = 0.0;
    phase[id + blockIdx.y*N]     = 0.0;
  }
}
@
\subsection{Ray tracing}
\label{sec:ray-tracing}

<<ray tracing>>=
void source::trace(gmt_m1 *M1)
{
  M1->trace(&rays);
}
void source::trace(gmt_m2 *M2)
{
  M2->trace(&rays);
}
void source::stop(gmt_m2 *M2)
{
  M2->blocking(&rays);
}
void source::opd2phase(void)
{
//  printf("Setting wavefront!\n");
  dim3 blockDim(16,16);
  dim3 gridDim(rays.N_RAY/256+1,1, rays.N_BUNDLE);
  opd2phase_kernel LLL gridDim , blockDim RRR (wavefront.amplitude, 
                                                   wavefront.phase,
						   rays.V.m,
                                                   rays.d__ray, rays.N_RAY);
  rays.V.set_filter();
  wavefront.masked(&(rays.V));
}
@ 
<<gathering wavefront kernel>>=
__global__ void opd2phase_kernel(float *amplitude, float *phase,
                                     char *m, ray *d__ray, int N_RAY)
{
  int i, j, k, iSource;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  iSource = blockIdx.z;
  k = j * gridDim.x * blockDim.x + i;
  if ( k<N_RAY )
    k += iSource*N_RAY;
    if (d__ray[k].v==1)
      {
	m[k]         = 1;
	amplitude[k] = 1.0;
	phase[k]     += d__ray[k].optical_path_difference;
      } else {
	m[k]         = 0;
	amplitude[k] = 0.0;
	phase[k]     = 0.0;
    }
}

@ 
\subsection{Input/Output}
\label{sec:inputoutput}

The main parameters of the source are displayed with the [[info]] routine:
<<info>>=
void source::info(void)
{
  fprintf(stdout,"\n\x1B[1;42m@(CEO)>%s:\x1B[;42m\n",tag);
  fprintf(stdout," zen[arcsec] azim[deg]  height[m]  lambda[micron] magnitude\n");
  fprintf(stdout," %5.2f      %6.2f    %8.2f       %5.3f    %4.1f\n",
	  zenith*RADIAN2ARCSEC,
	  azimuth*180.0/PI,height,wavelength(),
	  magnitude);
  if (wavefront.N_PX>0)
    fprintf(stdout," wavefront pixel sampling: %d\n",wavefront.N_PX);
  fprintf(stdout,"----------------------------------------------------\x1B[0m\n");
}

@ The wavefront phase is save to a file with
<<phase to file>>=
void source::phase2file(const char *filename) {
  dev2file(filename,wavefront.phase,wavefront.N_PX,wavefront.N_PX/N_SRC,N_SRC);
}

@ The wavefront phase is plotted with the plot.ly
<<plot phase>>=
void complex_amplitude::show_phase(char *filename)
{
  char title[1024];
  float *data, *d__data, alpha, piston;
  plotly_properties prop;
  stats S;

  HANDLE_ERROR( cudaMalloc((void**)&d__data, sizeof(float)*N_PX) );
  HANDLE_ERROR( cudaMemcpy( d__data, phase,
			    sizeof(float)*N_PX,
			    cudaMemcpyDeviceToDevice ) );

  S.setup();
  alpha = 1E9;
  CUBLAS_ERROR( cublasSscal(S.handle, N_PX, &alpha, d__data, 1) );
  
  
  if (M!=NULL) {

    int k, nel;
    char rms[32];
    nel = N_PX/N;
    dim3 blockDim(256);
    dim3 gridDim(N_PX/256+1);
    sprintf(title,"RMS=");

    for (k=0;k<N;k++) {
      piston = S.mean(d__data + k*nel, M, nel);
      
      remove_piston LLL gridDim,blockDim RRR (d__data + k*nel,
					      M->m, nel, piston);
      
      sprintf(rms,"%.2fnm ",S.std(d__data+ k*nel,M,nel));
      strcat(title,rms);
    }
    prop.set("title",title);
  }
  

  S.cleanup();
 
  HANDLE_ERROR( cudaHostAlloc( (void**)&data, sizeof(float)*N_PX,
			       cudaHostAllocDefault) );
  HANDLE_ERROR( cudaMemcpy( data, d__data, sizeof(float)*N_PX,
			    cudaMemcpyDeviceToHost ) );

  prop.set("xtitle","X");
  prop.set("ytitle","Y");
  prop.set("ztitle","[nm]");
  prop.set("filename",filename);
  int n = (int) sqrtf(N_PX/N);
  prop.aspect_ratio = N;
  prop.set("zdata",data,n,n*N);
  prop.set("colorscale","Portland");
  imagesc(&prop); 

  HANDLE_ERROR( cudaFree( d__data ) );
  HANDLE_ERROR( cudaFreeHost( data ) );
}
@  with the kernel
<<piston removal>>=
__global__ void remove_piston(float *data, const char* mask, int n_data, float p) 
{
int i;
i = blockIdx.x * blockDim.x + threadIdx.x;
 if ( (i<n_data) && (mask[i]>0) )
       data[i] -= p;
}

@ The wavefront amplitude is plotted with the plot.ly
<<plot amplitude I>>=
void complex_amplitude::show_amplitude(char *filename)
{
  float *data;
  plotly_properties prop;

  HANDLE_ERROR( cudaHostAlloc( (void**)&data, sizeof(float)*N_PX,
			       cudaHostAllocDefault) );
  HANDLE_ERROR( cudaMemcpy( data, amplitude, sizeof(float)*N_PX,
			    cudaMemcpyDeviceToHost ) );

  prop.set("xtitle","X");
  prop.set("ytitle","Y");
  prop.set("ztitle","[au]");
  prop.set("filename",filename);
  int n = (int) sqrtf(N_PX/N);
  prop.aspect_ratio = N;
  prop.set("zdata",data,n,n*N);
  imagesc(&prop); 

  HANDLE_ERROR( cudaFreeHost( data ) );
}
<<plot amplitude II>>=
  void complex_amplitude::show_amplitude(char *filename, int N, int M)
{
  float *data;
  plotly_properties prop;

  HANDLE_ERROR( cudaHostAlloc( (void**)&data, sizeof(float)*N_PX,
			       cudaHostAllocDefault) );
  HANDLE_ERROR( cudaMemcpy( data, amplitude, sizeof(float)*N_PX,
			    cudaMemcpyDeviceToHost ) );

  prop.set("xtitle","X");
  prop.set("ytitle","Y");
  prop.set("ztitle","[au]");
  prop.set("filename",filename);
  prop.aspect_ratio = M/N;
  prop.set("zdata",data,N,M);
  imagesc(&prop); 

  HANDLE_ERROR( cudaFreeHost( data ) );
}
