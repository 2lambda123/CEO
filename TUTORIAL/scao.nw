% -*- mode: Noweb; noweb-code-mode: c-mode -*-
\section{Single Conjugated Adaptive Optics System}
\label{sec:single-conj-adapt}

This is a collection of programs dealing with NGS and LGS single--conjugated AO systems. 
All programs must include the following headers which also contains the headers for all the CEO library modules.
<<main header>>=

#ifndef __CEO_H__
#include "ceo.h"
#endif

#define N_SIDE_LENSLET 60
#define _N_LENSLET_ (N_SIDE_LENSLET*N_SIDE_LENSLET)
@
And the main function of each program is:
<<scao.bin>>=
<<main header>>
int main(int argc,char *argv[]) {
<<setup>>
<<wavefront>>
<<NGS wavefront>>
<<NGS wavefront estimation>>
<<LGS wavefront>>
<<LGS wavefront estimation>>
<<LTAO wavefronts and wavefront gradients>>
<<LTAO wavefront estimation>>
<<saving to files>>
<<cleanup>>
}

@
\subsection{Setting--up}
\label{sec:setting-up}

Lets define the sources first:
\begin{itemize}
\item the science sources,
<<setup>>=
source src;
src.setup(ARCSEC(0) , 0, INFINITY,(N_SIDE_LENSLET+1)*(N_SIDE_LENSLET+1), "SRC");
src.photometric_band = "K";
<<cleanup>>=
src.cleanup();
@ \item the NGS
<<setup>>=
source ngs;
ngs.setup(ARCSEC(0) , 0, INFINITY, "NGS");
<<cleanup>>=
ngs.cleanup();
@ \item the LGS
<<setup>>=
source lgs;
lgs.setup(ARCSEC(0) , 0, 90e3, (N_SIDE_LENSLET+1)*(N_SIDE_LENSLET+1), "LGS");
<<cleanup>>=
lgs.cleanup();
@ \end{itemize}

@ The atmosphere is now defined:
<<setup>>=
atmosphere atm;
//atm.setup(20e-2,30,10e3,10,0);
atm.gmt_setup(15e-2,60);
/*
float altitude[] = {0, 10e3},
xi0[] = {0.5, 0.5},
wind_speed[] = {10, 10},
wind_direction[] = {0, 0};
atm.setup(20e-2,30,altitude, xi0, wind_speed, wind_direction);
*/
@ and cleared:
<<cleanup>>=
atm.cleanup();
@ The wavefront sensor centroid container is defined:
<<setup>>=
centroiding cog;
cog.setup();
<<cleanup>>=
cog.cleanup();
@ The diameter of the telescope is set to:
<<setup>>=
float D = 25; // telescope diameter in meter
@ leading to a lenslet size of:
<<setup>>=
float d = D/N_SIDE_LENSLET;
@  Finally we setup the statistical tool:
<<setup>>=
stats S;
S.setup();
<<cleanup>>=
S.cleanup();
@ 
Enforcing the Fried geometry for a circular pupil with the intensity [[threshold]]:
<<setup>>=
float threshold = 0.5;
cog.MASK_SET = fried_geometry_setup(cog.lenslet_mask, src.wavefront.pupil_mask, 
				    N_SIDE_LENSLET, 16, threshold);
dev2file("A_mask.bin",src.wavefront.pupil_mask,src.wavefront.N_PX);
src.wavefront.masked();
@ Defining an imager:
<<setup>>=
imaging imager;
imager.setup(N_SIDE_LENSLET+1,1,4,1,1);
imager.propagate(&src);
imager.frame2file("refFrame.bin");
<<cleanup>>=
imager.cleanup();
@
\subsection{Turbulence wavefront}
\label{sec:turbulence-wavefront}

Lets compute the wavefront propagated through the atmosphere from [[src]]
<<setup>>=
int NP, NP2;
NP = N_SIDE_LENSLET+1;
NP2 = NP*NP;
<<wavefront>>=
float wf_rms;
// NGS
atm.get_phase_screen(&src,d,NP,d,NP,0);
wf_rms = 1E9*S.std(src.wavefront.phase, src.wavefront.pupil_mask, NP2);
printf("\n NGS WF RMS: %7.2fnm",wf_rms);
imager.propagate(&src);
imager.frame2file("turbFrame.bin");
@ The turbulence wavefront is saved apart for later use:
<<wavefront>>=
complex_amplitude phase_screen;
phase_screen.setup((N_SIDE_LENSLET+1)*(N_SIDE_LENSLET+1));
phase_screen.add_phase(1,src.wavefront.phase);
@  The LGS turbulence wavefront is computed with
<<wavefront>>=
// LGS
atm.get_phase_screen(&lgs,d,NP,d,NP,0);
wf_rms = 1E9*S.std(lgs.wavefront.phase, lgs.wavefront.pupil_mask, NP2);
printf("\n LGS WF RMS: %7.2fnm\n",wf_rms);
//lgs.phase2file("lgsPhaseScreen.bin");
@  We also compute the wavefronts gradient:
<<NGS wavefront>>=
atm.get_phase_screen_gradient(&cog,N_SIDE_LENSLET,d,&ngs,0);
//dev2file("ngs_cog.bin",cog.d__c,2*_N_LENSLET_);
<<LGS wavefront>>=
  atm.get_phase_screen_gradient(&cog,N_SIDE_LENSLET,d,&lgs,0);
@ The wavefront is written to the disk
<<saving to files>>=
//dev2file("phaseScreenLowRes.bin", src.wavefront.phase, NP2);
src.phase2file("phaseScreenLowRes.bin");
@
\subsection{Wavefront reconstruction}
\label{sec:wavefr-reconstr}

In the following, the wavefront is reconstructed from the NGS centroids:
<<NGS wavefront estimation>>=
printf("\n___ ON-AXIS WAVEFRONT ESTIMATE FROM NGS ___\n");
LMMSE ngs_lmmse;
ngs_lmmse.setup(&atm,&ngs,1,&ngs,1,d,N_SIDE_LENSLET,"MINRES");
ngs_lmmse.estimation(&cog);
//ngs_lmmse.aa.toFile("ngs_aa.bin");
//ngs_lmmse.pa.toFile("ngs_pa.bin");
src.wavefront.add_phase(-1,ngs_lmmse.d__phase_est);
wf_rms = 1E9*S.std(src.wavefront.phase, 
		   src.wavefront.pupil_mask, NP2);
printf("\n WFE RMS: %8.3fnm\n",wf_rms);
dev2file("phaseEst.bin", ngs_lmmse.d__phase_est, (N_SIDE_LENSLET+1)*(N_SIDE_LENSLET+1));
ngs_lmmse.cleanup();
imager.propagate(&src);
imager.frame2file("ngsFrame.bin");
printf("------------------------------\n");
@ 
Here, the LGS wavefront is subtracted from the NGS wavefront:
<<LGS wavefront estimation>>=
printf("\n___ ON-AXIS WAVEFRONT ESTIMATE FROM LGS ___\n");
LMMSE lgs_lmmse;
lgs_lmmse.setup(&atm,&lgs,1,&src,1,d,N_SIDE_LENSLET,"MINRES");
lgs_lmmse.estimation(&cog);
//lgs_lmmse.aa.toFile("ngs-lgs_aa.bin");
//lgs_lmmse.pa.toFile("ngs-lgs_pa.bin");
src.wavefront.reset(phase_screen);
src.wavefront.add_phase(-1,lgs.wavefront.phase);
wf_rms = 1E9*S.std(src.wavefront.phase, 
		   src.wavefront.pupil_mask, NP2);
printf("\n NGS-LGS WFE RMS : %8.3fnm",wf_rms);
imager.propagate(&src);
imager.frame2file("lgsFrame.bin");
@ 
The, the LMMMSE LGS wavefront estimate is subtracted from the NGS wavefront:
<<LGS wavefront estimation>>=
src.wavefront.reset(phase_screen);
src.wavefront.add_phase(-1,lgs_lmmse.d__phase_est);
wf_rms = 1E9*S.std(src.wavefront.phase, 
		   src.wavefront.pupil_mask, NP2);
printf("\n LGS MMSE WFE RMS: %8.3fnm\n",wf_rms);
//dev2file("phaseEstLgs.bin", lgs_lmmse.d__phase_est, lgs_lmmse.paCov.MT2_TOTAL, lgs_lmmse.paCov.MT2, _N_LAYER_);
//dev2file("phaseEstLgsItp.bin", lgs_lmmse.d__phase_est, NP2);
lgs_lmmse.toFile("phaseEstLgsItp.bin");
lgs_lmmse.cleanup();
imager.propagate(&src);
imager.frame2file("lgsLmmseFrame.bin");
printf("------------------------------\n");

@ 
\section{LTAO}
\label{sec:ltao}

For the LTAO wavefront estimation, the LGS constellation is defined first.
We will use 3 LGSs on a 15 arcsec radius ring.
<<setup>>=
int N_GS = 6;
float gs_radius = 30;
// 3 LGS on a ring
/* float zenith[] = {ARCSEC(gs_radius),ARCSEC(gs_radius),ARCSEC(gs_radius)}, */
/*   azimuth[] = {0,2.*PI/3.,4.*PI/3.}; */
// 6 LGS on a ring
float zenith[] = {ARCSEC(30),ARCSEC(30),ARCSEC(30),ARCSEC(30),ARCSEC(30),ARCSEC(30)},
  azimuth[] = {0,2.*PI/6.,4.*PI/6.,6.*PI/6.,8.*PI/6.,10.*PI/6.,12.*PI/6.};

source gs_ast;
gs_ast.setup(zenith,azimuth,90e3,N_GS,NP2);
<<cleanup>>=
gs_ast.cleanup();

@ The wavefront sensor of the LGS asterism are setup next
<<setup>>=
centroiding gs_ast_cog;
gs_ast_cog.setup(_N_LENSLET_,N_GS);
gs_ast_cog.MASK_SET = fried_geometry_setup(gs_ast_cog.lenslet_mask, 
					   gs_ast.wavefront.pupil_mask, 
					   N_SIDE_LENSLET, 16, threshold);
<<cleanup>>=
gs_ast_cog.cleanup();

@ The 3 source are propagated through the atmosphere to the wavefront sensor.
<<LTAO wavefronts and wavefront gradients>>=
atm.get_phase_screen(&gs_ast,N_GS,d,NP,d,NP,0);
gs_ast.phase2file("gsAstWavefronts.bin");
atm.get_phase_screen_gradient(&gs_ast_cog,N_SIDE_LENSLET,d,&gs_ast,N_GS,0);
//dev2file("gs_ast_cog.bin",gs_ast_cog.d__c,2*_N_LENSLET_*N_GS);

@ We solve:
<<LTAO wavefront estimation>>=
printf("\n___ ON-AXIS WAVEFRONT ESTIMATE FROM LGS ASTERISM ___\n");
LMMSE gs_ast_lmmse;
gs_ast_lmmse.setup(&atm,&gs_ast,N_GS,&src,1,d,N_SIDE_LENSLET,"MINRES");
//gs_ast_lmmse.aa.toFile("gs_ast_aaCovariance.bin");
//gs_ast_lmmse.pa.toFile("gs_ast_paCovariance.bin");
gs_ast_lmmse.estimation(&gs_ast_cog);
src.wavefront.reset(phase_screen);
src.wavefront.add_phase(-1,gs_ast_lmmse.d__phase_est);
wf_rms = 1E9*S.std(src.wavefront.phase,
		   src.wavefront.pupil_mask, NP2);
printf("\n WFE RMS: %8.3fnm\n",wf_rms);
//dev2file("phaseEstLtao.bin", gs_ast_lmmse.d__phase_est, gs_ast_lmmse.paCov.MT2_TOTAL, gs_ast_lmmse.paCov.MT2, _N_LAYER_);
//dev2file("phaseEstLtaoItp.bin", gs_ast_lmmse.d__phase_est, NP2);
gs_ast_lmmse.toFile("phaseEstLtaoItp.bin");
gs_ast_lmmse.cleanup();
imager.propagate(&src);
imager.frame2file("lgsAstFrame.bin");
printf("------------------------------\n");

<<cleanup>>=
cudaDeviceReset();
