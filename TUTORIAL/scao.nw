% -*- mode: Noweb; noweb-code-mode: c-mode -*-

\section{Geometric adaptive optics}
\label{sec:open-loop-geometric}

In this section, the performances of several AO systems are compared.
All the systems employ geometric Shack--Hartmann wavefront sensors (SH--WFS).
For each system, the on--axis wavefront is estimated several times with a different random draw of the phase screens.

The components common to all the systems are defined first:
\begin{itemize}
\item the science source,
<<setup>>=
source src;
src.setup(ARCSEC(0) , 0, INFINITY,(N_SIDE_LENSLET+1)*(N_SIDE_LENSLET+1), "SRC");
src.photometric_band = "K";
<<cleanup>>=
src.cleanup();
@ \item the atmosphere,
<<setup>>=
atmosphere atm;
//atm.setup(20e-2,30,10e3,10,0);
atm.gmt_setup(15e-2,60);
/*
float altitude[] = {0, 10e3},
xi0[] = {0.5, 0.5},
wind_speed[] = {10, 10},
wind_direction[] = {0, 0};
atm.setup(20e-2,30,altitude, xi0, wind_speed, wind_direction);
*/
<<cleanup>>=
atm.cleanup();
@ \item @ the diameter of the telescope,
<<setup>>=
float D = 25; // telescope diameter in meter
@ leading to a lenslet size of:
<<setup>>=
float d = D/N_SIDE_LENSLET;
@ \item the pupil mask.
<<setup>>=
mask pupil_mask;
pupil_mask.setup( (N_SIDE_LENSLET+1)*(N_SIDE_LENSLET+1) );
<<cleanup>>=
pupil_mask.cleanup();
@ \item the wavefront sensor centroid container,
<<setup>>=
centroiding cog;
cog.setup();
<<cleanup>>=
cog.cleanup();
@ \item the science imager.
<<setup>>=
imaging imager;
imager.setup(N_SIDE_LENSLET+1,1,4,1,1);
<<cleanup>>=
imager.cleanup();
@ \item the statistical tool.
<<setup>>=
stats S;
S.setup();
<<cleanup>>=
S.cleanup();
@  \end{itemize}

@ 
The Fried geometry for a circular pupil with the intensity [[threshold]] is enforced::
<<setup>>=
float threshold = 0.5;
cog.MASK_SET = fried_geometry_setup(cog.lenslet_mask, pupil_mask.m, 
				    N_SIDE_LENSLET, 16, threshold);
@ 
The filtering properties associated with the pupil are set with:
<<setup>>=
pupil_mask.set_filter();
@ 
The science is propagated through the [[pupil_mask]] to the focal plane of the [[imager]]:
<<setup>>=
src.wavefront.M = &pupil_mask;
src.wavefront.masked();
imager.propagate(&src);
//imager.frame2file("refFrame.bin");
imager.show_frame("SCAO/frames/diffraction limited");

@ A few useful variables are defined here:
<<setup>>=
int NP, NP2;
NP = N_SIDE_LENSLET+1;
NP2 = NP*NP;

@
The science wavefront is propagated through the atmosphere from [[src]] to [[pupil_mask]].
<<science wavefront>>=
atm.get_phase_screen(&src,d,NP,d,NP,0);
src.wavefront.masked();
src.wavefront.show_phase("SCAO/phases/science phase screen");
float science_wf_rms;
science_wf_rms = 1E9*S.std(src.wavefront.phase, &pupil_mask, NP2);

@  and then propagated to the focal plane of the imager:
<<science wavefront>>=
imager.propagate(&src);
imager.show_frame("SCAO/frames/turbulence limited");
@ The turbulence wavefront is saved apart for later use:
<<science wavefront>>=
complex_amplitude phase_screen;
phase_screen.setup((N_SIDE_LENSLET+1)*(N_SIDE_LENSLET+1));
phase_screen.add_phase(1,src.wavefront.phase);

@ 
All CEO programs must include the following headers which also contains the headers for all the CEO library modules.
<<main header>>=
#ifndef __CEO_H__
#include "ceo.h"
#endif
@ The size of the lenslet array is defined in the header:
<<main header>>=
#define N_SIDE_LENSLET 60
#define _N_LENSLET_ (N_SIDE_LENSLET*N_SIDE_LENSLET)
@
The main function is:
<<scao.bin>>=
<<main header>>
int main(int argc,char *argv[]) {
<<setup>>
<<science wavefront>>
<<ngsao>>
<<lgsao>>
<<ltao>>
<<results>>
<<cleanup>>
}

@ 
\subsection{Natural guide star adaptive optics}
\label{sec:ngs-ao}

The natural guide star (NGS) is given by:
<<ngsao>>=
source ngs;
ngs.setup(ARCSEC(0) , 0, INFINITY, "NGS");
<<ngsao cleanup>>=
ngs.cleanup();

@  The NGS wavefronts gradients from the turbulence are generated from a dedicated slopes turbulence generator.
<<ngsao>>=
atm.get_phase_screen_gradient(&cog,N_SIDE_LENSLET,d,&ngs,0);

@ 
In the following, the wavefront is reconstructed from the NGS centroids:
<<ngsao>>=
LMMSE ngs_lmmse;
ngs_lmmse.setup(&atm,&ngs,1,&src,1,d,N_SIDE_LENSLET,&pupil_mask,"MINRES");
ngs_lmmse.estimation(&cog);
@ The estimated wavefront is removed from the science wavefront
<<ngsao>>=
src.wavefront.add_phase(-1,ngs_lmmse.d__phase_est);
src.wavefront.show_phase("SCAO/phases/residual from LMMSE NGS AO");
float ngsao_wfe_rms;
ngsao_wfe_rms = 1E9*S.std(src.wavefront.phase, 
		   &pupil_mask, NP2);
<<ngsao cleanup>>=
ngs_lmmse.cleanup();
@ and the residual wavefront corresponding image is computed.
<<ngsao>>=
imager.propagate(&src);
imager.show_frame("SCAO/frames/LMMSE NGS AO");

<<ngsao>>=
<<ngsao cleanup>>

@ 
\subsection{Laser guide star adaptive optics}
\label{sec:lgs-ao}
 
The laser guide star (LGS) is given by:
<<lgsao>>=
source lgs;
lgs.setup(ARCSEC(0) , 0, 90e3, (N_SIDE_LENSLET+1)*(N_SIDE_LENSLET+1), "LGS");
<<lgsao cleanup>>=
lgs.cleanup();

@  The LGS turbulence wavefront and wavefront gradient are computed with:
<<lgsao>>=
atm.get_phase_screen(&lgs,d,NP,d,NP,0);
lgs.wavefront.M = &pupil_mask;
lgs.wavefront.masked();
lgs.wavefront.show_phase("SCAO/phases/LGS phase screen");
float lgs_wf_rms;
lgs_wf_rms = 1E9*S.std(lgs.wavefront.phase, &pupil_mask, NP2);
@ and with:
<<lgsao>>=
atm.get_phase_screen_gradient(&cog,N_SIDE_LENSLET,d,&lgs,0);

@  
The LGS wavefront is subtracted from the science wavefront:
<<lgsao>>=
src.wavefront.reset(phase_screen);
src.wavefront.add_phase(-1,lgs.wavefront.phase);
src.wavefront.show_phase("SCAO/phases/residual from LGS AO");
float lgs_wfe_rms;
lgs_wfe_rms = 1E9*S.std(src.wavefront.phase, 
		   &pupil_mask, NP2);
@  and the residual wavefront corresponding image is computed.
<<lgsao>>=
imager.propagate(&src);
imager.show_frame("SCAO/frames/LGS AO");

@ 
The wavefront is reconstructed from the LGS centroids:
<<lgsao>>=
LMMSE lgs_lmmse;
lgs_lmmse.setup(&atm,&lgs,1,&src,1,d,N_SIDE_LENSLET,&pupil_mask,"MINRES");
lgs_lmmse.estimation(&cog);
@ The LMMMSE LGS wavefront estimate is subtracted from the science wavefront:
<<lgsao>>=
src.wavefront.reset(phase_screen);
src.wavefront.add_phase(-1,lgs_lmmse.d__phase_est);
src.wavefront.show_phase("SCAO/phases/residual from LMMSE LGS AO");
float lgs_wfe_rms_lmmse;
lgs_wfe_rms_lmmse = 1E9*S.std(src.wavefront.phase, 
		   &pupil_mask, NP2);
//lgs_lmmse.toFile("phaseEstLgsItp.bin");
<<lgsao cleanup>>=
lgs_lmmse.cleanup();
@ and the residual wavefront corresponding image is computed.
<<lgsao>>=
imager.propagate(&src);
//imager.frame2file("lgsLmmseFrame.bin");
imager.show_frame("SCAO/frames/LMMSE LGS AO");

<<lgsao>>=
<<lgsao cleanup>>

@ 
\subsection{Laser tomography adaptive optics}
\label{sec:ltao}

For the LTAO wavefront estimation, the LGS constellation is defined first.
We will use 3 LGSs on a 30 arcsec radius ring.
<<ltao>>=
int N_GS = 6;
float gs_radius = 30;
// 3 LGS on a ring
/* float zenith[] = {ARCSEC(gs_radius),ARCSEC(gs_radius),ARCSEC(gs_radius)}, */
/*   azimuth[] = {0,2.*PI/3.,4.*PI/3.}; */
// 6 LGS on a ring
float zenith[] = {ARCSEC(30),ARCSEC(30),ARCSEC(30),ARCSEC(30),ARCSEC(30),ARCSEC(30)},
  azimuth[] = {0,2.*PI/6.,4.*PI/6.,6.*PI/6.,8.*PI/6.,10.*PI/6.,12.*PI/6.};

source gs_ast;
gs_ast.setup(zenith,azimuth,90e3,N_GS,NP2);
<<ltao cleanup>>=
gs_ast.cleanup();

@ The wavefront sensor of the LGS asterism are setup next
<<ltao>>=
centroiding gs_ast_cog;
gs_ast_cog.setup(_N_LENSLET_,N_GS);
gs_ast_cog.MASK_SET = fried_geometry_setup(gs_ast_cog.lenslet_mask, 
					   pupil_mask.m, 
					   N_SIDE_LENSLET, 16, threshold);
<<ltao cleanup>>=
gs_ast_cog.cleanup();

@ The 3 source are propagated through the atmosphere to the wavefront sensor.
<<ltao>>=
atm.get_phase_screen(&gs_ast,N_GS,d,NP,d,NP,0);
//gs_ast.phase2file("gsAstWavefronts.bin");
atm.get_phase_screen_gradient(&gs_ast_cog,N_SIDE_LENSLET,d,&gs_ast,N_GS,0);

@ The science wavefront is reconstructed with the tomographic estimator:
<<ltao>>=
LMMSE gs_ast_lmmse;
gs_ast_lmmse.setup(&atm,&gs_ast,N_GS,&src,1,d,N_SIDE_LENSLET,&pupil_mask,"MINRES");
gs_ast_lmmse.estimation(&gs_ast_cog);
@  The tomographic wavefront is subtracted from the science wavefront:
<<ltao>>=
src.wavefront.reset(phase_screen);
src.wavefront.add_phase(-1,gs_ast_lmmse.d__phase_est);
src.wavefront.show_phase("SCAO/phases/residual from LMMSE LTAO");
float ltao_wfe_rms;
ltao_wfe_rms = 1E9*S.std(src.wavefront.phase,
		   &pupil_mask, NP2);
<<ltao cleanup>>=
gs_ast_lmmse.cleanup();
@ and the residual wavefront corresponding image is computed.
<<ltao>>=
imager.propagate(&src);
imager.show_frame("SCAO/frames/LMMSE LTAO");

<<ltao>>=
<<ltao cleanup>>

@ 
\subsection{Results}
\label{sec:results}

<<results>>=
printf("------------------------------\n");
printf("___  TURBULENCE WAVEFRONT ___\n");
printf("\n NGS WF RMS: %7.2fnm\n", science_wf_rms);
printf("\n LGS WF RMS: %7.2fnm\n", lgs_wf_rms);
printf("\n___ ON-AXIS WAVEFRONT ESTIMATE FROM NGS ___\n");
printf("\n NGSAO WFE RMS: %8.3fnm\n",ngsao_wfe_rms);
printf("\n___ ON-AXIS WAVEFRONT ESTIMATE FROM LGS ___\n");
printf("\n NGS-LGS WFE RMS : %8.3fnm\n",lgs_wfe_rms);
printf("\n LGS MMSE WFE RMS: %8.3fnm\n",lgs_wfe_rms_lmmse);
printf("\n___ ON-AXIS WAVEFRONT ESTIMATE FROM LGS ASTERISM ___\n");
printf("\n WFE RMS: %8.3fnm\n",ltao_wfe_rms);
printf("------------------------------\n");

