% -*- mode: Noweb; noweb-code-mode: c-mode -*-
@
\subsection{The files}

\subsubsection{Header}

<<centroiding.h>>=
#ifndef __CENTROIDING_H__
#define __CENTROIDING_H__

#ifndef __UTILITIES_H__
#include "utilities.h"
#endif

#ifndef __IMAGING_H__
#include "imaging.h"
#endif

struct centroiding {

  <<parameters>>

  void setup(int _N_SIDE_LENSLET, int _N_SOURCE);

  void cleanup(void);
   
  void get_data(imaging *wfs);
  void get_data(float *frame, int N);
  void get_data(float *frame, int N, float cx0, float cy0, float units);

  void show_centroids(char *filename);
  void show_flux(char *filename);

};

#endif  // __CENTROIDING_H__
@

\subsubsection{Source}

<<centroiding.cu>>=
#include "centroiding.h"

<<centroiding>>

<<setup>>

<<cleanup>>
   
<<data Ia>>
<<data Ib>>
<<data II>>

<<display centroids>>
<<display flux>>
@ 
\subsection{Parameters}
\label{sec:prms}

The parameters are the centroid vector [[d__c]] with $2\times[[n_data]]$ elements.
The first half contains the X axis centroids [[d__cx]] and the other half contains the Y axis centroids [[d__cy]].
The lenslet intensity is stored in the vector [[d__mass]] of length [[n_data]].
<<parameters>>=
int _N_SIDE_LENSLET_, N_LENSLET, N_SOURCE;
float *d__c, *d__cx, *d__cy, *d__mass;
char *lenslet_mask, MASK_SET;
int n_data;
@ 
\subsection{Functions}
\label{sec:functions}

\subsubsection{Setup \& Cleanup}
\label{sec:setup--cleanup}

Parameters are allocated with the [[setup]] routines
<<setup>>=
void centroiding::setup(int _N_SIDE_LENSLET, int _N_SOURCE) {
  _N_SIDE_LENSLET_ = _N_SIDE_LENSLET;
  N_LENSLET = _N_SIDE_LENSLET_*_N_SIDE_LENSLET_;
  N_SOURCE = _N_SOURCE;
  HANDLE_ERROR( cudaMalloc( (void**)&d__c   , sizeof(float) *N_LENSLET*N_SOURCE*2 ) );
  d__cx = d__c;
  d__cy = d__c + N_LENSLET;
  HANDLE_ERROR( cudaMalloc( (void**)&d__mass , sizeof(float) *N_LENSLET*N_SOURCE ) );     
  HANDLE_ERROR( cudaMalloc( (void**)&lenslet_mask , sizeof(char) *N_LENSLET ) );     
  MASK_SET = 0;
}
@ and de--allocated with the [[cleanup]] routine
<<cleanup>>=
void centroiding::cleanup(void) {
  fprintf(stderr,"@(CEO)>centroiding: freeing memory!\n");
  HANDLE_ERROR( cudaFree( d__c ) );
  HANDLE_ERROR( cudaFree( d__mass ) );
  HANDLE_ERROR( cudaFree( lenslet_mask ) );
}
@
\subsubsection{Data processing}
\label{sec:data-processing}

The framelets are processed to retrieve centroids and flux
<<data Ia>>=
void centroiding::get_data(imaging *wfs) {
  dim3 blockGrid(_N_SIDE_LENSLET_,_N_SIDE_LENSLET_,N_SOURCE);
  dim3 threadGrid(wfs->N_PX_CAMERA,1);
  int N_PX_CAMERA_BYTE = sizeof(float)*wfs->N_PX_CAMERA*wfs->N_PX_CAMERA*3;
  centroidingEngine LLL blockGrid , threadGrid , N_PX_CAMERA_BYTE RRR 
    (d__cx, d__cy,
     d__mass, wfs->d__frame,
     0, 0, 1,
     _N_SIDE_LENSLET_, N_SOURCE,
     wfs->N_PX_CAMERA);
}
<<data Ib>>=
void centroiding::get_data(float *frame, int N_PX_CAMERA) {
  dim3 blockGrid(_N_SIDE_LENSLET_,_N_SIDE_LENSLET_,N_SOURCE);
  dim3 threadGrid(N_PX_CAMERA,1);
  int N_PX_CAMERA_BYTE = sizeof(float)*N_PX_CAMERA*N_PX_CAMERA*3;
  centroidingEngine LLL blockGrid , threadGrid , N_PX_CAMERA_BYTE RRR 
    (d__cx, d__cy,
     d__mass, frame,
     0, 0, 1,
     _N_SIDE_LENSLET_, N_SOURCE,
     N_PX_CAMERA);
}
<<data II>>=
void centroiding::get_data(float *frame, int N_PX_CAMERA, float cx0, float cy0, float units) {
  dim3 blockGrid(_N_SIDE_LENSLET_,_N_SIDE_LENSLET_,N_SOURCE);
  dim3 threadGrid(N_PX_CAMERA,1);
  int N_PX_CAMERA_BYTE = sizeof(float)*N_PX_CAMERA*N_PX_CAMERA*3;
  centroidingEngine LLL blockGrid , threadGrid , N_PX_CAMERA_BYTE RRR 
    (d__cx, d__cy,
     d__mass, frame,
     cx0, cy0, units,
     _N_SIDE_LENSLET_, N_SOURCE,
     N_PX_CAMERA);
}
@ 
The framelets are processed with the kernel:
<<centroiding>>=
__global__ void centroidingEngine(float *cx, float *cy,
				  float *flux, const float *frame,
				  float cx0, float cy0, float units,
				  int _N_SIDE_LENSLET_, int N_SOURCE,
				  int N_PX_CAMERA)
{
  int u, k, kp, i, ij, ij_inc, iLenslet,jLenslet, N_PX_CAMERA2, iSource, kSource;
  float *buffer0, *buffer1, *buffer2;
  u = threadIdx.x;
  iLenslet = blockIdx.x;
  jLenslet = blockIdx.y;
  iSource  = blockIdx.z;
  /* kLenslet = iLenslet*NSIDE_LENSLET + jLenslet; */
  
  extern __shared__ float shared[];
  N_PX_CAMERA2 = N_PX_CAMERA*N_PX_CAMERA;
  buffer0 = shared;
  buffer1 = shared + N_PX_CAMERA2;
  buffer2 = shared + N_PX_CAMERA2*2;

  // CENTROIDING
  if (u<N_PX_CAMERA)
    {
      buffer0[u] = buffer1[u] = buffer2[u] = 0.0;
      // ij = iLenslet*N_PX_CAMERA + u;
      // ij *= _N_SIDE_LENSLET_*N_PX_CAMERA*N_SOURCE;
      // ij += jLenslet*N_PX_CAMERA;
      //      ij = (u+k*N_PX_CAMERA)*N_PX_CAMERA;
      ij = lenslet2array(u, 0, N_PX_CAMERA, 
			 iLenslet, jLenslet, _N_SIDE_LENSLET_, 
			 iSource, N_SOURCE);
      for (i=0;i<N_PX_CAMERA;i++)
	{
	  ij_inc = ij + i;
	  buffer0[u]  += frame[ij_inc];
	  buffer1[u]  += u*frame[ij_inc];
	  buffer2[u]  += i*frame[ij_inc];
	}
    }
  
  __syncthreads();

  if (u<1)
  {
    k = kp = blockIdx.x*_N_SIDE_LENSLET_ + blockIdx.y;
    kSource = iSource*_N_SIDE_LENSLET_*_N_SIDE_LENSLET_;
    k  += 2*kSource;
    kp +=   kSource;
    flux[kp]  = cx[k] = cy[k] = 0.0;
    for (i=0;i<N_PX_CAMERA;i++)
      {
	flux[kp] += buffer0[i];
	cx[k]   += buffer1[i];
	cy[k]   += buffer2[i];
      }
    if (flux[kp]>0)
      {
	cx[k] /= flux[kp];
	cx[k] -= cx0;
	cx[k] *= units;
	cy[k] /= flux[kp];
	cy[k] -= cy0;
	cy[k] *= units;
      }
  }
}
@ 
\subsubsection{Input/Output}
\label{sec:inputoutput}

The centroids and flux are displayed with plot.ly.
<<display centroids>>=
void centroiding::show_centroids(char *filename)
{
  int nbyte;
  float *data, alpha;
  plotly_properties prop;

  stats S;
  S.setup();
  alpha = RADIAN2ARCSEC;
  nbyte = N_LENSLET*N_SOURCE*2;
  CUBLAS_ERROR( cublasSscal(S.handle, nbyte, &alpha, d__c, 1) );
  S.cleanup();

  nbyte *= sizeof(float);
  HANDLE_ERROR( cudaHostAlloc( (void**)&data, nbyte, 
			       cudaHostAllocDefault ) );
  HANDLE_ERROR( cudaMemcpy( data, d__c,nbyte,
			    cudaMemcpyDeviceToHost ) );

  prop.set("ztitle","[arcsec]");
  prop.set("filename",filename);
  prop.aspect_ratio = N_SOURCE*2;
  prop.set("zdata",data,
	   _N_SIDE_LENSLET_*N_SOURCE*2,
	   _N_SIDE_LENSLET_);
  imagesc(&prop); 

  HANDLE_ERROR( cudaFreeHost( data ) );
}
@ 
<<display flux>>=
void centroiding::show_flux(char *filename)
{
  int nbyte;
  float *data;
  plotly_properties prop;

  nbyte = sizeof(float) *N_LENSLET*N_SOURCE;
  HANDLE_ERROR( cudaHostAlloc( (void**)&data, nbyte, 
			       cudaHostAllocDefault ) );
  HANDLE_ERROR( cudaMemcpy( data, d__mass,nbyte,
			    cudaMemcpyDeviceToHost ) );

  prop.set("ztitle","[au]");
  prop.set("filename",filename);
  prop.aspect_ratio = N_SOURCE;
  prop.set("zdata",data,
	   _N_SIDE_LENSLET_,
	   _N_SIDE_LENSLET_*N_SOURCE);
  imagesc(&prop); 

  HANDLE_ERROR( cudaFreeHost( data ) );
}
