% -*- mode: Noweb; noweb-code-mode: c-mode -*-
@
\subsection{The files}

\subsubsection{Header}

<<centroiding.h>>=
#ifndef __CENTROIDING_H__
#define __CENTROIDING_H__

#ifndef __UTILITIES_H__
#include "utilities.h"
#endif

struct centroiding {

  <<parameters>>

  void setup(int _N_SIDE_LENSLET, int _N_SOURCE);

  void cleanup(void);
   
  void get_data(float *frame, int N);
  void get_data(float *frame, int N, float cx0, float cy0, float units);

};

#endif  // __CENTROIDING_H__
@
\subsubsection{Source}

<<centroiding.cu>>=
#include "centroiding.h"

<<centroiding>>

<<setup>>

<<cleanup>>
   
<<data I>>
<<data II>>
@ 
\subsection{Parameters}
\label{sec:prms}

The parameters are the centroid vector [[d__c]] with $2\times[[n_data]]$ elements.
The first half contains the X axis centroids [[d__cx]] and the other half contains the Y axis centroids [[d__cy]].
The lenslet intensity is stored in the vector [[d__mass]] of length [[n_data]].
<<parameters>>=
int _N_SIDE_LENSLET_, N_LENSLET, N_SOURCE;
float *d__c, *d__cx, *d__cy, *d__mass;
char *lenslet_mask, MASK_SET;
int n_data;
@ 
\subsection{Functions}
\label{sec:functions}

\subsubsection{Setup \& Cleanup}
\label{sec:setup--cleanup}

Parameters are allocated with the [[setup]] routines
<<setup>>=
void centroiding::setup(int _N_SIDE_LENSLET, int _N_SOURCE) {
  _N_SIDE_LENSLET_ = _N_SIDE_LENSLET;
  N_LENSLET = _N_SIDE_LENSLET_*_N_SIDE_LENSLET_;
  N_SOURCE = _N_SOURCE;
  HANDLE_ERROR( cudaMalloc( (void**)&d__c   , sizeof(float) *N_LENSLET*N_SOURCE*2 ) );
  d__cx = d__c;
  d__cy = d__c + N_LENSLET*N_SOURCE;
  HANDLE_ERROR( cudaMalloc( (void**)&d__mass , sizeof(float) *N_LENSLET*N_SOURCE ) );     
  HANDLE_ERROR( cudaMalloc( (void**)&lenslet_mask , sizeof(char) *N_LENSLET ) );     
  MASK_SET = 0;
}
@ and de--allocated with the [[cleanup]] routine
<<cleanup>>=
void centroiding::cleanup(void) {
  fprintf(stderr,"@(CEO)>centroiding: freeing memory!\n");
  HANDLE_ERROR( cudaFree( d__c ) );
  HANDLE_ERROR( cudaFree( d__mass ) );
  HANDLE_ERROR( cudaFree( lenslet_mask ) );
}
@
\subsubsection{Data processing}
\label{sec:data-processing}

The framelets are processed to retrieve centroids and flux
<<data I>>=
void centroiding::get_data(float *frame, int N_PX_CAMERA) {
     dim3 blockGrid(_N_SIDE_LENSLET_,_N_SIDE_LENSLET_*N_SOURCE);
     dim3 threadGrid(N_PX_CAMERA,1);
     int N_PX_CAMERA_BYTE = sizeof(float)*N_PX_CAMERA*N_PX_CAMERA*3;
     centroidingEngine LLL blockGrid , threadGrid , N_PX_CAMERA_BYTE RRR 
       (d__cx, d__cy,
	d__mass, frame,
	0, 0, 1,
	_N_SIDE_LENSLET_, N_SOURCE,
	N_PX_CAMERA);
}
<<data II>>=
void centroiding::get_data(float *frame, int N_PX_CAMERA, float cx0, float cy0, float units) {
     dim3 blockGrid(_N_SIDE_LENSLET_,_N_SIDE_LENSLET_*N_SOURCE);
     dim3 threadGrid(N_PX_CAMERA,1);
     int N_PX_CAMERA_BYTE = sizeof(float)*N_PX_CAMERA*N_PX_CAMERA*3;
     centroidingEngine LLL blockGrid , threadGrid , N_PX_CAMERA_BYTE RRR 
       (d__cx, d__cy,
	d__mass, frame,
	cx0, cy0, units,
	_N_SIDE_LENSLET_, N_SOURCE,
	N_PX_CAMERA);
}
@ 
The framelets are processed with the kernel:
<<centroiding>>=
__global__ void centroidingEngine(float *cx, float *cy,
				  float *flux, const float *frame,
				  float cx0, float cy0, float units,
				  int _N_SIDE_LENSLET_, int N_SOURCE,
				  int N_PX_CAMERA)
{
  int u, k, i, ij, ij_inc, iLenslet,jLenslet, N_PX_CAMERA2;
  float *buffer0, *buffer1, *buffer2;
  u = threadIdx.x;
  iLenslet = blockIdx.x;
  jLenslet = blockIdx.y;
  /* kLenslet = iLenslet*NSIDE_LENSLET + jLenslet; */
  k = blockIdx.x*_N_SIDE_LENSLET_*N_SOURCE + blockIdx.y;
  
  extern __shared__ float shared[];
  N_PX_CAMERA2 = N_PX_CAMERA*N_PX_CAMERA;
  buffer0 = shared;
  buffer1 = shared + N_PX_CAMERA2;
  buffer2 = shared + N_PX_CAMERA2*2;

  // CENTROIDING
  if (u<N_PX_CAMERA)
    {
      buffer0[u] = buffer1[u] = buffer2[u] = 0.0;
      // ij = iLenslet*N_PX_CAMERA + u;
      // ij *= _N_SIDE_LENSLET_*N_PX_CAMERA*N_SOURCE;
      // ij += jLenslet*N_PX_CAMERA;
      //      ij = (u+k*N_PX_CAMERA)*N_PX_CAMERA;
      ij = lenslet2array(u, 0, N_PX_CAMERA, 
			 iLenslet, jLenslet, _N_SIDE_LENSLET_, 
			 0, N_SOURCE);
      for (i=0;i<N_PX_CAMERA;i++)
	{
	  ij_inc = ij + i;
	  buffer0[u]  += frame[ij_inc];
	  buffer1[u]  += u*frame[ij_inc];
	  buffer2[u]  += i*frame[ij_inc];
	}
    }
  
  __syncthreads();

  if (u<1)
  {
      flux[k]  = cx[k] = cy[k] = 0.0;
      for (i=0;i<N_PX_CAMERA;i++)
      {
          flux[k] += buffer0[i];
          cx[k]   += buffer1[i];
          cy[k]   += buffer2[i];
      }
      if (flux[k]>0)
      {
          cx[k] /= flux[k];
	  cx[k] -= cx0;
	  cx[k] *= units;
          cy[k] /= flux[k];
	  cy[k] -= cy0;
	  cy[k] *= units;
      }
  }
}
