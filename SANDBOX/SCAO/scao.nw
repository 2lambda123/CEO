% -*- mode: Noweb; noweb-code-mode: c-mode -*-

\section{Single Conjugated Adaptive Optics System}
\label{sec:single-conj-adapt}

This is a collection of programs dealing with NGS and LGS single--conjugated AO systems. 
All programs must include the following headers which also contains the headers for all the CEO library modules.
<<main header>>=
#ifndef __CEO_H__
#include "ceo.h"
#endif
#ifndef __SOURCE_H__
#include "source.h"
#endif
#ifndef __ATMOSPHERE_H__
#include "atmosphere.h"
#endif
#ifndef __IMAGING_H__
#include "imaging.h"
#endif
#ifndef __CENTROIDING_H__
#include "centroiding.h"
#endif
#ifndef __AASTATS_H__
#include "aaStats.h"
#endif
#ifndef __BTBT_H__
#include "BTBT.h"
#endif
#ifndef __GBTBT_H__
#include "GBTBT.h"
#endif
#ifndef __ITERATIVESOLVERS_H__
#include "iterativeSolvers.h"
#endif
#ifndef __LMMSE_H__
#include "LMMSE.h"
#endif
@
And the main function of each program is:
<<scao.bin full>>=
<<main header>>
int main(int argc,char *argv[]) {
<<setup>>
<<wavefront>>
<<NGS wavefront>>
<<wavefront reconstruction from NGS>>
<<LGS wavefront>>
<<wavefront reconstruction from LGS>>
<<paStats MVM alternative>>
<<LMMSE MVM alternative>>
<<LMMSE MVM alternative Fried>>
<<saving to files>>
<<LTAO wavefronts and wavefront gradients>>
<<LTAO wavefront estimation>>
<<paStats MVM tomography>>
<<LTAO wavefront estimation Fried>>
<<cleanup>>
}
<<scao.bin>>=
<<main header>>
int main(int argc,char *argv[]) {
<<setup>>
<<wavefront>>
<<NGS wavefront>>
<<wavefront reconstruction from NGS>>
<<LGS wavefront>>
<<wavefront reconstruction from LGS>>
<<LMMSE MVM alternative Fried>>
<<saving to files>>
<<cleanup>>
}

@
\subsection{Setting--up}
\label{sec:setting-up}

Lets define the sources first:
\begin{itemize}
\item the science sources,
<<setup>>=
source src, src_fried, near_src, near_src_fried;
src.setup(ARCSEC(0) , 0, INFINITY);
src_fried.setup(ARCSEC(0) , 0, INFINITY,(N_SIDE_LENSLET+1)*(N_SIDE_LENSLET+1));
near_src.setup(ARCSEC(0) , 0, 90e3);
near_src_fried.setup(ARCSEC(0) , 0, 90e3,(N_SIDE_LENSLET+1)*(N_SIDE_LENSLET+1));
<<cleanup>>=
src.cleanup();
src_fried.cleanup();
near_src.cleanup();
near_src_fried.cleanup();
@ \item the NGS
<<setup>>=
source ngs;
ngs.setup(ARCSEC(0) , 0, INFINITY);
<<cleanup>>=
ngs.cleanup();
@ \item the LGS
<<setup>>=
source lgs;
lgs.setup(ARCSEC(0) , 0, 90e3);
<<cleanup>>=
lgs.cleanup();
@ \end{itemize}

@ The atmosphere is now defined:
<<setup>>=
atmosphere atm;
atm.setup(20e-2,30,10e3,10,0);
//atm.gmt_setup(15e-2,60);
/*
float altitude[] = {0, 10e3},
xi0[] = {0.5, 0.5},
wind_speed[] = {10, 10},
wind_direction[] = {0, 0};
atm.setup(20e-2,30,altitude, xi0, wind_speed, wind_direction);
*/
@ and cleared:
<<cleanup>>=
atm.cleanup();
@ The wavefront sensor centroid container is defined:
<<setup>>=
centroiding cog;
cog.setup();
<<cleanup>>=
cog.cleanup();
@ The diameter of the telescope is set to:
<<setup>>=
float D = 8; // telescope diameter in meter
@ leading to a lenslet size of:
<<setup>>=
float d = D/N_SIDE_LENSLET;
@  The linear minimum mean square error wavefront reconstructor is initialized with the atmosphere, the lenslet array pitch, the number of slopes and the iterative solver type and destroyed with
<<setup>>=
LMMSE lmmse, ngs_lmmse, alt_lmmse;

@  Finally we setup the statistical tool:
<<setup>>=
stats S;
S.setup();
<<cleanup>>=
S.cleanup();
@
\subsection{Turbulence wavefront}
\label{sec:turbulence-wavefront}

Lets compute the wavefront propagated through the atmosphere from [[src]]
<<setup>>=
int NP, NP2, NP_fried, NP2_fried;
NP = 2*N_SIDE_LENSLET+1;
NP2 = NP*NP;
NP_fried = N_SIDE_LENSLET+1;
NP2_fried = NP_fried*NP_fried;
<<wavefront>>=
float delta_e = d/2;
float phase2nm;
phase2nm = atm.wavelength/2/PI;
float wf_rms;
// NGS
atm.get_phase_screen(&src,delta_e,NP,delta_e,NP,0);
wf_rms = 1E9*S.std(src.wavefront.phase, NP2);
printf("\n WF RMS: %7.2fnm\n",wf_rms);
// NGS with Fried geometry
atm.get_phase_screen(&src_fried,d,NP_fried,d,NP_fried,0);
wf_rms = 1E9*S.std(src_fried.wavefront.phase, NP2_fried);
printf("\n WF RMS: %7.2fnm\n",wf_rms);
// LGS
atm.get_phase_screen(&near_src,delta_e,NP,delta_e,NP,0);
wf_rms = 1E9*S.std(near_src.wavefront.phase, NP2);
printf("\n WF(near source) RMS: %7.2fnm\n",wf_rms);
// LGS with Fried geometry
atm.get_phase_screen(&near_src_fried,d,NP_fried,d,NP_fried,0);
wf_rms = 1E9*S.std(near_src_fried.wavefront.phase, NP2_fried);
printf("\n WF RMS: %7.2fnm\n",wf_rms);
@  We also compute the wavefront gradient:
<<NGS wavefront>>=
atm.get_phase_screen_gradient(&cog,N_SIDE_LENSLET,d,&ngs,0);
//dev2file("ngs_cog.bin",cog.d__c,2*_N_LENSLET_);
<<LGS uplink wavefront>>=
float lgs_theta_x, lgs_theta_y;
atm.get_phase_screen_gradient(&cog, 1,d,&lgs,0);
<<LGS wavefront>>=
atm.get_phase_screen_gradient(&cog,N_SIDE_LENSLET,d,&lgs,0);
@ The wavefront is written to the disk
<<saving to files>>=
dev2file("phaseScreenLowResNearField.bin", near_src.wavefront.phase, NP2);
dev2file("phaseScreenLowRes.bin", src.wavefront.phase, NP2);
dev2file("phaseScreenLowResNearFieldFried.bin", near_src_fried.wavefront.phase, NP2_fried);
dev2file("phaseScreenLowResFried.bin", src_fried.wavefront.phase, NP2_fried);
@
\subsection{Wavefront reconstruction}
\label{sec:wavefr-reconstr}

In the following, the wavefront is reconstructed from the centroids:
<<wavefront reconstruction from NGS>>=
printf("\n___ NGS WAVEFRONT ESTIMATE ___\n");
ngs_lmmse.setup(&atm,&ngs,1,&ngs,1,d,_N_LENSLET_*2,"MINRES");
ngs_lmmse.estimation(cog.d__c, 100);
//ngs_lmmse.aa.toFile("ngs_aa.bin");
//ngs_lmmse.pa.toFile("ngs_pa.bin");
phase_est = ngs_lmmse.d__phase_est;
<<wavefront error>>
ngs_lmmse.cleanup();

LMMSE ngs_fried_lmmse;
ngs_fried_lmmse.fried_setup(&atm,&ngs,1,&ngs,1,d,_N_LENSLET_*2,"MINRES");
ngs_fried_lmmse.fried_estimation(cog.d__c, 100);
phase_est = ngs_fried_lmmse.d__phase_est;
ngs_fried_lmmse.aa.toFile("ngs_fried_aa.bin");
ngs_fried_lmmse.pa.toFile("ngs_fried_pa.bin");
<<wavefront error Fried>>
dev2file("phaseEstFried.bin", ngs_fried_lmmse.d__phase_est, (N_SIDE_LENSLET+1)*(N_SIDE_LENSLET+1));
ngs_fried_lmmse.cleanup();
printf("------------------------------\n");

<<Fried wavefront reconstruction (test)>>=
int NL = 10, NL2, ML, ML2;
NL2 = NL*NL;
ML = NL+1;
ML2 = ML*ML;

paStats pas;
pas.setup(ML, NL, 1,  &atm, d, &ngs, 1, &ngs, 1);
pas.toFile("test_pa.bin");

BTBT Cpa;
Cpa.setup(1,2,ML,NL,pas.d__cov);
printf("NT2=%d\n",Cpa.NT2);
//dev2file("test_Cpa.bin",Cpa.d__cov, Cpa.NDFT );

float *data;
data = (float*)malloc(sizeof(float)*NL2*2); 
for (int k=0;k<NL2*2;k++)
  data[k] = k;
float *d__x;
HANDLE_ERROR( cudaMalloc((void**)&d__x, sizeof(float)*NL2*2 ) );
HANDLE_ERROR( cudaMemcpy( d__x, data, 2*NL2*sizeof(float), cudaMemcpyHostToDevice ) );
dev2file("test_x.bin",d__x,NL2*2);

float *d__y;
HANDLE_ERROR( cudaMalloc((void**)&d__y, sizeof(float)*ML2 ) );
Cpa.MVM(d__y,d__x);
dev2file("test_y.bin",d__y,ML2);

pas.cleanup();
Cpa.cleanup();
free(data);
HANDLE_ERROR(cudaFree(d__x));
HANDLE_ERROR(cudaFree(d__y));

<<wavefront reconstruction from LGS>>=
printf("\n___ LGS WAVEFRONT ESTIMATE (conic geom.) ___\n");
lmmse.setup(&atm,&lgs,1,&near_src,1,d,_N_LENSLET_*2,"MINRES");
lmmse.estimation(cog.d__c, 100);
//wf_rms = phase2nm*S.std(lmmse.d__phase_est, NP2);
//printf("\n WF RMS: %7.2fnm\n",wf_rms);
phase_est = lmmse.d__phase_est;
<<wavefront error near source>>
<<wavefront error>>
dev2file("phaseEst.bin", lmmse.d__phase_est, NP2);

source src1;
src1.setup(ARCSEC(0) , 0, INFINITY, 47*47);
float d1;
d1 = d*(1.-1./9.);
atm.get_phase_screen(&src1,d1,47,d1,47,0);
dev2file("phaseScreen47.bin", src1.wavefront.phase, src1.wavefront.N_PX);
src1.cleanup();

LMMSE lgs_fried_lmmse;
lgs_fried_lmmse.fried_setup(&atm,&near_src,1,&near_src,1,d,_N_LENSLET_*2,"MINRES");
lgs_fried_lmmse.fried_estimation(cog.d__c, 100);
lgs_fried_lmmse.aa.toFile("lgs_fried_aa.bin");
lgs_fried_lmmse.pa.toFile("lgs_fried_pa.bin");
phase_est = lgs_fried_lmmse.d__phase_est;
<<wavefront error near source Fried>>
<<wavefront error Fried>>
dev2file("phaseEstLgsFried.bin", lgs_fried_lmmse.d__phase_est, (N_SIDE_LENSLET+1)*(N_SIDE_LENSLET+1));
lgs_fried_lmmse.cleanup();
printf("------------------------------\n");

<<paStats MVM alternative>>=
printf("\n___ LGS WAVEFRONT ESTIMATE (cylindric/conic geom. I) ___\n");
pa.MVM(lmmse.d__phase_est,lmmse.d__ce,
       delta_e, 1, NP,
       delta_e, NP,
       &atm, &src, 1, &lgs, 1);
//wf_rms = phase2nm*S.std(lmmse.d__phase_est, NP2);
//printf("\n WF RMS: %7.2fnm\n",wf_rms);
<<wavefront error>>
dev2file("phaseEstAlt.bin", lmmse.d__phase_est, NP2);
lmmse.cleanup();
printf("------------------------------\n");
<<setup>>=
paStats pa;
pa.setup(N_SIDE_LENSLET,2,&atm,d,&src,1,&lgs,1);
//pa.toFile("paCovariance.bin");
<<cleanup>>=
pa.cleanup();

<<LMMSE MVM alternative>>=
printf("\n___ LGS WAVEFRONT ESTIMATE (cylindric/conic geom. II) ___\n");
alt_lmmse.new_setup(&atm,&lgs,1,&near_src,1,d,_N_LENSLET_*2,"MINRES");
alt_lmmse.new_estimation(cog.d__c,100);
phase_est = alt_lmmse.d__phase_est_i;
<<wavefront error>>
//dev2file("phaseEstAltLmmse.bin", alt_lmmse.d__phase_est, alt_lmmse.PS_E_N_PX);
dev2file("phaseEstItpAltLmmse.bin", alt_lmmse.d__phase_est_i, NP2);
alt_lmmse.new_cleanup();
printf("------------------------------\n");

<<LMMSE MVM alternative Fried>>=
printf("\n___ LGS WAVEFRONT ESTIMATE (cylindric/conic Fried geom.) ___\n");
LMMSE alt_fried_lmmse;
alt_fried_lmmse.fried_setup(&atm,&lgs,1,&src,1,d,_N_LENSLET_*2,"MINRES");
alt_fried_lmmse.fried_sparse_estimation(cog.d__c,100);
alt_fried_lmmse.aa.toFile("ngs-lgs_fried_aa.bin");
alt_fried_lmmse.pa.toFile("ngs-lgs_fried_pa.bin");
phase_est = alt_fried_lmmse.d__phase_est_i;
<<wavefront error Fried>>
dev2file("phaseEstAltLmmse.bin", alt_fried_lmmse.d__phase_est, alt_fried_lmmse.PS_E_N_PX);
dev2file("phaseEstAltItpLmmse.bin", alt_fried_lmmse.d__phase_est_i, NP2_fried);
alt_fried_lmmse.new_cleanup();
printf("------------------------------\n");

@ The wavefront error is computed with
<<setup>>=
cublasHandle_t handle;
cublasCreate(&handle);
float *d__wavefront_error, *d__wavefront_error_fried, *phase_est;
HANDLE_ERROR( cudaMalloc((void**)&d__wavefront_error, sizeof(float)* NP2) );
HANDLE_ERROR( cudaMalloc((void**)&d__wavefront_error_fried, sizeof(float)* NP2_fried) );
float alpha;
<<cleanup>>=
cublasDestroy(handle);
HANDLE_ERROR( cudaFree(d__wavefront_error) );
HANDLE_ERROR( cudaFree(d__wavefront_error_fried) );

<<wavefront error>>=
CUBLAS_ERROR( cublasScopy(handle, NP2, src.wavefront.phase, 1, d__wavefront_error, 1) );
alpha = -1;//phase2nm;
CUBLAS_ERROR( cublasSaxpy(handle, NP2, &alpha, phase_est, 1, d__wavefront_error, 1) );
wf_rms = 1E9*S.std(d__wavefront_error, NP2);
printf("\n WFE RMS: %8.3fnm\n",wf_rms);

<<wavefront error Fried>>=
CUBLAS_ERROR( cublasScopy(handle, NP2_fried, src_fried.wavefront.phase, 1, d__wavefront_error_fried, 1) );
alpha = -1;//phase2nm;
CUBLAS_ERROR( cublasSaxpy(handle, NP2_fried, &alpha, phase_est, 1, d__wavefront_error_fried, 1) );
wf_rms = 1E9*S.std(d__wavefront_error_fried, NP2_fried);
printf("\n WFE RMS (Fried geom.): %8.3fnm\n",wf_rms);

<<wavefront error near source>>=
CUBLAS_ERROR( cublasScopy(handle, NP2, near_src.wavefront.phase, 1, d__wavefront_error, 1) );
CUBLAS_ERROR( cublasSaxpy(handle, NP2, &alpha, phase_est, 1, d__wavefront_error, 1) );
wf_rms = 1E9*S.std(d__wavefront_error, NP2);
printf("\n WFE (near source) RMS: %8.3fnm\n",wf_rms);

<<wavefront error near source Fried>>=
CUBLAS_ERROR( cublasScopy(handle, NP2_fried, near_src_fried.wavefront.phase, 1, d__wavefront_error_fried, 1) );
alpha = -1;//phase2nm;
CUBLAS_ERROR( cublasSaxpy(handle, NP2_fried, &alpha, phase_est, 1, d__wavefront_error_fried, 1) );
wf_rms = 1E9*S.std(d__wavefront_error_fried, NP2_fried);
printf("\n WFE RMS (Fried geom.): %8.3fnm\n",wf_rms);

@ 
\section{LTAO}
\label{sec:ltao}

For the LTAO wavefront estimation, the LGS constellation is defined first.
We will use 3 LGSs on a 15 arcsec radius ring.
<<setup>>=
int N_GS = 3;
float gs_radius = 15;
// 3 LGS on a ring
float zenith[] = {ARCSEC(gs_radius),ARCSEC(gs_radius),ARCSEC(gs_radius)},
  azimuth[] = {0,2.*PI/3.,4.*PI/3.};
// 6 LGS on a ring
/*
float zenith[] = {ARCSEC(30),ARCSEC(30),ARCSEC(30),ARCSEC(30),ARCSEC(30)},
  azimuth[] = {0,2.*PI/6.,4.*PI/6.,6.*PI/6.,8.*PI/6.,10.*PI/6.,12.*PI/6.};
*/
source gs_ast, gs_ast_fried;
gs_ast.setup(zenith,azimuth,90e3,N_GS);
gs_ast_fried.setup(zenith,azimuth,90e3,N_GS,NP2_fried);
<<cleanup>>=
gs_ast.cleanup();
gs_ast_fried.cleanup();

@ The wavefront sensor of the LGS asterism are setup next
<<setup>>=
centroiding gs_ast_cog;
gs_ast_cog.setup(_N_LENSLET_,N_GS);
<<cleanup>>=
gs_ast_cog.cleanup();

@ The 3 source are propagated through the atmosphere to the wavefront sensor.
<<LTAO wavefronts and wavefront gradients>>=
atm.get_phase_screen(&gs_ast,N_GS,delta_e,NP,delta_e,NP,0);
gs_ast.wavefront.phase2file("ngsAstWavefronts.bin");
atm.get_phase_screen(&gs_ast_fried,N_GS,d,NP_fried,d,NP_fried,0);
gs_ast_fried.wavefront.phase2file("ngsAstWavefrontsFried.bin");
atm.get_phase_screen_gradient(&gs_ast_cog,N_SIDE_LENSLET,d,&gs_ast,N_GS,0);
//dev2file("gs_ast_cog.bin",gs_ast_cog.d__c,2*_N_LENSLET_*N_GS);

@ We solve:
<<LTAO wavefront estimation>>=
printf("\n___ NGS WAVEFRONT ESTIMATE ___\n");
//gs_ast_lmmse.iSolve.VERBOSE = 1;
gs_ast_lmmse.estimation(gs_ast_cog.d__c, 100);
phase_est = gs_ast_lmmse.d__phase_est;
<<wavefront error>>
dev2file("phaseEstNtao.bin", gs_ast_lmmse.d__phase_est, NP2);

<<setup>>=
LMMSE gs_ast_lmmse;
gs_ast_lmmse.setup(&atm,&gs_ast,N_GS,&lgs,1,d,_N_LENSLET_*2,"MINRES");
//gs_ast_lmmse.aa.toFile("gs_ast_aaCovariance.bin");
//gs_ast_lmmse.pa.toFile("gs_ast_paCovariance.bin");
<<cleanup>>=
gs_ast_lmmse.cleanup();

<<LTAO wavefront estimation Fried>>=
LMMSE gs_ast_fried_lmmse;
gs_ast_fried_lmmse.fried_setup(&atm,&gs_ast,N_GS,&src,1,d,_N_LENSLET_*2,"MINRES");
gs_ast_fried_lmmse.aa.toFile("gs_ast_fried_aaCovariance.bin");
gs_ast_fried_lmmse.pa.toFile("gs_ast_fried_paCovariance.bin");
gs_ast_fried_lmmse.fried_sparse_estimation(gs_ast_cog.d__c,100);
phase_est = gs_ast_fried_lmmse.d__phase_est_i;
<<wavefront error Fried>>
dev2file("phaseEstAltTomoLmmse.bin", gs_ast_fried_lmmse.d__phase_est, gs_ast_fried_lmmse.PS_E_N_PX);
dev2file("phaseEstAltItpTomoLmmse.bin", gs_ast_fried_lmmse.d__phase_est_i, NP2_fried);
gs_ast_fried_lmmse.cleanup();
printf("------------------------------\n");

<<paStats MVM tomography>>=
printf("\n___ LGS WAVEFRONT ESTIMATE (cylindric/conic geom.) ___\n");
paTomo.MVM(gs_ast_lmmse.d__phase_est,gs_ast_lmmse.d__ce,
       delta_e, 1, NP,
       delta_e, NP,
       &atm, &src, 1, &gs_ast, N_GS);
//wf_rms = phase2nm*S.std(lmmse.d__phase_est, NP2);
//printf("\n WF RMS: %7.2fnm\n",wf_rms);
<<wavefront error>>
dev2file("phaseEstAltTomo.bin", gs_ast_lmmse.d__phase_est, NP2);
printf("------------------------------\n");
<<setup>>=
paStats paTomo;
paTomo.setup(N_SIDE_LENSLET,2,&atm,d,&src,1,&gs_ast,N_GS);
paTomo.toFile("paTomoCovariance.bin");
<<cleanup>>=
paTomo.cleanup();
