% -*- mode: Noweb; noweb-code-mode: c-mode -*-
@
\def\bk{\bar \kappa_i}
\def\bkx{\bar \kappa_{x,i}}
\def\bky{\bar \kappa_{y,i}}
\def\dk{\Delta \kappa_i}
\def\dphi{\Delta \varphi}
\def\nk{N_\kappa}
\def\na{N_\varphi}

\subsection{The files}

\subsubsection{Header}

<<atmosphere.h>>=
#ifndef __ATMOSPHERE_H__
#define __ATMOSPHERE_H__

#ifndef __CEO_H__
#include "ceo.h"
#endif

#ifndef __SOURCE_H__
#include "source.h"
#endif

#ifndef __CENTROIDING_H__
#include "centroiding.h"
#endif

#define RAND_SEED 2013

struct profile {

  <<profile parameters>>

  void setup(float *altitude, float *xi0,
	     float *wind_speed, float *wind_direction);

};

struct atmosphere {

  <<atmosphere parameters>>

  void setup(float r0_, float L0, 
	     float *altitude, float *xi0,
	     float *wind_speed, float *wind_direction);
  void setup(float r0_, float L0, 
	     float altitude,
	     float wind_speed, float wind_direction);
  void gmt_setup();
  void gmt_setup(float r0_, float L0);

  void cleanup(void);

  void info(void);

  void reset(void);

  void get_phase_screen(float *phase_screen,
			float const *x, float const *y, int N_xy, 
			source *src, float time);

  void get_phase_screen(float const *x, float const *y, int N_xy, 
			source *src, float time);

  void get_phase_screen(float const delta_x, int N_x, float const delta_y, int N_y, 
			source *src, float time);

  void get_phase_screen(float *phase_screen,
			float const delta_x, int N_x, float const delta_y, int N_y, 
			source *src, float time);
  void get_phase_screen(source *src,
			float const delta_x, int N_x, float const delta_y, int N_y, 
			float time);
  void get_phase_screen(source *src, int N_SRC,
			float const delta_x, int N_x, float const delta_y, int N_y, 
			float time);

  void get_phase_screen_gradient(float *sx, float *sy, int NL, float const d, source *src, float time);
  void get_phase_screen_gradient(float *sx, float *sy, int NL, char *valid_lenslet, float const d, source *src, float time);
  void get_phase_screen_gradient(centroiding *cog, int NL, float const d, source *src, float time);
  void get_phase_screen_gradient(centroiding *cog, int NL, float const d, source *src, int N_SRC, float time);

};

#endif // __ATMOSPHERE_H__
@
\subsubsection{Source}

<<atmosphere.cu>>=
#include "atmosphere.h"

<<sinc (atm)>>

<<init random variates>>

<<variates>>

<<new variates>>

<<phase screen kernel>>

<<phase screen kernel (square)>>

<<phase screen gradient kernel>>
<<phase screen gradient kernel (masked)>>

<<profile setup>>

<<atmosphere setup>>
<<atmosphere setup (single layer)>>
<<atmosphere setup (GMT)>>
<<atmosphere setup (GMT prm)>>

<<cleanup>>

<<info>>

<<phase screen I>>
<<phase screen II>>
<<phase screen III>>
<<phase screen IV>>
<<phase screen V>>
<<phase screen VI>>

<<phase screen gradient I>>
<<phase screen gradient II>>
<<phase screen gradient III>>
<<phase screen gradient (masked)>>
@
\subsection{Parameters}
\label{sec:prms}

The atmosphere parameters are
\begin{itemize}
\item the Fried parameter $r_0$ are a given photometric band
<<atmosphere parameters>>=
char *photometric_band;
float wavelength, r0, wavenumber;
@ \item the outer scale
<<profile parameters>>=
float  L0;      
@ \item the turbulence layers altitude
<<profile parameters>>=
float altitude[_N_LAYER_],
@ \item the fractional $r_0$ vector: $$\xi_0(h)= \left( r_0(h)\over r_0 \right)^{-5/3}$$
<<profile parameters>>=
      xi0[_N_LAYER_],
@ \item the wind vector
<<profile parameters>>=
  wind_speed[_N_LAYER_], wind_direction[_N_LAYER_];

@ \end{itemize}

\subsection{Functions}
\label{sec:functions}

The main parameters of the atmosphere are displayed with the [[info]] routine:
<<info>>=
void atmosphere::info(void)
{
printf("\n\x1B[1;42m@(CEO)>atmosphere: Von Karman atmospheric turbulence model\x1B[;42m\n");
printf(" . wavelength = %5.2fnm\n . r0 = %5.2fcm\n . L0 = %5.2fm\n",
       wavelength*1e9,r0*1e2,turbulence.L0);
printf("----------------------------------------------------\n");
printf("  Layer   Altitude[m]   fr0    wind([m/s] [deg])\n");
for (int kLayer=0;kLayer<_N_LAYER_;kLayer++) {
  printf("  %2d      %8.2f      %4.2f    (%5.2f %6.2f)\n",
  kLayer,
  turbulence.altitude[kLayer],
  turbulence.xi0[kLayer],
  turbulence.wind_speed[kLayer],
  turbulence.wind_direction[kLayer]*180/PI);
}
printf("----------------------------------------------------\x1B[0m\n");
}
@

\subsubsection{Phase screen}
\label{sec:phase-screen}

The phase screen equation is 
\begin{eqnarray}
  \label{eq:1}
  \varphi(x,y) &=& 1.4 r_0^{-{5\over6}}\sum_{i=1}^{N_\kappa}\sum_{j=1}^{N_\varphi} \Gamma\left( \bk\right) \\
&& \times \left\{ \zeta_1(i,j) \cos\left[ \eta_1(i,j) + \bk \left( x\cos \phi_j + y\sin \phi_j \right) \right] \right. \nonumber\\
&& \quad + \left. \zeta_2(i,j) \cos\left[ \eta_2(i,j) - \bk \left( x\sin \phi_j - y\cos \phi_j \right) \right] \right\} \nonumber
\end{eqnarray}
where 
\begin{equation}
  \label{eq:2}
  \Gamma\left( \bk\right) = \left[ \Lambda(\bk) \bk \dk \dphi \right]^{1\over2}
\end{equation}
$\Lambda\left( \bk\right)$ is the spectrum kernel at the spatial frequency $\bk$, given by
\begin{equation}
  \label{eq:3}
  \Lambda\left( \bk\right) = \left( \bk^2 + \kappa_0^2 \right)^{-{11\over6}}
\end{equation}
with $\kappa_0=2\pi/\mathcal L_0$, where $\mathcal L_0$ is the outer scale.

Eq.~(\ref{eq:1}) is defined over a frequency range f, $$f={\kappa_{max}\over \kappa_{min}}$$ and for a frequency resolution $\delta$, $$\delta={\dk\over\bk}.$$
$\bk$ and $\varphi_j$ are the magnitude and angle of the spatial frequency vector.
$\bk$ is the average spatial frequency over a given interval $i$ and is written
\begin{equation}
  \label{eq:4}
  \bk = {\kappa_{min}\over 2}f^{i\over\nk}\left( 1 + f^{-{1\over\nk}} \right).
\end{equation}
The interval width is given by
\begin{equation}
  \label{eq:5}
  \dk = \kappa_{min}f^{i\over\nk}\left( 1 - f^{-{1\over\nk}} \right).
\end{equation}
$\varphi_j$ is derived from
\begin{equation}
  \label{eq:6}
  \varphi_j = \left( j -{1\over2} \right) \Delta\varphi
\end{equation}
with $\Delta\varphi=\delta$.

The number of frequency and angle samples are given by
\begin{equation}
  \label{eq:7}
  \nk = { \ln f \over \ln \left( 2+\delta \over 2-\delta \right) }
\end{equation}
and
\begin{equation}
  \label{eq:8}
  \na = {\pi\over4} \left( f^{1\over\nk}+1 \over f^{1\over\nk}-1 \right).
\end{equation}

The frequency range and resolution can also be derived from the $\nk$ and $\na$:
\begin{equation}
  \label{eq:9}
  f = \left( 4\na + \pi \over 4\na - \pi \right)^{\nk}
\end{equation}
and
\begin{equation}
  \label{eq:10}
  \delta = {\pi\over2\na}.
\end{equation}

$\zeta$ and $\eta$ are variates defined by
\begin{equation}
  \label{eq:11}
  \zeta = \left( -\ln\beta_1 \right)^{1\over2}
\end{equation}
and
\begin{equation}
  \label{eq:12}
  \eta = 2\pi\beta_2,
\end{equation}
where $\beta_1$ and $\beta_2$ are uniformly distributed variates.

Eq.~(\ref{eq:1}) gives the expression of a single phase screen sampled with the rays of a light source at infinity.
For an atmosphere made of several phase screens with a source at a finite distance, Eq.~(\ref{eq:1}) becomes:
\begin{eqnarray}
  \label{eq:13}
    \varphi(x,y) &=& 1.4 r_0^{-{5\over6}} \sum_{i=1}^{N_\kappa}\sum_{j=1}^{N_\varphi} \Gamma\left( \bk\right) \sum_{l=1}^{[[_N_LAYER_]]} \xi_{0l}^{1\over2} \\
&& \times \left\{ \zeta_{1l}(i,j) \cos\left[ \eta_{1l}(i,j) + \bk \left( x_l\cos \phi_j + y_l\sin \phi_j \right) \right] \right. \nonumber\\
&& \quad + \left. \zeta_{2l}(i,j) \cos\left[ \eta_{2l}(i,j) - \bk \left( x_l\sin \phi_j - y_l\cos \phi_j \right) \right] \right\} \nonumber\\
x_l &=& \left( 1 - {h_l\over z_\ast} \right)(x-v_xt) + h_l\theta_{\ast x} \\
y_l &=& \left( 1 - {h_l\over z_\ast} \right)(y-v_yt) + h_l\theta_{\ast y} 
\end{eqnarray}

The above definitions call for the declarations of new variables:
<<profile parameters>>=
float l0, L, f, delta, N_k, N_a, kmin;
float vx[_N_LAYER_], vy[_N_LAYER_];
@ 
<<atmosphere parameters>>=
float *zeta1, *eta1, *zeta2, *eta2;
curandState *devStates;
profile turbulence, *d__turbulence;
@ This variables are defined in the setup routines:
<<atmosphere setup>>=
void atmosphere::setup(float r0_, float L0, 
		       float *altitude, float *xi0,
		       float *wind_speed, float *wind_direction) {
  wavelength = 550e-9;
  wavenumber = wavelength/2/PI;
  r0 = r0_;
  turbulence.L0 = L0;
  turbulence.setup(altitude, xi0,
		   wind_speed, wind_direction);
  <<allocation>>
}
@  or for a single layer atmosphere, one can call instead:
<<atmosphere setup (single layer)>>=
void atmosphere::setup(float r0_, float L0, 
		       float altitude,
		       float wind_speed, float wind_direction) {
  wavelength = 550e-9;
  wavenumber = wavelength/2/PI;
  r0 = r0_;
  turbulence.L0 = L0;
  float xi0 = 1;
  turbulence.setup(&altitude, &xi0,
		   &wind_speed, &wind_direction);
  <<allocation>>
}
@ For the GMT simulations, the GMT standard atmosphere model is called with:
<<atmosphere setup (GMT)>>=
void atmosphere::gmt_setup() {
  wavelength = 550e-9;
  wavenumber = wavelength/2/PI;
  r0 = 15e-2;
  turbulence.L0 = 60;
  float altitude[] = {25, 275, 425, 1250, 4000, 8000, 13000},
              xi0[] = {0.1257, 0.0874, 0.0666, 0.3498, 0.2273, 0.0681, 0.0751},
              wind_speed[] = {5.6540, 5.7964, 5.8942, 6.6370, 13.2925, 34.8250, 29.4187},
              wind_direction[] = {0.0136, 0.1441, 0.2177, 0.5672, 1.2584, 1.6266, 1.7462};
  turbulence.setup(altitude, xi0,
		   wind_speed, wind_direction);
  <<allocation>>
}
<<atmosphere setup (GMT prm)>>=
void atmosphere::gmt_setup(float r0_, float L0) {
  wavelength = 550e-9;
  wavenumber = wavelength/2/PI;
  r0 = r0_;
  turbulence.L0 = L0;
  float altitude[] = {25, 275, 425, 1250, 4000, 8000, 13000},
              xi0[] = {0.1257, 0.0874, 0.0666, 0.3498, 0.2273, 0.0681, 0.0751},
              wind_speed[] = {5.6540, 5.7964, 5.8942, 6.6370, 13.2925, 34.8250, 29.4187},
              wind_direction[] = {0.0136, 0.1441, 0.2177, 0.5672, 1.2584, 1.6266, 1.7462};
  turbulence.setup(altitude, xi0,
		   wind_speed, wind_direction);
  <<allocation>>
}

<<allocation>>=
info();
HANDLE_ERROR( cudaMalloc( (void**)&d__turbulence, sizeof(profile) ) );
HANDLE_ERROR( cudaMemcpy( d__turbulence, &turbulence,
			  sizeof(profile), cudaMemcpyHostToDevice ) );
int nel = _N_LAYER_*turbulence.N_k*turbulence.N_a;
printf("\n@(CEO)>atmosphere: initializing %d variates ...",nel);
HANDLE_ERROR( cudaMalloc( (void**)&devStates, 4*nel*sizeof(curandState)) );  
HANDLE_ERROR( cudaMalloc( (void**)&zeta1, nel*sizeof(float)) );
HANDLE_ERROR( cudaMalloc( (void**)&eta1,  nel*sizeof(float)) );
HANDLE_ERROR( cudaMalloc( (void**)&zeta2, nel*sizeof(float)) );
HANDLE_ERROR( cudaMalloc( (void**)&eta2,  nel*sizeof(float)) );
dim3 blockDim(64,1);
dim3 gridDim( 1+4*nel/64 , 1 );
setupRandomSequence LLL gridDim,blockDim RRR (devStates, 4*nel);
HANDLE_ERROR( cudaDeviceSynchronize() );
generateVariates LLL gridDim,blockDim RRR (zeta1, eta1, zeta2, eta2, devStates, nel);
HANDLE_ERROR( cudaDeviceSynchronize() );
printf("done!\n");

@ 
<<profile setup>>=
void profile::setup(float *altitude_, float *xi0_,
		    float *wind_speed_, float *wind_direction_) {
  for (int k=0;k<_N_LAYER_;k++)
    {
      altitude[k] = altitude_[k];
      xi0[k]      = xi0_[k];
      wind_speed[k]     = wind_speed_[k];
      wind_direction[k] = wind_direction_[k];
      vx[k] = wind_speed[k]*cosf(wind_direction[k]);
      vy[k] = wind_speed[k]*sinf(wind_direction[k]);
    }
  l0    = 1e-3;
  L     = 1e2;
  f     = MAX(L,3*L0);
  kmin  = 2*PI/f;
  f     = f/l0;
  delta = 0.05; // TODO: like f, should depends on the input parameters but 5% seems optimal from a statistical stand point
  N_k = logf(f)/log( (2+delta)/(2-delta) );
  N_a = powf( f , 1/N_k ) ;
  N_a = 0.25*PI*( (N_a + 1)/(N_a - 1) );
  N_k = ceilf( N_k );
  N_a = ceilf( N_a );
  f = powf( (4*N_a + PI)/(4*N_a - PI) , N_k );
  delta = 0.5*PI/N_a;
  printf("\n@(CEO)>profile:\n");
  printf(" . N_k = %f\n",N_k);
  printf(" . N_a = %f\n",N_a);
  printf(" . frequency range      = %8.2f\n",f);
  printf(" . frequency resolution = %6.4f\n",delta);
  printf(" . minimum frequency    = %6.4f\n",kmin);
}
@ 
The random generator is initialized within the following kernel:
<<init random variates>>=
__global__ void setupRandomSequence(curandState *state, int n_state) 
{
  int id;
  id = blockIdx.x * blockDim.x + threadIdx.x;
  if (id<n_state)
    curand_init(RAND_SEED, id, 0, &state[id]);  
}
@  and the variates are generated with:
<<variates>>=
__global__ void generateVariates(float *zeta1, float *eta1, float *zeta2, float *eta2, 
			    curandState *state, int n_state)
{
  int id;
  curandState localState;
  id = blockIdx.x * blockDim.x + threadIdx.x;
  if (id<n_state)
    {
      localState = state[id*4];
      zeta1[id] = curand_uniform(&localState);
      zeta1[id] = sqrtf( -logf( zeta1[id] ) );
      state[id*4] = localState;

      localState = state[id*4+1];
      eta1[id] = curand_uniform(&localState);
      eta1[id] = 2*PI*eta1[id];
      state[id*4+1] = localState;

      localState = state[id*4+2];
      zeta2[id] = curand_uniform(&localState);
      zeta2[id] = sqrtf( -logf( zeta2[id] ) );
      state[id*4+2] = localState;

      localState = state[id*4+3];
      eta2[id] = curand_uniform(&localState);
      eta2[id] = 2*PI*eta2[id];
      state[id*4+3] = localState;

    }
}
@ New variates can be computed with the call to the routine:
<<new variates>>=
void atmosphere::reset(void)
{
  int nel = _N_LAYER_*turbulence.N_k*turbulence.N_a;
  dim3 blockDim(64,1);
  dim3 gridDim( 1+nel/64 , 1 );
  generateVariates LLL gridDim,blockDim RRR (zeta1, eta1, zeta2, eta2, devStates, nel);
}
@ The dynamically allocated variables are freed in the cleanup routine:
<<cleanup>>=
void atmosphere::cleanup(void) {
  fprintf(stderr,"@(CEO)>atmosphere: freeing memory!\n");
  HANDLE_ERROR( cudaFree( devStates ) );
  HANDLE_ERROR( cudaFree( zeta1  ));
  HANDLE_ERROR( cudaFree( eta1 ) );
  HANDLE_ERROR( cudaFree( zeta2 ) );
  HANDLE_ERROR( cudaFree( eta2 ) );
  HANDLE_ERROR( cudaFree( d__turbulence ) );
}
@
The phase screen are defined in the telescope pupil at the ground 
<<phase screen I>>=
void atmosphere::get_phase_screen(float *phase_screen,
		       float const *x, float const *y, int N_xy, 
		       source *src, float time)
{
  dim3 blockDim(16,16);
  dim3 gridDim( ceilf(sqrt(N_xy)/16) , ceilf(sqrt(N_xy)/16));
  plps LLL gridDim , blockDim RRR (phase_screen,
				   x, y, N_xy, 
				   d__turbulence, wavenumber*powf(r0,-5.0/6.0),
				   zeta1, eta1, zeta2, eta2,
				   src, time);
}
@ 
<<phase screen II>>=
void atmosphere::get_phase_screen(float const *x, float const *y, int N_xy, 
		       source *src, float time)
{
  dim3 blockDim(16,16);
  dim3 gridDim( ceilf(sqrt(N_xy)/16) , ceilf(sqrt(N_xy)/16));
  plps LLL gridDim , blockDim RRR (src->wavefront.phase,
				   x, y, N_xy, 
				   d__turbulence, wavenumber*powf(r0,-5.0/6.0),
				   zeta1, eta1, zeta2, eta2,
				   src, time);
}
@ and computed with the kernel
<<phase screen kernel>>=
  __global__ void plps(float *phase_screen,
		       float const *x, float const *y, int N_xy, 
		       profile *turb, float r0,
		       float *zeta1, float *eta1, float *zeta2, float *eta2,
		       source *src, float time)
{
  <<declarations>>

  <<thread to coordinate index>>
  
  sum = 0;
  
  if (kl<N_xy)
    {

      <<variables>>

      for (i=0;i<turb->N_k;i++)
	{
	  <<frequency magnitude sum>>
          for (j=0;j<turb->N_a;j++)
	    {
	      <<frequency angle sum>>
	      for (l=0;l<_N_LAYER_;l++)
		{
		  <<layer sum>>
		}
	      sum += sqrt_spectrum_kernel*sum_l;
	    }
	}
      phase_screen[kl] = 1.4*r0*sum;
    }
}
@ 
The kernel starts with some declarations:
<<declarations (common)>>=
  int i, j, l, ij, ijl, kl, i_source;
float freq_mag0, delta_freq_mag0, f_red0, f_red, 
  freq_L0_square, x_kl, y_kl, x_kl0, y_kl0, gl,
  freq_mag, delta_freq_mag, sqrt_spectrum_kernel,
  freq_ang, cos_freq_ang, sin_freq_ang;
<<declarations>>=
<<declarations (common)>>
float sum, sum_l;
@ 
Each thread is computing one value of the phase screen at the coordinate [[x_kl = x[kl]]] and [[y_kl = y[kl]]]
<<thread to coordinate index>>=
i = blockIdx.x * blockDim.x + threadIdx.x;
j = blockIdx.y * blockDim.y + threadIdx.y;
i_source = blockIdx.z;
kl = j * gridDim.x * blockDim.x + i + i_source*N_xy;
x_kl0 = x[kl];
y_kl0 = y[kl];
@ 
Next a few new variables are defined, $$[[f_red0]]=f^{1/N_k},$$, $$[[freq_mag0]]=\kappa_{min}{[[f_red0]]+1)\over 2[[f_red0]]},$$ $$[[delta_freq_mag0]]=\kappa_{min}{[[f_red0]]-1)\over [[f_red0]]},$$ $$[[freq_L0_square]]=\left(2\pi\over\mathcal L_0\right)^2.$$
<<variables>>=
f_red0 = powf(turb->f,1/turb->N_k);
freq_mag0 = 0.5*turb->kmin*( f_red0 + 1 )/f_red0;
delta_freq_mag0 = turb->kmin*( f_red0 - 1 )/f_red0;
f_red  = 1;
freq_L0_square = 2*PI/turb->L0;
freq_L0_square *= freq_L0_square;
@ 
The outer loop is the sum over the frequency magnitude. It computes $\bk$, $\dk$ and $\Gamma\left( \bk\right)$:
<<frequency magnitude sum>>=
f_red *= f_red0;
freq_mag = freq_mag0*f_red;
delta_freq_mag = delta_freq_mag0*f_red;
sqrt_spectrum_kernel =
  powf( freq_mag*freq_mag + freq_L0_square, -11.0/12.0)*
  sqrt(freq_mag*delta_freq_mag*turb->delta);
@ 
The inner loop is the sum over the frequency angle. It computes $\varphi_j$, $\sin(\varphi_j)$ and $\cos(\varphi_j)$.
<<frequency angle sum (common)>>=
 freq_ang = (j+0.5)*turb->delta;
 sincosf(freq_ang, &sin_freq_ang, &cos_freq_ang);
 ij = i*turb->N_a + j;
<<frequency angle sum>>=
<<frequency angle sum (common)>>
 sum_l = 0;
@ 
The innest loop is the sum over the layer.
<<layer sum>>=
  ijl = ij + l*turb->N_a*turb->N_k;
gl = 1 - turb->altitude[l]/src[i_source].height;
x_kl = x_kl0 - turb->vx[l]*time;
y_kl = y_kl0 - turb->vy[l]*time;
x_kl = gl*x_kl + turb->altitude[l]*src[i_source].theta_x;
y_kl = gl*y_kl + turb->altitude[l]*src[i_source].theta_y;
sum_l += sqrt(turb->xi0[l])*
   ( zeta1[ijl]*cosf( eta1[ijl] +
		     freq_mag*( x_kl*cos_freq_ang + y_kl*sin_freq_ang ) ) +
     zeta2[ijl]*cosf( eta2[ijl] -
		     freq_mag*( x_kl*sin_freq_ang - y_kl*cos_freq_ang ) ));
@ 
The next routine compute the phase screen on a square grid of size [[N_x]]$\times$[[N_y]]
<<phase screen III>>=
void atmosphere::get_phase_screen(float const delta_x, int N_x, float const delta_y, int N_y, 
		       source *src, float time)
{
  dim3 blockDim(16,16);
  dim3 gridDim( 1+N_x/16 , 1+N_y/16);
  square_plps LLL gridDim , blockDim RRR (src->wavefront.phase,
				   delta_x, N_x, delta_y, N_y, 
				   d__turbulence, wavenumber*powf(r0,-5.0/6.0),
				   zeta1, eta1, zeta2, eta2,
				   src, time);
}
<<phase screen IV>>=
void atmosphere::get_phase_screen(float *phase_screen,
                       float const delta_x, int N_x, float const delta_y, int N_y, 
		       source *src, float time)
{
  dim3 blockDim(16,16);
  dim3 gridDim( 1+N_x/16 , 1+N_y/16);
  square_plps LLL gridDim , blockDim RRR (phase_screen,
				   delta_x, N_x, delta_y, N_y, 
				   d__turbulence, wavenumber*powf(r0,-5.0/6.0),
				   zeta1, eta1, zeta2, eta2,
				   src, time);
}
<<phase screen V>>=
void atmosphere::get_phase_screen(source *src,
                       float const delta_x, int N_x, float const delta_y, int N_y, 
		       float time)
{
  dim3 blockDim(16,16);
  dim3 gridDim( 1+N_x/16 , 1+N_y/16);
  square_plps LLL gridDim , blockDim RRR (src->wavefront.phase,
				   delta_x, N_x, delta_y, N_y, 
				   d__turbulence, wavenumber*powf(r0,-5.0/6.0),
				   zeta1, eta1, zeta2, eta2,
				   src->dev_ptr, time);
}
<<phase screen VI>>=
void atmosphere::get_phase_screen(source *src, int N_SRC,
                       float const delta_x, int N_x, float const delta_y, int N_y, 
		       float time)
{
  dim3 blockDim(16,16);
  dim3 gridDim( 1+N_x/16 , 1+N_y/16, N_SRC);
  square_plps LLL gridDim , blockDim RRR (src->wavefront.phase,
				   delta_x, N_x, delta_y, N_y, 
				   d__turbulence, wavenumber*powf(r0,-5.0/6.0),
				   zeta1, eta1, zeta2, eta2,
				   src->dev_ptr, time);
}
@ and computed with the kernel
<<phase screen kernel (square)>>=
  __global__ void square_plps(float *phase_screen,
		       float const delta_x, int N_x, float const delta_y, int N_y, 
		       profile *turb, float r0,
		       float *zeta1, float *eta1, float *zeta2, float *eta2,
		       source *src, float time)
{
  <<declarations>>

  <<thread to coordinate index (square)>>
  
  sum = 0;
  if ( (i<N_x) && (j<N_y) )
    {

      <<variables>>

      for (i=0;i<turb->N_k;i++)
	{
	  <<frequency magnitude sum>>
          for (j=0;j<turb->N_a;j++)
	    {
	      <<frequency angle sum>>
	      for (l=0;l<_N_LAYER_;l++)
		{
		  <<layer sum>>
		}
	      sum += sqrt_spectrum_kernel*sum_l;
	    }
	}
      phase_screen[kl] = 1.4*r0*sum;
    }
}
@
Each thread is computing one value of the phase screen at the coordinate [[x_kl = i*delta_x]] and [[y_kl = j*delta_y]]
<<thread to coordinate index (square)>>=
i = blockIdx.x * blockDim.x + threadIdx.x;
j = blockIdx.y * blockDim.y + threadIdx.y;
i_source = blockIdx.z;
kl = i * N_x + j + i_source*N_x*N_y;
x_kl0 = i*delta_x - (N_x-1)*delta_x*0.5;
y_kl0 = j*delta_y - (N_y-1)*delta_y*0.5;
@
\subsubsection{Phase screen gradient}
\label{sec:phase-scre-grad}

The centroids corresponding to a wavefront on a square pupil of size $d$ is written:
\begin{equation}
  \label{eq:14}
  s_{x,y} = {\lambda\over2\pi} {1\over d^2} \iint {\mathrm d\vec r} \Pi\left( x-x_L\over d \right) \Pi\left( y-y_L\over d \right) {\partial \varphi(x,y)\over\partial_{x,y}}.
\end{equation}
where $x_L$ and $y_L$ are the pupil center coordinates.
It is also given by the difference of the wavefront averaged on both sides of the pupil:
\begin{eqnarray}
  \label{eq:15}
  s_x &=& {\lambda\over2\pi} {1\over d} \int_{-d/2}^{d/2} {\mathrm d}y \varphi(x-x_L,y-y_L) \left[\delta\left(x+{d\over2}\right)-\delta\left(x-{d\over2}\right)\right] \\
  s_y &=& {\lambda\over2\pi} {1\over d} \int_{-d/2}^{d/2} {\mathrm d}x \varphi(x-x_L,y-y_L) \left[\delta\left(y+{d\over2}\right)-\delta\left(y-{d\over2}\right)\right] \\
\end{eqnarray}
Inserting Eq.~(\ref{eq:13}) into Eq.~(\ref{eq:15}) and performing the integration leads to:
\begin{eqnarray}
  \label{eq:16}
      s_x &=& -{\lambda\over 2\pi} 1.4 r_0^{-{5\over6}} \sum_{i=1}^{N_\kappa}\sum_{j=1}^{N_\varphi} \Gamma\left( \bk\right) \sum_{l=1}^{[[_N_LAYER_]]} \xi_{0l}^{1\over2} \mathrm{sinc}\left(\gamma_l^\ast\bkx d\over 2\right) \mathrm{sinc}\left(\gamma_l^\ast\bky d\over 2\right) \\
&& \times \left\{ \zeta_{1l}(i,j) \sin\left[ \eta_{1l}(i,j) + \bkx x_{L,l} + \bky y_{L,l} \right] \bkx \right. \nonumber\\
&& \quad - \left. \zeta_{2l}(i,j) \sin\left[ \eta_{2l}(i,j) - \bky x_{L,l} + \bkx y_{L,l} \right] \bky \right\} \nonumber\\
      s_y &=& -{\lambda\over 2\pi} 1.4 r_0^{-{5\over6}} \sum_{i=1}^{N_\kappa}\sum_{j=1}^{N_\varphi} \Gamma\left( \bk\right) \sum_{l=1}^{[[_N_LAYER_]]} \xi_{0l}^{1\over2} \mathrm{sinc}\left(\gamma_l^\ast\bkx d\over 2\right) \mathrm{sinc}\left(\gamma_l^\ast\bky d\over 2\right) \\
&& \times \left\{ \zeta_{1l}(i,j) \sin\left[ \eta_{1l}(i,j) + \bkx x_{L,l} + \bky y_{L,l} \right] \bky \right. \nonumber\\
&& \quad + \left. \zeta_{2l}(i,j) \sin\left[ \eta_{2l}(i,j) - \bky x_{L,l} + \bkx y_{L,l} \right] \bkx \right\} \nonumber
\end{eqnarray}
with
\begin{eqnarray}
  \label{eq:17}
  x_{L,l} &=& \gamma_l^\ast (x_L-v_xt) + h_l\theta_{\ast x} \\
y_{L,l} &=& \gamma_l^\ast (y_L-v_yt) + h_l\theta_{\ast y} \\
\gamma_l^\ast &=& 1 - {h_l\over z_\ast}\\
\bkx &=& \bk \cos \phi_j \\ 
\bky &=& \bk \sin \phi_j 
\end{eqnarray}
The phase screen gradient are computed on a $N_L\times N_L$ array with a resolution $d$
<<phase screen gradient I>>=
void atmosphere::get_phase_screen_gradient(float *sx, float *sy, int NL, float const d, source *src, float time)
{
  dim3 blockDim(16,16);
  dim3 gridDim( 1+NL/16 , 1+NL/16);
  plps_gradient LLL gridDim , blockDim RRR (sx, sy, NL, d,
					    d__turbulence, wavelength, r0,
				   zeta1, eta1, zeta2, eta2,
				   src, time);
}
<<phase screen gradient II>>=
void atmosphere::get_phase_screen_gradient(centroiding *cog, int NL, float const d, source *src, float time)
{
  dim3 blockDim(16,16);
  dim3 gridDim( 1+NL/16 , 1+NL/16);
  plps_gradient LLL gridDim , blockDim RRR (cog->d__cx, cog->d__cy, NL, d,
					    d__turbulence, wavelength, r0,
				   zeta1, eta1, zeta2, eta2,
				   src->dev_ptr, time);
}
<<phase screen gradient III>>=
void atmosphere::get_phase_screen_gradient(centroiding *cog, int NL, float const d, source *src, int N_SRC, float time)
{
  dim3 blockDim(16,16);
  dim3 gridDim( 1+NL/16 , 1+NL/16, N_SRC);
  plps_gradient LLL gridDim , blockDim RRR (cog->d__cx, cog->d__cy, NL, d,
					    d__turbulence, wavelength, r0,
				            zeta1, eta1, zeta2, eta2,
				            src->dev_ptr, time);
}
@ with the kernel
<<phase screen gradient kernel>>=
__global__ void plps_gradient(float *sx, float *sy, int NL, float const d,
			      profile *turb, float wavelength, float r0,
			      float *zeta1, float *eta1, float *zeta2, float *eta2,
			      source *src, float time)
{
  <<declarations (common)>>
    float sum_x, sum_l_x, sum_y, sum_l_y, red0, red1, red2;

  <<thread to lenslet coordinate>>
  
  sum_x = sum_y = 0;
  if ( (i<NL) && (j<NL) )
    {

      <<variables>>

      for (i=0;i<turb->N_k;i++)
	{
	  <<frequency magnitude sum>>
          for (j=0;j<turb->N_a;j++)
	    {
	      <<frequency angle sum (common)>>
		cos_freq_ang *= freq_mag;
		sin_freq_ang *= freq_mag;
		sum_l_x = sum_l_y = 0;
	      for (l=0;l<_N_LAYER_;l++)
		{
		  <<layer sum (gradient)>>
		}
	      sum_x += sqrt_spectrum_kernel*sum_l_x;
	      sum_y += sqrt_spectrum_kernel*sum_l_y;
	    }
	}
      red0 = 1.4*powf(r0,-5.0/6.0)*wavelength/(2*PI);
      sx[kl] = red0*sum_x;
      sy[kl] = red0*sum_y;
    }
}
@ 
A mask identifying the valid lenslet can also be passed to the routine:
<<phase screen gradient (masked)>>=
void atmosphere::get_phase_screen_gradient(float *sx, float *sy, int NL, char *valid_lenslet,
					   float const d, source *src, float time)
{
  dim3 blockDim(16,16);
  dim3 gridDim( 1+NL/16 , 1+NL/16);
  plps_gradient_mask LLL gridDim , blockDim RRR (sx, sy, NL, valid_lenslet, d,
					    d__turbulence, wavelength, r0,
				   zeta1, eta1, zeta2, eta2,
				   src, time);
}
@ with the kernel
<<phase screen gradient kernel (masked)>>=
__global__ void plps_gradient_mask(float *sx, float *sy, int NL, char *valid_lenslet, float const d,
				     profile *turb, float wavelength, float r0,
				     float *zeta1, float *eta1, float *zeta2, float *eta2,
				     source *src, float time)
{
  <<declarations (common)>>
    float sum_x, sum_l_x, sum_y, sum_l_y, red0, red1, red2;

  <<thread to lenslet coordinate>>
  
      sum_x = sum_y = 0;
  if ( (i<NL) && (j<NL) )
    {
      <<variables>>
	if (valid_lenslet[kl]>0) 
	  {

	    for (i=0;i<turb->N_k;i++)
	      {
		<<frequency magnitude sum>>
		  for (j=0;j<turb->N_a;j++)
		    {
		      <<frequency angle sum (common)>>
			cos_freq_ang *= freq_mag;
		      sin_freq_ang *= freq_mag;
		      sum_l_x = sum_l_y = 0;
		      for (l=0;l<_N_LAYER_;l++)
			{
			  <<layer sum (gradient)>>
			    }
		      sum_x += sqrt_spectrum_kernel*sum_l_x;
		      sum_y += sqrt_spectrum_kernel*sum_l_y;
		    }
	      }
	    red0 = 1.4*powf(r0,-5.0/6.0)*wavelength/(2*PI);
	    sx[kl] = red0*sum_x;
	    sy[kl] = red0*sum_y;
	  } else {
	  sx[kl] = 0.0;
	  sy[kl] = 0.0;
	}
    }
}
@
Each thread is computing one value of the phase screen gradient at the coordinate [[x_kl = (i+1/2)*d]] and [[y_kl = (j+1/2)*delta_y]]
<<thread to lenslet coordinate>>=
i = blockIdx.x * blockDim.x + threadIdx.x;
j = blockIdx.y * blockDim.y + threadIdx.y;
i_source = blockIdx.z;
kl = i * NL + j + 2*i_source*NL*NL;
x_kl0 = (i+0.5)*d - NL*d*0.5;
y_kl0 = (j+0.5)*d - NL*d*0.5;
@ 
The innest loop is the sum over the layer.
<<layer sum (gradient)>>=
  ijl = ij + l*turb->N_a*turb->N_k;
gl = 1 - turb->altitude[l]/src[i_source].height;
x_kl = x_kl0 - turb->vx[l]*time;
y_kl = y_kl0 - turb->vy[l]*time;
x_kl = gl*x_kl + turb->altitude[l]*src[i_source].theta_x;
y_kl = gl*y_kl + turb->altitude[l]*src[i_source].theta_y;
red0 = sqrt(turb->xi0[l])*
  sinc_atm(0.5*gl*cos_freq_ang*d)*sinc_atm(0.5*gl*sin_freq_ang*d);
red1 = zeta1[ijl]*sin( eta1[ijl] + cos_freq_ang*x_kl + sin_freq_ang*y_kl );
red2 = zeta2[ijl]*sin( eta2[ijl] - sin_freq_ang*x_kl + cos_freq_ang*y_kl );
sum_l_x += red0*( red1*cos_freq_ang - red2*sin_freq_ang);
sum_l_y += red0*( red1*sin_freq_ang + red2*cos_freq_ang);
<<sinc (atm)>>=
__device__ float sinc_atm(float x) {
  return (x==0) ? 1.0 : sin(x) / (x) ; 
}
@ 
\subsection{Tests}
\label{sec:tests}

The test suite is a Matlab script.
It calls the mex function:
<<atmosphere.mex>>=
<<atmosphere phase gradient>>
@ 
<<atmosphere phase>>=
#include <math.h>
#include <cuda_runtime.h>
#include "cublas_v2.h"
#include "mex.h"
#include "gpu/mxGPUArray.h"

#include "definitions.h"

#ifndef __CEO_H__
#include "ceo.h"
#endif
#ifndef __SOURCE_H__
#include "source.h"
#endif
#ifndef __ATMOSPHERE_H__
#include "atmosphere.h"
#endif

static source src, *d__src;
static atmosphere atm;
static unsigned int INIT=0;
static void cleanup(void)
{
    atm.cleanup();
    INIT = 0;
}
void mexFunction(int nlhs, mxArray *plhs[],
        int nrhs, mxArray const *prhs[])
{
    unsigned int inputIndex;
    float const *d__x, *d__y;
    float *d__phase_screen;
    double *reset, *L0, *time;
    
    char const * const errId = "parallel:gpu:CEO_SCAO_MEX:InvalidInput";
    char const * const errMsg = "Invalid input to MEX file.";
    
    /* Check for proper number of input and output arguments */
    if (nrhs != 5) {
        mexErrMsgIdAndTxt( "MATLAB:mxislogical:invalidNumInputs",
                "Five input argument required.");
    }
    if(nlhs > 1){
        mexErrMsgIdAndTxt( "MATLAB:mxislogical:maxlhs",
                "Too many output arguments.");
    }

    inputIndex = 0;
    
    /* Create GPUArray from mxArray input and get underlying pointer. */
    mxGPUArray const *x;
    x = mxGPUCreateFromMxArray(prhs[inputIndex++]);
    if (mxGPUGetClassID(x) != mxSINGLE_CLASS) {
        mexErrMsgIdAndTxt(errId, errMsg);
    }
    d__x = (float const *)(mxGPUGetDataReadOnly(x));
    // ---------------------------------------
    mxGPUArray const *y;
    y = mxGPUCreateFromMxArray(prhs[inputIndex++]);
    if (mxGPUGetClassID(y) != mxSINGLE_CLASS) {
        mexErrMsgIdAndTxt(errId, errMsg);
    }
    d__y = (float const *)(mxGPUGetDataReadOnly(y));
    // ---------------------------------------
    reset = mxGetPr(prhs[inputIndex++]);
    L0 = mxGetPr(prhs[inputIndex++]);
    time = mxGetPr(prhs[inputIndex++]);

    /* Create GPUArray to hold the result and get underlying pointer. */
    mxGPUArray *phase_screen;
    phase_screen = mxGPUCreateGPUArray(2,mxGPUGetDimensions(x),
            mxSINGLE_CLASS,mxREAL,MX_GPU_INITIALIZE_VALUES);
    d__phase_screen = (float *)(mxGPUGetData(phase_screen));
    
    if (INIT==0) {
        // Source
        src.setup(ARCSEC(60) , 0, 90e3);//INFINITY);
	HANDLE_ERROR( cudaMalloc( (void**)&d__src, sizeof(source)*_N_SOURCE_ ) );
	HANDLE_ERROR( cudaMemcpy( d__src, &src,
				  sizeof(source)*_N_SOURCE_ ,
				  cudaMemcpyHostToDevice ) );
       
        // Single layer turbulence profile
        float altitude[] = {0},
              xi0[] = {1},
              wind_speed[] = {10},
              wind_direction[] = {0};
	      /*
        // GMT 7 layers turbulence profile
        float altitude[] = {25, 275, 425, 1250, 4000, 8000, 13000},
              xi0[] = {0.1257, 0.0874, 0.0666, 0.3498, 0.2273, 0.0681, 0.0751},
              wind_speed[] = {5.6540, 5.7964, 5.8942, 6.6370, 13.2925, 34.8250, 29.4187},
              wind_direction[] = {0.0136, 0.1441, 0.2177, 0.5672, 1.2584, 1.6266, 1.7462};
	      */

        // Atmosphere
        atm.setup(0.15,(float) (*L0),altitude,xi0,wind_speed,wind_direction);
        mexAtExit(cleanup);
        INIT = 1;
    }
    
   if (*reset>0) { atm.reset(); }
    
   atm.get_phase_screen(d__phase_screen,d__x,d__y,_N_PIXEL_,d__src,(float)(*time));
    
    /* Wrap the result up as a MATLAB gpuArray for return. */
    plhs[0] = mxGPUCreateMxArrayOnGPU(phase_screen);
    
//   atm.cleanup();
    mxGPUDestroyGPUArray(x);
    mxGPUDestroyGPUArray(y);
    mxGPUDestroyGPUArray(phase_screen);
}
@ 
<<atmosphere phase gradient>>=
#include <math.h>
#include <cuda_runtime.h>
#include "cublas_v2.h"
#include "mex.h"
#include "gpu/mxGPUArray.h"

#include "definitions.h"

#ifndef __CEO_H__
#include "ceo.h"
#endif
#ifndef __SOURCE_H__
#include "source.h"
#endif
#ifndef __ATMOSPHERE_H__
#include "atmosphere.h"
#endif

static source src, *d__src;
static atmosphere atm;
static unsigned int INIT=0;
static void cleanup(void)
{
    atm.cleanup();
    INIT = 0;
}
void mexFunction(int nlhs, mxArray *plhs[],
        int nrhs, mxArray const *prhs[])
{
    unsigned int inputIndex;
    float *d__s;
    double *pitch, *reset, *L0, *time;
    
    //    char const * const errId = "parallel:gpu:CEO_SCAO_MEX:InvalidInput";
    //    char const * const errMsg = "Invalid input to MEX file.";
    
    /* Check for proper number of input and output arguments */
    if (nrhs != 4) {
        mexErrMsgIdAndTxt( "MATLAB:mxislogical:invalidNumInputs",
                "Five input argument required.");
    }
    if(nlhs > 1){
        mexErrMsgIdAndTxt( "MATLAB:mxislogical:maxlhs",
                "Too many output arguments.");
    }

    inputIndex = 0;
    
    /* Create GPUArray from mxArray input and get underlying pointer. */
    pitch = mxGetPr(prhs[inputIndex++]);
    reset = mxGetPr(prhs[inputIndex++]);
    L0 = mxGetPr(prhs[inputIndex++]);
    time = mxGetPr(prhs[inputIndex++]);

    /* Create GPUArray to hold the result and get underlying pointer. */
    mxGPUArray *s;
    mwSize dims[2];
    dims[0] = _N_LENSLET_*2;
    dims[1] = 1;
    s = mxGPUCreateGPUArray(2,dims,
            mxSINGLE_CLASS,mxREAL,MX_GPU_INITIALIZE_VALUES);
    d__s = (float *)(mxGPUGetData(s));
    
    if (INIT==0) {
        // Source
      src.setup(ARCSEC(0) , 0, 20e3);//INFINITY);
	HANDLE_ERROR( cudaMalloc( (void**)&d__src, sizeof(source)*_N_SOURCE_ ) );
	HANDLE_ERROR( cudaMemcpy( d__src, &src,
				  sizeof(source)*_N_SOURCE_ ,
				  cudaMemcpyHostToDevice ) );
       
        // Single layer turbulence profile
	/*
        float altitude[] = {10e3},
	  xi0[] = {1},
	    wind_speed[] = {2},
              wind_direction[] = {0};
	*/
	/*
        float altitude[] = {0,5000,15000},
	  xi0[] = {0.33,0.33,0.33},
	    wind_speed[] = {2,5.6569,6.3246},
              wind_direction[] = {0,2.3562,-1.8925};
	*/
        // GMT 7 layers turbulence profile
        float altitude[] = {25, 275, 425, 1250, 4000, 8000, 13000},
              xi0[] = {0.1257, 0.0874, 0.0666, 0.3498, 0.2273, 0.0681, 0.0751},
              wind_speed[] = {5.6540, 5.7964, 5.8942, 6.6370, 13.2925, 34.8250, 29.4187},
              wind_direction[] = {0.0136, 0.1441, 0.2177, 0.5672, 1.2584, 1.6266, 1.7462};

        // Atmosphere
        atm.setup(0.15,(float) (*L0),altitude,xi0,wind_speed,wind_direction);
        mexAtExit(cleanup);
        INIT = 1;
    }
    
   if (*reset>0) { atm.reset(); }
    
   atm.get_phase_screen_gradient(d__s,d__s+_N_LENSLET_,N_SIDE_LENSLET,
				 (float)(*pitch),d__src,(float)(*time));
    
    /* Wrap the result up as a MATLAB gpuArray for return. */
    plhs[0] = mxGPUCreateMxArrayOnGPU(s);
    
//   atm.cleanup();
    mxGPUDestroyGPUArray(s);
}
@
The Matlab test suite:
<<atmosphereTest.m>>=
%% 
% gpuDevice([])

 r0 = 15e-2;
 L0 = 30;
 atm = atmosphere(photometry.V,r0,L0,'windSpeed',10,'windDirection',0);
%  atm = atmosphere(photometry.V,r0,L0,...
%      'altitude',[0, 500, 1000, 2000, 5000, 8000. 13000],...
%      'fractionnalR0',[0.2, 0.1, 0.1, 0.3, 0.2, 0.05, 0.05],...
%      'windSpeed',[10, 5, 7.5, 5, 10, 12, 15],...
%      'windDirection',[0, 0.25, 0.5, 1, 1.5, 1.75, 2]);
% atm = gmtAtmosphere(1);
% r0 = atm.r0;
% L0 = atm.L0;

nxy = 512;
ceodir = '~/CEO';
cd(ceodir)
unix(['sed -i ',...
    '-e ''s/#define _N_LAYER_ [0-9]*/#define _N_LAYER_ ',num2str(atm.nLayer),'/g'' ',...
    '-e ''s/#define _N_PIXEL_ [0-9]*/#define _N_PIXEL_ ',...
    num2str(nxy^2),'/g'' include/definitions.h']);
unix('cat include/definitions.h');
unix('make clean lib atmosphere.mex')
cd([ceodir,'/test'])
clear ceo_atmosphere
mex -largeArrayDims -I../include -L../lib -lceo -o ceo_atmosphere atmosphere.mex.cu

u = single( L0*gpuArray.linspace(-1,1,nxy) );
[x,y] = meshgrid( u );
phs = ceo_atmosphere(x,y,0,L0,0);
figure(1)
imagesc(u,u,phs)
axis square
colorbar

%% Variance test
fprintf('__ Variance Test __\n')
clear x y ceo_atmosphere
cd(ceodir)
unix(['sed -i ',...
    '-e ''s/#define _N_LAYER_ [0-9]*/#define _N_LAYER_ ',num2str(atm.nLayer),'/g'' ',...
    '-e ''s/#define _N_PIXEL_ [0-9]*/#define _N_PIXEL_ 1/g'' include/definitions.h']);
unix('cat include/definitions.h');
unix('make clean lib atmosphere.mex')
cd([ceodir,'/test'])
clear ceo_atmosphere
mex -largeArrayDims -I../include -L../lib -lceo -o ceo_atmosphere atmosphere.mex.cu
tic
nxy = 1000;
x   = gpuArray.rand(1,nxy,'single');
y   = gpuArray.rand(1,nxy,'single');
L = 100;
x = (2*x-1)*L/2;
y = (2*y-1)*L/2;
phs_var =  gpuArray.zeros(1,nxy,'single');
h = waitbar(0,'Variance Test');
for kxy = 1:nxy
    phs_var(kxy) =  ceo_atmosphere(x(kxy),y(kxy),1,L0,0);
    waitbar(kxy/nxy,h)
end
close(h)
fprintf(' . Theoretical variance: %8.2frd^2\n',phaseStats.variance(atm))
fprintf(' . Numerical variance:   %8.2frd^2\n',var(phs_var))
fprintf(' . Variance ratio: %6.5f\n',var(phs_var)/phaseStats.variance(atm))
toc
%% Structure function test I
fprintf('__ Structure Function Test I __\n')
n_sample = 1000;
clear ceo_atmosphere
cd(ceodir)
unix(['sed -i -e ''s/#define _N_PIXEL_ [0-9]*/#define _N_PIXEL_ ',...
    num2str(n_sample),'/g'' include/definitions.h']);
unix('cat include/definitions.h');
unix('make clean lib atmosphere.mex')
cd([ceodir,'/test'])
mex -largeArrayDims -I../include -L../lib -lceo -o ceo_atmosphere atmosphere.mex.cu
rho = 0:0.25:5;
rho(1) = 0.1;
nRho = length(rho);
mean_sf = zeros(1,nRho);
std_sf = zeros(1,nRho);
n_plps = 1000;
d_phs = gpuArray.zeros(n_plps,n_sample,'single');
hwb = waitbar(0,'Computing SF ...');
for kRho=1:nRho
    
    phi = gpuArray.rand(1,n_sample,'single')*2*pi;
    zRho = rho(kRho).*exp(1i*phi);
    zxy = (gpuArray.rand(1,n_sample,'single')*2-1)*0.5*L0 + ...
        1i*(gpuArray.rand(1,n_sample,'single')*2-1)*0.5*L0;
    zxy_rho = zxy + zRho;
    tic
    for k_plps = 1:n_plps
        
        phs_xy = ceo_atmosphere(real(zxy),imag(zxy),1,L0,0);
        phs_xy_rho =  ceo_atmosphere(real(zxy_rho),imag(zxy_rho),0,L0,0);
        d_phs(k_plps,:) = phs_xy - phs_xy_rho;
        
    end
    toc
    
    sf = var(d_phs);
    mean_sf(kRho) =  gather( mean(sf) );
    std_sf(kRho)  = gather( std(sf) );
    
    waitbar(kRho/nRho)
    
end
close(hwb)

figure(25)
heb = errorbar(rho,mean_sf, std_sf);
set(heb','Marker','o','MarkerSize',8,...
    'MarkerFaceColor','r','MarkerEdgeColor','k',...
    'Linewidth',2,'LineStyle','none')
hold all
plot(rho,phaseStats.structureFunction(rho,atm),'Linewidth',2)
hold off
grid
xlabel('Separation [m]')
ylabel('Structure function [rd^2]')

%% Structure function test II
fprintf('__ Structure Function Test II __\n')
L0_ = [1 5 25 300]; 
nL0 = length(L0_);

n_plps = 1000;

nxy = n_sample;
phs_xy = gpuArray.zeros(1,nxy,'single');
phs_xy_rho = gpuArray.zeros(1,nxy,'single');

d_phs = gpuArray.zeros(n_plps,n_sample,'single');

rho = logspace(-2,2,10)';
nRho = length(rho);
mean_sf = zeros(nRho,nL0);
std_sf = zeros(nRho,nL0);
th_sf = zeros(nRho,nL0);

for kL0 = 1:nL0
    
    L0 = L0_(kL0);
    atm.L0 = L0;
    clear ceo_atmosphere

    hwb = waitbar(0,sprintf('Computing SF for L0=%3.0fm ...',L0));
    for kRho=1:nRho
        
        phi = gpuArray.rand(1,n_sample,'single')*2*pi;
        zRho = rho(kRho).*exp(1i*phi);
        zxy = (gpuArray.rand(1,n_sample,'single')*2-1)*0.5*L0 + ...
            1i*(gpuArray.rand(1,n_sample,'single')*2-1)*0.5*L0;
        zxy_rho = zxy + zRho;
        
        tic
        for k_plps = 1:n_plps
            
            phs_xy = ceo_atmosphere(real(zxy),imag(zxy),1,L0,0);
            phs_xy_rho =  ceo_atmosphere(real(zxy_rho),imag(zxy_rho),0,L0,0);
            d_phs(k_plps,:) = phs_xy - phs_xy_rho;
            
        end
        toc
        
        sf = var(d_phs);
        mean_sf(kRho,kL0) =  gather( mean(sf) );
        std_sf(kRho,kL0)  = gather( std(sf) );
        
        waitbar(kRho/nRho)
        
    end
    close(hwb)
    
    th_sf(:,kL0) = phaseStats.structureFunction(rho,atm);
    
    figure(26)
    heb = errorbar(repmat(rho,1,kL0),mean_sf(:,1:kL0), std_sf(:,1:kL0));
    set(heb','Marker','o','MarkerSize',8,...
        'MarkerFaceColor','r','MarkerEdgeColor','k',...
        'Linewidth',2,'LineStyle','none','color','b')
    hold all
    plot(rho,th_sf(:,1:kL0),'color','k','Linewidth',2)
    hold off
    grid
    xlabel('Separation [m]')
    ylabel('Structure function [rd^2]')
    set(gca,'xscale','log','yscale','log')  
    drawnow
end
for kL0=1:nL0
    text(rho(end),mean_sf(end,kL0)*.7,sprintf('L0=%3.0fm',L0_(kL0)),...
        'VerticalAlignment','top','BackgroundColor','w')
end

%% Zernike test
fprintf('__ Zernike Test __\n')

L0 = 30;
atm.L0 = L0;
nxy = 128;
clear ceo_atmosphere
cd(ceodir)
unix(['sed -i ',...
    '-e ''s/#define _N_LAYER_ [0-9]*/#define _N_LAYER_ ',num2str(atm.nLayer),'/g'' ',...
    '-e ''s/#define _N_PIXEL_ [0-9]*/#define _N_PIXEL_ ',...
    num2str(nxy^2),'/g'' include/definitions.h']);
unix('cat include/definitions.h');
unix('make clean lib atmosphere.mex')
cd([ceodir,'/test'])
mex -largeArrayDims -I../include -L../lib -lceo -o ceo_atmosphere atmosphere.mex.cu

u = 12.5*single(gpuArray.linspace(-1,1,nxy));
[x,y] = meshgrid(u);

ngs = source('zenith',0,'azimuth',0,'height',90e3);
zern = zernike(1:66,25,'resolution',nxy);

nIt = 4000;
zernCoefs = gpuArray.zeros(zern.nMode,nIt,'single');
h = waitbar(0,'Zernike Test !');
for kTau=1:nIt
    phs = ceo_atmosphere(x,y,1,L0,0);
    zern = zern.\phs;
    zernCoefs(:,kTau) = zern.c;
    waitbar(kTau/nIt,h)
end
close(h)
figure(29)
h = semilogy(zern.j,var(zernCoefs,0,2),'ko',...
    zern.j,zernikeStats.variance(zern,atm,ngs),'.-',...
    zern.j,zernikeStats.variance(zern,atm),'ko--');
set(h(1),'MarkerFaceColor','r')
grid
xlabel('Zernike mode')
ylabel('Zernike coef. variance [rd^2]')

%for kTau=1:nTau;phs = ceo_atmosphere(x,y,0,L0,(kTau-1)*tau);imagesc(phs);axis square;colorbar;drawnow;end

%% Taylor (frozen flow) hypothesis test
fprintf('__ Taylor (frozen flow) Hypothesis Test __\n')

tic
phs = ceo_atmosphere(x,y,0,L0,0);
toc

figure(27)
imagesc(u,u,phs)
axis square
colorbar

nIt = 1000;
tau = 1/10;
duration = 5;
nTau = duration/tau;
wind = 10;%.*exp(1i*pi/3);
% wind = 10.*exp(1i*sin(2*pi*(0:nIt-1)*tau*1));

zern = zernike(1:22,25,'resolution',nxy);
zernCoefs = gpuArray.zeros(zern.nMode,nTau,nIt,'single');

h = waitbar(0,'Taylor (frozen flow) hypothesis test!');
for kIt=1:nIt
    
    phs = ceo_atmosphere(x,y,1,L0,0);
    
    for kTau=1:nTau
        phs = ceo_atmosphere(x,y,0,L0,(kTau-1)*tau);
        zern = zern.\phs;
        zernCoefs(:,kTau,kIt) = zern.c;
        %     set(h,'Cdata',h_phs)
        %     drawnow
    end
    
    waitbar(kIt/nIt,h)
    
end
close(h)

tau_ = (0:nTau-1)*tau;
ngs = source;
zcov = zeros(zern.nMode,zern.nMode,nTau);
if matlabpool('size')==0
    matlabpool open
end
tic
parfor kTau=1:nTau
    zcov(:,:,kTau) = ...
        zernikeStats.temporalAngularCovariance(zern,atm,tau_(kTau),ngs,ngs);
end
toc
zcov_diag =cell2mat( ...
    arrayfun( @(x) squeeze( zcov(x,x,:) ) , 1:22, 'UniformOutput', false) );
figure(30)
h_th = plot(tau_,zcov_diag(:,2:8),'LineWidth',2);
grid
xlabel('Time [s]')
ylabel('Zernike coef. covariance [rd^2]')
legend(num2str((2:8)'),0)
hold off

C = mean( bsxfun( @times , zernCoefs(:,1,:) , zernCoefs ) , 3);
hold all
h_num = plot(tau_,C(2:8,:)','.','MarkerSize',15);
hold off
@ 
<<atmosphere.bin>>=
#ifndef __CEO_H__
#include "ceo.h"
#endif
#ifndef __SOURCE_H__
#include "source.h"
#endif
#ifndef __ATMOSPHERE_H__
#include "atmosphere.h"
#endif
#ifndef __IMAGING_H__
#include "imaging.h"
#endif
#ifndef __CENTROIDING_H__
#include "centroiding.h"
#endif
#ifndef __AASTATS_H__
#include "aaStats.h"
#endif
#ifndef __BTBT_H__
#include "BTBT.h"
#endif
#include "iterativeSolvers.h"

int main( void) {

atmosphere atm;
imaging lenslet_array;
centroiding cog;

float slopes2Angle, d, cxy0;
int N = _N_LENSLET_*2;

// Single layer turbulence profile
float altitude[] = {0},
  xi0[] = {1},
  wind_speed[] = {10},
  wind_direction[] = {0};
d = 1;
atm.setup(d,30,altitude,xi0,wind_speed,wind_direction);
//atm.reset();
slopes2Angle = (atm.wavelength/2/d);

source src, *d__src;
src.setup(ARCSEC(0) , 0, INFINITY);
HANDLE_ERROR( cudaMalloc( (void**)&d__src, sizeof(source)*_N_SOURCE_ ) );
HANDLE_ERROR( cudaMemcpy( d__src, &src,
			  sizeof(source)*_N_SOURCE_ ,
			  cudaMemcpyHostToDevice ) );

// SH WFS
lenslet_array.setup();

// Centroid
cog.setup();

float phase_screen[_N_PIXEL_];
float delta, delta_e;
int PS_N_PX, PS_E_N_PX, NP;
FILE *fid;
float *phase_screen_low_res, *d__phase_screen_low_res, *b;

PS_N_PX = _N_PX_PUPIL_*N_SIDE_LENSLET;
PS_E_N_PX = PS_N_PX*PS_N_PX;
NP = PS_N_PX;

delta=d/16.;
atm.get_phase_screen(delta,PS_N_PX,delta,PS_N_PX,d__src,0);

HANDLE_ERROR( cudaMemcpy( phase_screen,d__src->phase,
			  sizeof(float)*PS_E_N_PX,
			  cudaMemcpyDeviceToHost ) );
fid = fopen("phaseScreen.bin","wb");
fwrite(phase_screen,sizeof(float),PS_E_N_PX,fid);
fclose(fid);

PS_N_PX = 9;
PS_E_N_PX = PS_N_PX*PS_N_PX;
NP = PS_N_PX;

HANDLE_ERROR( cudaMalloc( (void**)&d__phase_screen_low_res, sizeof(float)*PS_E_N_PX ) );

delta_e = d/2;
atm.get_phase_screen(d__phase_screen_low_res,delta_e,NP,delta_e,NP,d__src,0);

phase_screen_low_res = (float*)malloc(sizeof(float)*PS_E_N_PX);
HANDLE_ERROR( cudaMemcpy( phase_screen_low_res, d__phase_screen_low_res,
			  sizeof(float)*PS_E_N_PX,
			  cudaMemcpyDeviceToHost ) );
fid = fopen("phaseScreenLowRes.bin","wb");
fwrite(phase_screen_low_res,sizeof(float),PS_E_N_PX,fid);
fclose(fid);

lenslet_array.propagate(d__src);
cxy0 = (_N_PX_PUPIL_ - 1)/2.0;
cog.get_data(lenslet_array.d__frame, cxy0, cxy0, slopes2Angle);
b = (float *)malloc(sizeof(float)*N);
HANDLE_ERROR( cudaMemcpy( b, cog.d__c,
			  sizeof(float)*N,
			  cudaMemcpyDeviceToHost ) );
printf("\n   Cx       Cy\n");
for (int k=0;k<_N_LENSLET_;k++) {
  printf("%+6.4E  %+6.4E\n",b[k],b[k+_N_LENSLET_]);
}

atm.get_phase_screen_gradient(cog.d__cx, cog.d__cy, _N_LENSLET_, d, d__src, 0);
HANDLE_ERROR( cudaMemcpy( b, cog.d__c,
			  sizeof(float)*N,
			  cudaMemcpyDeviceToHost ) );
printf("\n   Cx       Cy\n");
for (int k=0;k<_N_LENSLET_;k++) {
  printf("%+6.4E  %+6.4E\n",b[k],b[k+_N_LENSLET_]);
}

atm.cleanup();
lenslet_array.cleanup();
cog.cleanup();

HANDLE_ERROR( cudaFree( d__src) );
HANDLE_ERROR( cudaFree( d__phase_screen_low_res ) );
free(phase_screen_low_res);
}
