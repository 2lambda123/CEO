% -*- mode: Noweb; noweb-code-mode: c-mode -*-

\def\bk{\bar \kappa_i}
\def\dk{\Delta \kappa_i}
\def\dphi{\Delta \varphi}
\def\nk{N_\kappa}
\def\na{N_\varphi}

The atmosphere structure is written:
<<atmosphere.h>>=
#ifndef __ATMOSPHERE_H__
#define __ATMOSPHERE_H__

#ifndef __CEO_H__
#include "ceo.h"
#endif

#ifndef __SOURCE_H__
#include "source.h"
#endif

#define RAND_SEED 2013

struct profile {

  <<profile parameters>>

  void setup(float *altitude, float *xi0,
	     float *wind_speed, float *wind_direction);

};

struct atmosphere {

  <<atmosphere parameters>>

  void setup(float r0_, float L0, 
	     float *altitude, float *xi0,
	     float *wind_speed, float *wind_direction);

  void cleanup(void);

  void info(void);

  void reset(void);

  void get_phase_screen(float *phase_screen,
			float const *x, float const *y, int N_xy, 
			source *src, float time);

  void get_phase_screen(float const *x, float const *y, int N_xy, 
			source *src, float time);

  void get_phase_screen(float const delta_x, int N_x, float const delta_y, int N_y, 
			source *src, float time);

};

#endif // __ATMOSPHERE_H__
@ with the source file:
<<atmosphere.cu>>=
#include "atmosphere.h"

<<init random variates>>

<<variates>>

<<new variates>>

<<phase screen kernel>>

<<phase screen kernel (square)>>

<<profile setup>>

<<atmosphere setup>>

<<cleanup>>

<<info>>

<<phase screen I>>

<<phase screen II>>

<<phase screen III>>
@
The atmosphere parameters are
\begin{itemize}
\item the Fried parameter $r_0$ are a given photometric band
<<atmosphere parameters>>=
char *photometric_band;
float wavelength, r0;
@ \item the outer scale
<<profile parameters>>=
float  L0;      
@ \item the turbulence layers altitude
<<profile parameters>>=
float altitude[_N_LAYER_],
@ \item the fractional $r_0$ vector: $$\xi_0(h)= \left( r_0(h)\over r_0 \right)^{-5/3}$$
<<profile parameters>>=
      xi0[_N_LAYER_],
@ \item the wind vector
<<profile parameters>>=
  wind_speed[_N_LAYER_], wind_direction[_N_LAYER_];

@ \end{itemize}
The main parameters of the atmosphere are displayed with the [[info]] routine:
<<info>>=
void atmosphere::info(void)
{
printf("\n\x1B[1;42m@(CEO)>atmosphere: Von Karman atmospheric turbulence model\x1B[;42m\n");
printf(" . r0 = %5.2fcm\n . L0 = %5.2fm\n",r0*1e2,turbulence.L0);
printf("----------------------------------------------------\n");
printf("  Layer   Altitude[m]   fr0    wind([m/s] [deg])\n");
for (int kLayer=0;kLayer<_N_LAYER_;kLayer++) {
  printf("  %2d      %8.2f      %4.2f    (%5.2f %6.2f)\n",
  kLayer,
  turbulence.altitude[kLayer],
  turbulence.xi0[kLayer],
  turbulence.wind_speed[kLayer],
  turbulence.wind_direction[kLayer]*180/PI);
}
printf("----------------------------------------------------\x1B[0m\n");
}
@ 
Specifics turbulence profile are pre--defined as:
<<GMT median turbulence profile>>=
float  L, l0, L, f, delta, N_k, N_a, kmin0;      
float altitude[_N_LAYER_] = {25, 275, 425, 1250, 4000, 8000, 13000},
  xi0[_N_LAYER_] = {0.1257, 0.0874, 0.0666, 0.3498, 0.2273, 0.0681, 0.0751},
  wind_speed[_N_LAYER_] = {5.6540, 5.7964, 5.8942, 6.6370, 13.2925, 34.8250, 29.4187},
  wind_direction[_N_LAYER_] = {0.0136, 0.1441, 0.2177, 0.5672, 1.2584, 1.6266, 1.7462};
float vx[_N_LAYER_], vy[_N_LAYER_];
@
The phase screen equation is 
\begin{eqnarray}
  \label{eq:1}
  \phi(x,y) &=& 1.4 r_0^{-{5\over6}}\sum_{i=1}^{N_\kappa}\sum_{j=1}^{N_\varphi} \Gamma\left( \bk\right) \\
&& \times \left\{ \zeta_1(i,j) cos\left[ \eta_1(i,j) + \bk \left( x\cos \phi_j + y\sin \phi_j \right) \right] \right. \nonumber\\
&& \quad + \left. \zeta_2(i,j) cos\left[ \eta_2(i,j) - \bk \left( x\sin \phi_j - y\cos \phi_j \right) \right] \right\} \nonumber
\end{eqnarray}
where 
\begin{equation}
  \label{eq:2}
  \Gamma\left( \bk\right) = \left[ \Lambda(\bk) \bk \dk \dphi \right]^{1\over2}
\end{equation}
$\Lambda\left( \bk\right)$ is the spectrum kernel at the spatial frequency $\bk$, given by
\begin{equation}
  \label{eq:3}
  \Lambda\left( \bk\right) = \left( \bk^2 + \kappa_0^2 \right)^{-{11\over6}}
\end{equation}
with $\kappa_0=2\pi/\mathcal L_0$, where $\mathcal L_0$ is the outer scale.

Eq.~(\ref{eq:1}) is defined over a frequency range f, $$f={\kappa_{max}\over \kappa_{min}}$$ and for a frequency resolution $\delta$, $$\delta={\dk\over\bk}.$$
$\bk$ and $\varphi_j$ are the magnitude and angle of the spatial frequency vector.
$\bk$ is the average spatial frequency over a given interval $i$ and is written
\begin{equation}
  \label{eq:4}
  \bk = {\kappa_{min}\over 2}f^{i\over\nk}\left( 1 + f^{-{1\over\nk}} \right).
\end{equation}
The interval width is given by
\begin{equation}
  \label{eq:5}
  \dk = \kappa_{min}f^{i\over\nk}\left( 1 - f^{-{1\over\nk}} \right).
\end{equation}
$\varphi_j$ is derived from
\begin{equation}
  \label{eq:6}
  \varphi_j = \left( j -{1\over2} \right) \Delta\varphi
\end{equation}
with $\Delta\varphi=\delta$.

The number of frequency and angle samples are given by
\begin{equation}
  \label{eq:7}
  \nk = { \ln f \over \ln \left( 2+\delta \over 2-\delta \right) }
\end{equation}
and
\begin{equation}
  \label{eq:8}
  \na = {\pi\over4} \left( f^{1\over\nk}+1 \over f^{1\over\nk}-1 \right).
\end{equation}

The frequency range and resolution can also be derived from the $\nk$ and $\na$:
\begin{equation}
  \label{eq:9}
  f = \left( 4\na + \pi \over 4\na - \pi \right)^{\nk}
\end{equation}
and
\begin{equation}
  \label{eq:10}
  \delta = {\pi\over2\na}.
\end{equation}

$\zeta$ and $\eta$ are variates defined by
\begin{equation}
  \label{eq:11}
  \zeta = \left( -\ln\beta_1 \right)^{1\over2}
\end{equation}
and
\begin{equation}
  \label{eq:12}
  \eta = 2\pi\beta_2,
\end{equation}
where $\beta_1$ and $\beta_2$ are uniformly distributed variates.

Eq.~(\ref{eq:1}) gives the expression of a single phase screen sampled with the rays of a light source at infinity.
For an atmosphere made of several phase screens with a source at a finite distance, Eq.~(\ref{eq:1}) becomes:
\begin{eqnarray}
  \label{eq:13}
    \phi(x,y) &=& 1.4 r_0^{-{5\over6}} \sum_{i=1}^{N_\kappa}\sum_{j=1}^{N_\varphi} \Gamma\left( \bk\right) \sum_{l=1}^{[[_N_LAYER_]]} \xi_{0l}^{1\over2} \\
&& \times \left\{ \zeta_{1l}(i,j) cos\left[ \eta_{1l}(i,j) + \bk \left( x_l\cos \phi_j + y_l\sin \phi_j \right) \right] \right. \nonumber\\
&& \quad + \left. \zeta_{2l}(i,j) cos\left[ \eta_{2l}(i,j) - \bk \left( x_l\sin \phi_j - y_l\cos \phi_j \right) \right] \right\} \nonumber\\
x_l &=& \left( 1 - {h_l\over z_\ast} \right)(x-v_xt) + h_l\theta_{\ast x} \\
y_l &=& \left( 1 - {h_l\over z_\ast} \right)(y-v_yt) + h_l\theta_{\ast y} 
\end{eqnarray}

The above definitions call for the declarations of new variables:
<<profile parameters>>=
float l0, L, f, delta, N_k, N_a, kmin;
float vx[_N_LAYER_], vy[_N_LAYER_];
@ 
<<atmosphere parameters>>=
float *zeta1, *eta1, *zeta2, *eta2;
curandState *devStates;
profile turbulence, *d__turbulence;
@ This variables are defined in the setup routines:
<<atmosphere setup>>=
void atmosphere::setup(float r0_, float L0, 
		       float *altitude, float *xi0,
		       float *wind_speed, float *wind_direction) {
  wavelength = 550e-9;
  r0 = r0_;
  turbulence.L0 = L0;
  turbulence.setup(altitude, xi0,
		   wind_speed, wind_direction);
  info();
  HANDLE_ERROR( cudaMalloc( (void**)&d__turbulence, sizeof(profile) ) );
  HANDLE_ERROR( cudaMemcpy( d__turbulence, &turbulence,
			    sizeof(profile), cudaMemcpyHostToDevice ) );
  int nel = _N_LAYER_*turbulence.N_k*turbulence.N_a;
  printf("\n@(CEO)>atmosphere: initializing %d variates ...",nel);
  HANDLE_ERROR( cudaMalloc( (void**)&devStates, 4*nel*sizeof(curandState)) );  
  HANDLE_ERROR( cudaMalloc( (void**)&zeta1, nel*sizeof(float)) );
  HANDLE_ERROR( cudaMalloc( (void**)&eta1,  nel*sizeof(float)) );
  HANDLE_ERROR( cudaMalloc( (void**)&zeta2, nel*sizeof(float)) );
  HANDLE_ERROR( cudaMalloc( (void**)&eta2,  nel*sizeof(float)) );
  dim3 blockDim(64,1);
  dim3 gridDim( 1+4*nel/64 , 1 );
  setupRandomSequence LLL gridDim,blockDim RRR (devStates, 4*nel);
  HANDLE_ERROR( cudaDeviceSynchronize() );
  generateVariates LLL gridDim,blockDim RRR (zeta1, eta1, zeta2, eta2, devStates, nel);
  HANDLE_ERROR( cudaDeviceSynchronize() );
printf("done!\n");
}
@ 
<<profile setup>>=
void profile::setup(float *altitude_, float *xi0_,
		    float *wind_speed_, float *wind_direction_) {
  for (int k=0;k<_N_LAYER_;k++)
    {
      altitude[k] = altitude_[k];
      xi0[k]      = xi0_[k];
      wind_speed[k]     = wind_speed_[k];
      wind_direction[k] = wind_direction_[k];
      vx[k] = wind_speed[k]*cosf(wind_direction[k]);
      vy[k] = wind_speed[k]*sinf(wind_direction[k]);
    }
  l0    = 1e-3;
  L     = 1e2;
  f     = MAX(L,3*L0);
  kmin  = 2*PI/f;
  f     = f/l0;
  delta = 0.1; // TODO: like f, should depends on the input parameters
  N_k = logf(f)/log( (2+delta)/(2-delta) );
  N_a = powf( f , 1/N_k ) ;
  N_a = 0.25*PI*( (N_a + 1)/(N_a - 1) );
  N_k = ceilf( N_k );
  N_a = ceilf( N_a );
  f = powf( (4*N_a + PI)/(4*N_a - PI) , N_k );
  delta = 0.5*PI/N_a;
  printf("\n@(CEO)>profile:\n");
  printf(" . N_k = %f\n",N_k);
  printf(" . N_a = %f\n",N_a);
  printf(" . frequency range      = %8.2f\n",f);
  printf(" . frequency resolution = %6.4f\n",delta);
  printf(" . minimum frequency    = %6.4f\n",kmin);
}
@ 
The random generator is initialized within the following kernel:
<<init random variates>>=
__global__ void setupRandomSequence(curandState *state, int n_state) 
{
  int id;
  id = blockIdx.x * blockDim.x + threadIdx.x;
  if (id<n_state)
    curand_init(RAND_SEED, id, 0, &state[id]);  
}
@  and the variates are generated with:
<<variates>>=
__global__ void generateVariates(float *zeta1, float *eta1, float *zeta2, float *eta2, 
			    curandState *state, int n_state)
{
  int id;
  curandState localState;
  id = blockIdx.x * blockDim.x + threadIdx.x;
  if (id<n_state)
    {
      localState = state[id*4];
      zeta1[id] = curand_uniform(&localState);
      zeta1[id] = sqrtf( -logf( zeta1[id] ) );
      state[id*4] = localState;

      localState = state[id*4+1];
      eta1[id] = curand_uniform(&localState);
      eta1[id] = 2*PI*eta1[id];
      state[id*4+1] = localState;

      localState = state[id*4+2];
      zeta2[id] = curand_uniform(&localState);
      zeta2[id] = sqrtf( -logf( zeta2[id] ) );
      state[id*4+2] = localState;

      localState = state[id*4+3];
      eta2[id] = curand_uniform(&localState);
      eta2[id] = 2*PI*eta2[id];
      state[id*4+3] = localState;

    }
}
@ New variates can be computed with the call to the routine:
<<new variates>>=
void atmosphere::reset(void)
{
  int nel = _N_LAYER_*turbulence.N_k*turbulence.N_a;
  dim3 blockDim(64,1);
  dim3 gridDim( 1+nel/64 , 1 );
  generateVariates LLL gridDim,blockDim RRR (zeta1, eta1, zeta2, eta2, devStates, nel);
}
@ The dynamically allocated variables are freed in the cleanup routine:
<<cleanup>>=
void atmosphere::cleanup(void) {
  printf("\n@(CEO)>atmosphere: freeing memory!\n");
  HANDLE_ERROR( cudaFree( devStates ) );
  HANDLE_ERROR( cudaFree( zeta1  ));
  HANDLE_ERROR( cudaFree( eta1 ) );
  HANDLE_ERROR( cudaFree( zeta2 ) );
  HANDLE_ERROR( cudaFree( eta2 ) );
  HANDLE_ERROR( cudaFree( d__turbulence ) );
}
@
The phase screen are defined in the telescope pupil at the ground 
<<phase screen I>>=
void atmosphere::get_phase_screen(float *phase_screen,
		       float const *x, float const *y, int N_xy, 
		       source *src, float time)
{
  dim3 blockDim(16,16);
  dim3 gridDim( ceilf(sqrt(N_xy)/16) , ceilf(sqrt(N_xy)/16));
  plps LLL gridDim , blockDim RRR (phase_screen,
				   x, y, N_xy, 
				   d__turbulence, r0,
				   zeta1, eta1, zeta2, eta2,
				   src, time);
}
@ 
<<phase screen II>>=
void atmosphere::get_phase_screen(float const *x, float const *y, int N_xy, 
		       source *src, float time)
{
  dim3 blockDim(16,16);
  dim3 gridDim( ceilf(sqrt(N_xy)/16) , ceilf(sqrt(N_xy)/16));
  plps LLL gridDim , blockDim RRR (src->phase,
				   x, y, N_xy, 
				   d__turbulence, r0,
				   zeta1, eta1, zeta2, eta2,
				   src, time);
}
@ and computed with the kernel
<<phase screen kernel>>=
  __global__ void plps(float *phase_screen,
		       float const *x, float const *y, int N_xy, 
		       profile *turb, float r0,
		       float *zeta1, float *eta1, float *zeta2, float *eta2,
		       source *src, float time)
{
  <<declarations>>

  <<thread to coordinate index>>
  
  sum = 0;
  
  if (kl<N_xy)
    {

      <<variables>>

      for (i=0;i<turb->N_k;i++)
	{
	  <<frequency magnitude sum>>
          for (j=0;j<turb->N_a;j++)
	    {
	      <<frequency angle sum>>
	      for (l=0;l<_N_LAYER_;l++)
		{
		  <<layer sum>>
		}
	      sum += sqrt_spectrum_kernel*sum_l;
	    }
	}
      phase_screen[kl] = 1.4*powf(r0,-5.0/6.0)*sum;
    }
}
@ 
The kernel starts with some declarations:
<<declarations>>=
  int i, j, l, ij, ijl, kl;
float freq_mag0, delta_freq_mag0, f_red0, f_red, 
  freq_L0_square, x_kl, y_kl, x_kl0, y_kl0, gl,
  freq_mag, delta_freq_mag, sqrt_spectrum_kernel,
  freq_ang, cos_freq_ang, sin_freq_ang, sum, sum_l;
@ 
Each thread is computing one value of the phase screen at the coordinate [[x_kl = x[kl]]] and [[y_kl = y[kl]]]
<<thread to coordinate index>>=
i = blockIdx.x * blockDim.x + threadIdx.x;
j = blockIdx.y * blockDim.y + threadIdx.y;
kl = j * gridDim.x * blockDim.x + i;
x_kl0 = x[kl];
y_kl0 = y[kl];
@ 
Next a few new variables are defined, $$[[f_red0]]=f^{1/N_k},$$, $$[[freq_mag0]]=\kappa_{min}{[[f_red0]]+1)\over 2[[f_red0]]},$$ $$[[delta_freq_mag0]]=\kappa_{min}{[[f_red0]]-1)\over [[f_red0]]},$$ $$[[freq_L0_square]]=\left(2\pi\over\mathcal L_0\right)^2.$$
<<variables>>=
f_red0 = powf(turb->f,1/turb->N_k);
freq_mag0 = 0.5*turb->kmin*( f_red0 + 1 )/f_red0;
delta_freq_mag0 = turb->kmin*( f_red0 - 1 )/f_red0;
f_red  = 1;
freq_L0_square = 2*PI/turb->L0;
freq_L0_square *= freq_L0_square;
@ 
The outer loop is the sum over the frequency magnitude. It computes $\bk$, $\dk$ and $\Gamma\left( \bk\right)$:
<<frequency magnitude sum>>=
f_red *= f_red0;
freq_mag = freq_mag0*f_red;
delta_freq_mag = delta_freq_mag0*f_red;
sqrt_spectrum_kernel =
  powf( freq_mag*freq_mag + freq_L0_square, -11.0/12.0)*
  sqrt(freq_mag*delta_freq_mag*turb->delta);
@ 
The inner loop is the sum over the frequency angle. It computes $\varphi_j$, $\sin(\varphi_j)$ and $\cos(\varphi_j)$.
<<frequency angle sum>>=
 freq_ang = (j+0.5)*turb->delta;
 sincosf(freq_ang, &sin_freq_ang, &cos_freq_ang);
 ij = i*turb->N_a + j;
 sum_l = 0;
@ 
The innest loop is the sum over the layer.
<<layer sum>>=
  ijl = ij + l*turb->N_a*turb->N_k;
gl = 1 - turb->altitude[l]/src->height;
x_kl = x_kl0 - turb->vx[l]*time;
y_kl = y_kl0 - turb->vy[l]*time;
x_kl = gl*x_kl + turb->altitude[l]*src->theta_x;
y_kl = gl*y_kl + turb->altitude[l]*src->theta_y;
sum_l += sqrt(turb->xi0[l])*
   ( zeta1[ijl]*cosf( eta1[ijl] +
		     freq_mag*( x_kl*cos_freq_ang + y_kl*sin_freq_ang ) ) +
     zeta2[ijl]*cosf( eta2[ijl] -
		     freq_mag*( x_kl*sin_freq_ang - y_kl*cos_freq_ang ) ));
@ 
The next routine compute the phase screen on a square grid of size [[N_x]]$\times$[[N_y]]
<<phase screen III>>=
void atmosphere::get_phase_screen(float const delta_x, int N_x, float const delta_y, int N_y, 
		       source *src, float time)
{
  dim3 blockDim(16,16);
  dim3 gridDim( ceilf(N_x/16) , ceilf(N_y/16));
  square_plps LLL gridDim , blockDim RRR (src->phase,
				   delta_x, N_x, delta_y, N_y, 
				   d__turbulence, r0,
				   zeta1, eta1, zeta2, eta2,
				   src, time);
}
@ and computed with the kernel
<<phase screen kernel (square)>>=
  __global__ void square_plps(float *phase_screen,
		       float const delta_x, int N_x, float const delta_y, int N_y, 
		       profile *turb, float r0,
		       float *zeta1, float *eta1, float *zeta2, float *eta2,
		       source *src, float time)
{
  <<declarations>>

  <<thread to coordinate index (square)>>
  
  sum = 0;
  
  if ( (i<N_x) && (j<N_y) )
    {

      <<variables>>

      for (i=0;i<turb->N_k;i++)
	{
	  <<frequency magnitude sum>>
          for (j=0;j<turb->N_a;j++)
	    {
	      <<frequency angle sum>>
	      for (l=0;l<_N_LAYER_;l++)
		{
		  <<layer sum>>
		}
	      sum += sqrt_spectrum_kernel*sum_l;
	    }
	}
      phase_screen[kl] = 1.4*powf(r0,-5.0/6.0)*sum;
    }
}
@
Each thread is computing one value of the phase screen at the coordinate [[x_kl = i*delta_x]] and [[y_kl = j*delta_y]]
<<thread to coordinate index (square)>>=
i = blockIdx.x * blockDim.x + threadIdx.x;
j = blockIdx.y * blockDim.y + threadIdx.y;
kl = j * gridDim.x * blockDim.x + i;
x_kl0 = i*delta_x;
y_kl0 = j*delta_y;
@ 
The test suite is a Matlab script.
It calls the mex function:
<<atmosphere.mex>>=
#include <math.h>
#include <cuda_runtime.h>
#include "cublas_v2.h"
#include "mex.h"
#include "gpu/mxGPUArray.h"

#include "definitions.h"

#ifndef __CEO_H__
#include "ceo.h"
#endif
#ifndef __SOURCE_H__
#include "source.h"
#endif
#ifndef __ATMOSPHERE_H__
#include "atmosphere.h"
#endif

static source src, *d__src;
static atmosphere atm;
static unsigned int INIT=0;
static void cleanup(void)
{
    atm.cleanup();
    INIT = 0;
}
void mexFunction(int nlhs, mxArray *plhs[],
        int nrhs, mxArray const *prhs[])
{
    unsigned int inputIndex;
    float const *d__x, *d__y;
    float *d__phase_screen;
    double *reset, *L0, *time;
    
    char const * const errId = "parallel:gpu:CEO_SCAO_MEX:InvalidInput";
    char const * const errMsg = "Invalid input to MEX file.";
    
    /* Check for proper number of input and output arguments */
    if (nrhs != 5) {
        mexErrMsgIdAndTxt( "MATLAB:mxislogical:invalidNumInputs",
                "Five input argument required.");
    }
    if(nlhs > 1){
        mexErrMsgIdAndTxt( "MATLAB:mxislogical:maxlhs",
                "Too many output arguments.");
    }

    inputIndex = 0;
    
    /* Create GPUArray from mxArray input and get underlying pointer. */
    mxGPUArray const *x;
    x = mxGPUCreateFromMxArray(prhs[inputIndex++]);
    if (mxGPUGetClassID(x) != mxSINGLE_CLASS) {
        mexErrMsgIdAndTxt(errId, errMsg);
    }
    d__x = (float const *)(mxGPUGetDataReadOnly(x));
    // ---------------------------------------
    mxGPUArray const *y;
    y = mxGPUCreateFromMxArray(prhs[inputIndex++]);
    if (mxGPUGetClassID(y) != mxSINGLE_CLASS) {
        mexErrMsgIdAndTxt(errId, errMsg);
    }
    d__y = (float const *)(mxGPUGetDataReadOnly(y));
    // ---------------------------------------
    reset = mxGetPr(prhs[inputIndex++]);
    L0 = mxGetPr(prhs[inputIndex++]);
    time = mxGetPr(prhs[inputIndex++]);

    /* Create GPUArray to hold the result and get underlying pointer. */
    mxGPUArray *phase_screen;
    phase_screen = mxGPUCreateGPUArray(2,mxGPUGetDimensions(x),
            mxSINGLE_CLASS,mxREAL,MX_GPU_INITIALIZE_VALUES);
    d__phase_screen = (float *)(mxGPUGetData(phase_screen));
    
    if (INIT==0) {
        // Source
        src.setup(ARCSEC(60) , 0, INFINITY);
	HANDLE_ERROR( cudaMalloc( (void**)&d__src, sizeof(source)*_N_SOURCE_ ) );
	HANDLE_ERROR( cudaMemcpy( d__src, &src,
				  sizeof(source)*_N_SOURCE_ ,
				  cudaMemcpyHostToDevice ) );
       
        // Single layer turbulence profile
        float altitude[] = {0},
              xi0[] = {1},
              wind_speed[] = {10},
              wind_direction[] = {0};
	      /*
        // GMT 7 layers turbulence profile
        float altitude[] = {25, 275, 425, 1250, 4000, 8000, 13000},
              xi0[] = {0.1257, 0.0874, 0.0666, 0.3498, 0.2273, 0.0681, 0.0751},
              wind_speed[] = {5.6540, 5.7964, 5.8942, 6.6370, 13.2925, 34.8250, 29.4187},
              wind_direction[] = {0.0136, 0.1441, 0.2177, 0.5672, 1.2584, 1.6266, 1.7462};
	      */

        // Atmosphere
        atm.setup(0.15,(float) (*L0),altitude,xi0,wind_speed,wind_direction);
        mexAtExit(cleanup);
        INIT = 1;
    }
    
   if (*reset>0) { atm.reset(); }
    
   atm.get_phase_screen(d__phase_screen,d__x,d__y,_N_PIXEL_,d__src,(float)(*time));
    
    /* Wrap the result up as a MATLAB gpuArray for return. */
    plhs[0] = mxGPUCreateMxArrayOnGPU(phase_screen);
    
//   atm.cleanup();
    mxGPUDestroyGPUArray(x);
    mxGPUDestroyGPUArray(y);
    mxGPUDestroyGPUArray(phase_screen);
}
@ 
The Matlab test suite:
<<atmosphereTest.m>>=
%% 
% gpuDevice([])

 r0 = 15e-2;
 L0 = 30;
 atm = atmosphere(photometry.V,r0,L0,'windSpeed',10,'windDirection',0);
%  atm = atmosphere(photometry.V,r0,L0,...
%      'altitude',[0, 500, 1000, 2000, 5000, 8000. 13000],...
%      'fractionnalR0',[0.2, 0.1, 0.1, 0.3, 0.2, 0.05, 0.05],...
%      'windSpeed',[10, 5, 7.5, 5, 10, 12, 15],...
%      'windDirection',[0, 0.25, 0.5, 1, 1.5, 1.75, 2]);
% atm = gmtAtmosphere(1);
% r0 = atm.r0;
% L0 = atm.L0;

nxy = 512;
ceodir = '~/CEO';
cd(ceodir)
unix(['sed -i ',...
    '-e ''s/#define _N_LAYER_ [0-9]*/#define _N_LAYER_ ',num2str(atm.nLayer),'/g'' ',...
    '-e ''s/#define _N_PIXEL_ [0-9]*/#define _N_PIXEL_ ',...
    num2str(nxy^2),'/g'' include/definitions.h']);
unix('cat include/definitions.h');
unix('make clean lib atmosphere.mex')
cd([ceodir,'/test'])
clear ceo_atmosphere
mex -largeArrayDims -I../include -L../lib -lceo -o ceo_atmosphere atmosphere.mex.cu

u = single( L0*gpuArray.linspace(-1,1,nxy) );
[x,y] = meshgrid( u );
phs = ceo_atmosphere(x,y,0,L0,0);
figure(1)
imagesc(u,u,phs)
axis square
colorbar

%% Variance test
fprintf('__ Variance Test __\n')
clear x y ceo_atmosphere
cd(ceodir)
unix(['sed -i ',...
    '-e ''s/#define _N_LAYER_ [0-9]*/#define _N_LAYER_ ',num2str(atm.nLayer),'/g'' ',...
    '-e ''s/#define _N_PIXEL_ [0-9]*/#define _N_PIXEL_ 1/g'' include/definitions.h']);
unix('cat include/definitions.h');
unix('make clean lib atmosphere.mex')
cd([ceodir,'/test'])
clear ceo_atmosphere
mex -largeArrayDims -I../include -L../lib -lceo -o ceo_atmosphere atmosphere.mex.cu
tic
nxy = 1000;
x   = gpuArray.rand(1,nxy,'single');
y   = gpuArray.rand(1,nxy,'single');
L = 100;
x = (2*x-1)*L/2;
y = (2*y-1)*L/2;
phs_var =  gpuArray.zeros(1,nxy,'single');
h = waitbar(0,'Variance Test');
for kxy = 1:nxy
    phs_var(kxy) =  ceo_atmosphere(x(kxy),y(kxy),1,L0,0);
    waitbar(kxy/nxy,h)
end
close(h)
fprintf(' . Theoretical variance: %8.2frd^2\n',phaseStats.variance(atm))
fprintf(' . Numerical variance:   %8.2frd^2\n',var(phs_var))
fprintf(' . Variance ratio: %6.5f\n',var(phs_var)/phaseStats.variance(atm))
toc
%% Structure function test I
fprintf('__ Structure Function Test I __\n')
n_sample = 1000;
clear ceo_atmosphere
cd(ceodir)
unix(['sed -i -e ''s/#define _N_PIXEL_ [0-9]*/#define _N_PIXEL_ ',...
    num2str(n_sample),'/g'' include/definitions.h']);
unix('cat include/definitions.h');
unix('make clean lib atmosphere.mex')
cd([ceodir,'/test'])
mex -largeArrayDims -I../include -L../lib -lceo -o ceo_atmosphere atmosphere.mex.cu
rho = 0:0.25:5;
rho(1) = 0.1;
nRho = length(rho);
mean_sf = zeros(1,nRho);
std_sf = zeros(1,nRho);
n_plps = 1000;
d_phs = gpuArray.zeros(n_plps,n_sample,'single');
hwb = waitbar(0,'Computing SF ...');
for kRho=1:nRho
    
    phi = gpuArray.rand(1,n_sample,'single')*2*pi;
    zRho = rho(kRho).*exp(1i*phi);
    zxy = (gpuArray.rand(1,n_sample,'single')*2-1)*0.5*L0 + ...
        1i*(gpuArray.rand(1,n_sample,'single')*2-1)*0.5*L0;
    zxy_rho = zxy + zRho;
    tic
    for k_plps = 1:n_plps
        
        phs_xy = ceo_atmosphere(real(zxy),imag(zxy),1,L0,0);
        phs_xy_rho =  ceo_atmosphere(real(zxy_rho),imag(zxy_rho),0,L0,0);
        d_phs(k_plps,:) = phs_xy - phs_xy_rho;
        
    end
    toc
    
    sf = var(d_phs);
    mean_sf(kRho) =  gather( mean(sf) );
    std_sf(kRho)  = gather( std(sf) );
    
    waitbar(kRho/nRho)
    
end
close(hwb)

figure(25)
heb = errorbar(rho,mean_sf, std_sf);
set(heb','Marker','o','MarkerSize',8,...
    'MarkerFaceColor','r','MarkerEdgeColor','k',...
    'Linewidth',2,'LineStyle','none')
hold all
plot(rho,phaseStats.structureFunction(rho,atm),'Linewidth',2)
hold off
grid
xlabel('Separation [m]')
ylabel('Structure function [rd^2]')

%% Structure function test II
fprintf('__ Structure Function Test II __\n')
L0_ = [1 5 25 300]; 
nL0 = length(L0_);

n_plps = 1000;

nxy = n_sample;
phs_xy = gpuArray.zeros(1,nxy,'single');
phs_xy_rho = gpuArray.zeros(1,nxy,'single');

d_phs = gpuArray.zeros(n_plps,n_sample,'single');

rho = logspace(-2,2,10)';
nRho = length(rho);
mean_sf = zeros(nRho,nL0);
std_sf = zeros(nRho,nL0);
th_sf = zeros(nRho,nL0);

for kL0 = 1:nL0
    
    L0 = L0_(kL0);
    atm.L0 = L0;
    clear ceo_atmosphere

    hwb = waitbar(0,sprintf('Computing SF for L0=%3.0fm ...',L0));
    for kRho=1:nRho
        
        phi = gpuArray.rand(1,n_sample,'single')*2*pi;
        zRho = rho(kRho).*exp(1i*phi);
        zxy = (gpuArray.rand(1,n_sample,'single')*2-1)*0.5*L0 + ...
            1i*(gpuArray.rand(1,n_sample,'single')*2-1)*0.5*L0;
        zxy_rho = zxy + zRho;
        
        tic
        for k_plps = 1:n_plps
            
            phs_xy = ceo_atmosphere(real(zxy),imag(zxy),1,L0,0);
            phs_xy_rho =  ceo_atmosphere(real(zxy_rho),imag(zxy_rho),0,L0,0);
            d_phs(k_plps,:) = phs_xy - phs_xy_rho;
            
        end
        toc
        
        sf = var(d_phs);
        mean_sf(kRho,kL0) =  gather( mean(sf) );
        std_sf(kRho,kL0)  = gather( std(sf) );
        
        waitbar(kRho/nRho)
        
    end
    close(hwb)
    
    th_sf(:,kL0) = phaseStats.structureFunction(rho,atm);
    
    figure(26)
    heb = errorbar(repmat(rho,1,kL0),mean_sf(:,1:kL0), std_sf(:,1:kL0));
    set(heb','Marker','o','MarkerSize',8,...
        'MarkerFaceColor','r','MarkerEdgeColor','k',...
        'Linewidth',2,'LineStyle','none','color','b')
    hold all
    plot(rho,th_sf(:,1:kL0),'color','k','Linewidth',2)
    hold off
    grid
    xlabel('Separation [m]')
    ylabel('Structure function [rd^2]')
    set(gca,'xscale','log','yscale','log')  
    drawnow
end
for kL0=1:nL0
    text(rho(end),mean_sf(end,kL0)*.7,sprintf('L0=%3.0fm',L0_(kL0)),...
        'VerticalAlignment','top','BackgroundColor','w')
end

%% Zernike test
fprintf('__ Zernike Test __\n')

L0 = 30;
atm.L0 = L0;
nxy = 128;
clear ceo_atmosphere
cd(ceodir)
unix(['sed -i ',...
    '-e ''s/#define _N_LAYER_ [0-9]*/#define _N_LAYER_ ',num2str(atm.nLayer),'/g'' ',...
    '-e ''s/#define _N_PIXEL_ [0-9]*/#define _N_PIXEL_ ',...
    num2str(nxy^2),'/g'' include/definitions.h']);
unix('cat include/definitions.h');
unix('make clean lib atmosphere.mex')
cd([ceodir,'/test'])
mex -largeArrayDims -I../include -L../lib -lceo -o ceo_atmosphere atmosphere.mex.cu

u = 12.5*single(gpuArray.linspace(-1,1,nxy));
[x,y] = meshgrid(u);

ngs = source('zenith',0,'azimuth',0,'height',90e3);
zern = zernike(1:66,25,'resolution',nxy);

nIt = 4000;
zernCoefs = gpuArray.zeros(zern.nMode,nIt,'single');
h = waitbar(0,'Zernike Test !');
for kTau=1:nIt
    phs = ceo_atmosphere(x,y,1,L0,0);
    zern = zern.\phs;
    zernCoefs(:,kTau) = zern.c;
    waitbar(kTau/nIt,h)
end
close(h)
figure(29)
h = semilogy(zern.j,var(zernCoefs,0,2),'ko',...
    zern.j,zernikeStats.variance(zern,atm,ngs),'.-',...
    zern.j,zernikeStats.variance(zern,atm),'ko--');
set(h(1),'MarkerFaceColor','r')
grid
xlabel('Zernike mode')
ylabel('Zernike coef. variance [rd^2]')

%for kTau=1:nTau;phs = ceo_atmosphere(x,y,0,L0,(kTau-1)*tau);imagesc(phs);axis square;colorbar;drawnow;end

%% Taylor (frozen flow) hypothesis test
fprintf('__ Taylor (frozen flow) Hypothesis Test __\n')

tic
phs = ceo_atmosphere(x,y,0,L0,0);
toc

figure(27)
imagesc(u,u,phs)
axis square
colorbar

nIt = 1000;
tau = 1/10;
duration = 5;
nTau = duration/tau;
wind = 10;%.*exp(1i*pi/3);
% wind = 10.*exp(1i*sin(2*pi*(0:nIt-1)*tau*1));

zern = zernike(1:22,25,'resolution',nxy);
zernCoefs = gpuArray.zeros(zern.nMode,nTau,nIt,'single');

h = waitbar(0,'Taylor (frozen flow) hypothesis test!');
for kIt=1:nIt
    
    phs = ceo_atmosphere(x,y,1,L0,0);
    
    for kTau=1:nTau
        phs = ceo_atmosphere(x,y,0,L0,(kTau-1)*tau);
        zern = zern.\phs;
        zernCoefs(:,kTau,kIt) = zern.c;
        %     set(h,'Cdata',h_phs)
        %     drawnow
    end
    
    waitbar(kIt/nIt,h)
    
end
close(h)

tau_ = (0:nTau-1)*tau;
ngs = source;
zcov = zeros(zern.nMode,zern.nMode,nTau);
if matlabpool('size')==0
    matlabpool open
end
tic
parfor kTau=1:nTau
    zcov(:,:,kTau) = ...
        zernikeStats.temporalAngularCovariance(zern,atm,tau_(kTau),ngs,ngs);
end
toc
zcov_diag =cell2mat( ...
    arrayfun( @(x) squeeze( zcov(x,x,:) ) , 1:22, 'UniformOutput', false) );
figure(30)
h_th = plot(tau_,zcov_diag(:,2:8),'LineWidth',2);
grid
xlabel('Time [s]')
ylabel('Zernike coef. covariance [rd^2]')
legend(num2str((2:8)'),0)
hold off

C = mean( bsxfun( @times , zernCoefs(:,1,:) , zernCoefs ) , 3);
hold all
h_num = plot(tau_,C(2:8,:)','.','MarkerSize',15);
hold off

