% -*- mode: Noweb; noweb-code-mode: c-mode -*-
[[paStats]] contains a structure and the routines to compute the covariance matrix of between the phase if the wavefront and the angle--of--arrival.
The paStats structure is written in the header:
<<paStats.h>>=
#ifndef __PASTATS_H__
#define __PASTATS_H__

#ifndef __CEO_H__
#include "ceo.h"
#endif

#ifndef __ATMOSPHERE_H__
#include "atmosphere.h"
#endif

//#define PASTATS_DEBUG

struct paStats {

  <<paStats parameters>>

  void setup(int N, int osf, atmosphere *atm, float lenslet_pitch);

  void cleanup(void);

  void info(void);

  void MVM(float *y, float *x);

};
#endif // __PASTATS_H__
@ The routines are gathered in the source file:
<<paStats.cu>>=
#include "paStats.h"

<<sinc>>

<<subaperture PSF>>

<<phase power spectrum>>

<<paStats power spectrum kernel>>

<<covariance extraction>>

<<paStats setup>>

<<paStats cleanup>>

<<paStats info>>
@
Shack--Hartmann WFS centroids are a measure of the spatial derivatives of the wavefront averaged on each subaperture.
These derivatives are often referred as angle of arrivals $\vec \alpha=(\alpha_x\alpha_y,)$:
\begin{eqnarray}
  \label{eq:1}
  \alpha_x &=& {\lambda\over 2\pi d^2} {\partial\varphi\over\partial x} \ast \Pi\left(x\over d\right)\Pi\left(y\over d\right),\\
  \alpha_y &=& {\lambda\over 2\pi d^2} {\partial\varphi\over\partial y} \ast \Pi\left(x\over d\right)\Pi\left(y\over d\right),
\end{eqnarray}
where $\lambda$ is the sensing wavelength and $d$ in the size of one subaperture.

The covariance between $\varphi$ and $\vec \alpha$ is derived from the cross--power spectrum density given by:
  \begin{equation}
    \label{eq:2}
    W_{\varphi\vec \alpha}(\vec f) = -\iota\lambda\left( \vec f \cdot \vec\alpha \right) W_\varphi(\vec f) G(\vec f)
  \end{equation}
$W_\varphi(f)$ is the wavefront power spectrum density given by
\begin{equation}
  \label{eq:3}
  W_\varphi(f) = 0.0229 r_0^{-5/3} \left( f^2 + {1\over\mathcal L_0^2} \right)^{-11/6}.
\end{equation}
$G(\vec f)$ is the point spread function of a subaperture of the WFS,
\begin{equation}
  \label{eq:4}
  G(\vec f) = {\sin(\pi d f_x) \over \pi d f_x }{ \sin(\pi d f_y) \over \pi d f_y } .
\end{equation}

The covariance $C_{\varphi \vec \alpha}(\vec\rho)$ is derived from the Wiener--Khinchine theorem:
\begin{equation}
  \label{eq:5}
  C_{\varphi \vec \alpha}(\vec\rho) = \mathcal F^{-1} \left[ W_{\varphi\vec \alpha}(\vec f) \right] (\vec\rho)
\end{equation}
where $\mathcal F^{-1}$ stands for the inverse Fourier transform.

The covariance is computed when the setup function is called with the size of a block, the oversampling factor, an [[atmosphere]] structure and the lenslet pitch:
<<paStats setup>>=
void paStats::setup(int N_, int osf_, atmosphere *atm, float lenslet_pitch)
{
  float alpha[2] = {1,0}, beta[2] = {0,1}, kappa; 
  osf = osf_;
  N = osf*N_+1;
  N2 = N*N;
  NU = 2*N-1;
  NU2 = NU*NU;
  NF = 2048;
  NF2 = NF*NF;
  kappa = 4;

  psd_size = sizeof(float2)*NF2*2;
  cov_size = sizeof(float2)*NU2*2;
  ind_size = sizeof(int)*N2;
  HANDLE_ERROR( cudaMalloc((void**)&d__psd, psd_size ) );
  HANDLE_ERROR( cudaMalloc((void**)&d__alpha, 2*sizeof(float) ) );
  HANDLE_ERROR( cudaMalloc((void**)&d__beta,  2*sizeof(float) ) );
  HANDLE_ERROR( cudaMemcpy( d__alpha, alpha, 2*sizeof(float), cudaMemcpyHostToDevice) );
  HANDLE_ERROR( cudaMemcpy( d__beta, beta, 2*sizeof(float), cudaMemcpyHostToDevice) );
  HANDLE_ERROR( cudaMalloc((void**)&d__cov, cov_size ) );

  printf("\n@(CEO)>imaging: Creating 2D covariance FFT plan\n");
  int n_DFT[2] = {NF, NF};
  int iodist = NF2;
  int BATCH = 2;
  /* Create a 2D FFT plan. */
  if (cufftPlanMany(&plan, 2, n_DFT,
		    NULL, 1, iodist,
		    NULL, 1, iodist,
		    CUFFT_C2C,BATCH) != CUFFT_SUCCESS) {
    fprintf(stderr,
	    "CUFFT Error: Unable to create plan\n");
    return;
  }
  if (cufftSetCompatibilityMode(plan, CUFFT_COMPATIBILITY_NATIVE)!= CUFFT_SUCCESS) {
    fprintf(stderr,
	    "CUFFT Error: Unable to set compatibility mode to native\n");
    return;
  }

 info();  

  stopwatch tid;
  tid.tic();
  <<paStats evaluate covariance>>
  tid.toc(&cov_eval_et,"Covariance evaluation");
}
@ 
The covariance is computed with
<<paStats evaluate covariance>>=
<<paStats power spectrum>>
#ifdef PASTATS_DEBUG
HANDLE_ERROR( cudaDeviceSynchronize() );
psd = (float2 *)malloc( psd_size );
HANDLE_ERROR( cudaMemcpy( psd, d__psd, psd_size, cudaMemcpyDeviceToHost) );
int k;
printf("\n@(CEO)>paStats: power spectrum\n");
for (int i=0;i<MIN(NF,5);i++) {
  printf("|");
  for (int j=0;j<MIN(NF,5);j++) {
    k = i*NF + j;
    printf("|(%d,%d)%+6.4E;%+6.4E|",i,j,psd[k].x,psd[k].y);
  }
  printf("|\n");
}
#endif

<<paStats covariance>>
#ifdef PASTATS_DEBUG
cov = (float2 *)malloc( cov_size );
HANDLE_ERROR( cudaMemcpy( cov, d__cov, cov_size, cudaMemcpyDeviceToHost) );
printf("\n@(CEO)>paStats: covariance\n");
for (int i=0;i<MIN(NU,10);i++) {
  printf("|");
  for (int j=0;j<MIN(NU,10);j++) {
    k = i*(NU) + j;
    printf("|(%d,%d)%+6.4E|",i,j,cov[k].x);
  }
  printf("|\n");
}
#endif
@ The main parameters of [[paStats]] are displayed with the [[info]] routine:
<<paStats info>>=
void paStats::info(void)
{
  printf("\n\x1B[1;42m@(CEO)>paStats:\x1B[;42m\n");
  <<info content>>
  printf("----------------------------------------------------\x1B[0m\n");
}
<<info content>>=
  printf(" . number of blocks              : %dX%d\n",N,N);
  printf(" . size of blocks                : %dX%d\n",N,N);
  n_full = powf(N,4)*4;
  printf(" . full matrix elements #        : %.3E\n",n_full);
  n_comp = 4*NU2;
  printf(" . compressed matrix elements #  : %.3E\n",n_comp);
  printf(" . compression factor            : %4.0f \n",n_full/n_comp);
  float mb = powf(2,20);
  b_full = n_full*sizeof(float);
  if (b_full>mb)
    printf(" . full matrix storage [MB]      : %6.1f\n",b_full/mb);
  else
    printf(" . full matrix storage [KB]      : %6.1f\n",b_full/1024.0);
  b_comp = cov_size;
  if (b_comp>mb)
    printf(" . compressed matrix storage [MB]: %6.1f\n",b_comp/mb);
  else
    printf(" . compressed matrix storage [KB]: %6.1f\n",b_comp/1024.0);
  printf(" . compression factor            : %4.0f \n",b_full/b_comp);
@ 
<<paStats cleanup>>=
void paStats::cleanup(void)
{
  printf("\n@(CEO)>paStats: freeing memory!\n");
  cufftDestroy(plan);
  HANDLE_ERROR( cudaFree( d__psd ) );
  HANDLE_ERROR( cudaFree( d__alpha ) );
  HANDLE_ERROR( cudaFree( d__beta ) );
  HANDLE_ERROR( cudaFree( d__cov ) );
#ifdef PASTATS_DEBUG
  free(psd);		
  free(cov);		
#endif		
}
@
The parameters of the [[paStats]] structure are:
<<paStats parameters>>=
int N, N2, NU, NU2, NF, NF2, psd_size, cov_size, ind_size, osf;
float2 *d__cov, *d__psd;
float *d__alpha, *d__beta, n_full, n_comp, b_full, b_comp, cov_eval_et;
unsigned int *d__mu, *d__xi;
cufftHandle plan;
#ifdef PASTATS_DEBUG
float2 *psd, *cov;
#endif
@ 
The power spectrum  must be sampled such as its Fourier transform gives unbiased values of the covariance.
The largest spatial frequency is $f_{max}=\kappa/2d$ with $\kappa\ge 1$.
The number of sample is given by $[[N_F]]\ge [[N_SIDE_LENSLET]]$.
The spatial frequencies are given by
\begin{eqnarray}
  \label{eq:6}
  f_{x,y} &=& (i,j){2\over [[NF]] }\omega{\kappa\over 2d}, (i,j) \in \left[ 0,\dots,[[NF]]/2-1\right] \\
  f_{x,y} &=& \left[(i,j)-[[NF]]\right]\omega{2\over [[NF]] }{\kappa\over 2d}, (i,j) \in \left[ [[NF]]/2,\dots,[[NF]]-1\right] 
\end{eqnarray}
where $\omega\geq2$ is the oversampling factor [[osf]].
Note that [[NF]] must be even.
<<paStats power spectrum>>=
dim3 blockDim(16,16);
dim3 gridDim( 1+NF/16 , 1+NF/16 );
powerSpectrum LLL gridDim,blockDim RRR (d__psd, NF, osf, lenslet_pitch, 
					atm->wavelength, atm->r0, atm->turbulence.L0,
					d__alpha, kappa);
powerSpectrum LLL gridDim,blockDim RRR (d__psd + NF2, NF, osf, lenslet_pitch,
					atm->wavelength, atm->r0, atm->turbulence.L0,
					d__beta, kappa);
@ The power spectrum is computed with the following kernel:
<<paStats power spectrum kernel>>=
  __global__ void powerSpectrum(float2 *d__psd, int NF, int osf, float d,
				float wavelength, float r0, float L0,
				float *alpha, float kappa)
{
  int i, j, k;
  float fx, fy, f_square, fs;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  k = i*NF + j;
  if ( (i<NF) && (j<(NF)) ) {
    fx = (float) i;
    fy = (float) j;
    if (i>=(NF/2))
      fx = fx - NF;
    if (j>=(NF/2))
      fy = fy - NF;
    fs = osf*(2.0/NF)*(kappa/(2*d));
    fx *= fs;
    fy *= fs;
    k = i*NF + j;
    f_square = fx*fx + fy*fy;
    fs *= fs;
    d__psd[k].y = -fs*wavelength*(fx*alpha[0] + fy*alpha[1])*
      powf(r0,-5.0/3.0)*
      phasePowerSpectrum(f_square, 1.0/L0)*
      gateAmp(fx*d,fy*d);
    d__psd[k].x = 0;
  }
}
@ 
The phase power spectrum is given by:
<<phase power spectrum>>=
 __device__ float phasePowerSpectrum(float f_square, float f0) {
  return 0.0228955871*powf(f_square + f0*f0,-11.0/6.0);
}
@ 
The subaperture Fourier transform is given by
\begin{equation}
  \label{eq:9}
  {\mathrm sinc}(f_x){\mathrm sinc}(f_y)
\end{equation}
and written in
<<subaperture PSF>>=
__device__ float gateAmp(float fx, float fy) {
  float out;
  out = sinc(fx)*sinc(fy);
  return out;
}
@ that depends on the $sinc$ function:
\begin{equation}
  \label{eq:10}
  {\sin(\pi x)\over \pi x}
\end{equation}
<<sinc>>=
__device__ float sinc(float x) {
  return (x==0) ? 1.0 : sinf( PI*x) / (PI*x) ; 
}
@ 
The covariance derived from the power spectrum is sampled every $\rho_s=d/\kappa$.
The covariance derived from the slopes of the lenslet array is sampled every $d$.
Consequently the lenslet--array--slope--covariance is extracted from the power--spectrum--covariance at $(i\kappa,j\kappa)$.
Due to the symmetry of the Fourier transform output, the subscripts in the power--spectrum--covariance are in fact given by
\begin{eqnarray}
  \label{eq:8}
  (i,j)\kappa, (i,j) \in \left[ 0,\dots,[[N]]-1 \right] \\
  \left[(i,j)-[[NU]]\right]\kappa + [[NF]], (i,j) \in \left[ [[N]],\dots,[[NU]]-1 \right]
\end{eqnarray}

The lenslet--array--slope--covariance is shifted such as the baseline coordinate $(0,0$) is a the center of the array i.e.
\begin{equation}
  \label{eq:7}
  (i,j) \leftarrow \left[ (i,j) + (2[[N]]-2)/2 \right] \mod ( 2[[N]]-1 )
\end{equation}
<<paStats covariance>>=
if (cufftExecC2C(plan, d__psd, d__psd, CUFFT_FORWARD) 
    != CUFFT_SUCCESS){
  fprintf(stderr,"CUFFT Error: Unable to execute plan\n");
 }
if (cudaThreadSynchronize() != cudaSuccess){
  fprintf(stderr, "Cuda error: Failed to synchronize\n");
 }
blockDim = dim3(16,16);
gridDim = dim3( 1+NU/16 , 1+NU/16 );
covariance_extraction LLL gridDim,blockDim RRR( d__cov, NU, d__psd, NF, kappa);
covariance_extraction LLL gridDim,blockDim RRR( d__cov + NU2, NU, d__psd + NF2, NF, kappa);
@ The extraction of the covariance is done with the kernel:
<<covariance extraction>>=
__global__ void covariance_extraction(float2 *cov_out, int NC_out, 
				      float2 *cov_in, int NC_in, float kappa)
{
  int i, j, k_out, k_in, h;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  if ( (i<NC_out) && (j<(NC_out)) ) {
    h = (NC_out-1)/2;
    k_out = (NC_out - 1 - (i+h)%NC_out)*NC_out + (NC_out - 1 - (j+h)%NC_out);
    if (i>=((NC_out+1)/2))
      i = kappa*(i - NC_out) + NC_in;
    else
      i *= kappa;
    if (j>=(NC_out+1)/2)
      j = kappa*(j - NC_out) + NC_in;
    else
      j *= kappa;
    k_in = i*NC_in + j;      
    cov_out[k_out].x = cov_in[k_in].x;
    cov_out[k_out].y = 0.0;
  }
}
@ 
The 1D Fourier transform is now applied to the raster covariance
<<raster covariance FT>>=
if (cufftExecC2C(raster_plan, d__cov, d__cov, CUFFT_FORWARD) 
    != CUFFT_SUCCESS){
  fprintf(stderr,"CUFFT Error: Unable to execute plan\n");
 }
if (cudaThreadSynchronize() != cudaSuccess){
  fprintf(stderr, "Cuda error: Failed to synchronize\n");
 }
@ 
The test routine is written:
<<paStats.bin>>=

#include "cublas_v2.h"
#include "ceo.h"
#include "paStats.h"
#include "BTBT.h"

#define N_RUN 1

  __global__ void fill(float *A, int m_a, int n_a) {
  int i, j, k;
  float n;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  k = i*m_a +j;
  n = (float) m_a*n_a;
  if (k<n)
    A[k] = ((float)k)/n;
}

int main( void) {
  atmosphere atm;
  paStats pa;
  BTBT S;
  int k, data_size, MA, NA, N, NX, NY, k_N;
  float altitude[] = {0},
        xi0[] = {1},
        wind_speed[] = {10},
  	wind_direction[] = {0};
  float *x, *y, *d__x, *d__y, *d__A;
  stopwatch tid;
  cublasHandle_t handle;
  cublasCreate(&handle);
  cublasStatus_t status;

  atm.setup(0.15,30,altitude,xi0,wind_speed,wind_direction);

  int N_[N_RUN] = {4};//{10,20,40,60,100,200};//,500};
  float full_mvm_et[N_RUN], comp_mvm_et[N_RUN], comp_eval_et[N_RUN], 
    b_full[N_RUN], b_comp[N_RUN];

  dim3 blockDim(16,16);
  dim3 gridDim;
  float alpha, beta, osf;
  alpha = 1;
  beta  = 0;
  osf = 2;

  for (k_N=0;k_N<N_RUN;k_N++) {

    N = 2*N_[k_N]+1;
    NX = N*N*2;
    NY = N*N;
    data_size = sizeof(float);

    x = (float *)malloc( data_size*NX );
    y = (float *)malloc( data_size*NY );
    HANDLE_ERROR( cudaMalloc((void**)&d__x, data_size*NX ) );
    HANDLE_ERROR( cudaMalloc((void**)&d__y, data_size*NY ) );

    for (k=0;k<NX;k++) {
      x[k] = (float)k;
    }
    HANDLE_ERROR( cudaMemcpy( d__x, x, data_size*NX, cudaMemcpyHostToDevice) );
    pa.setup(N_[k_N],osf,&atm,0.1);
    S.setup(1,2,N,pa.d__cov);
    
    comp_eval_et[k_N] = pa.cov_eval_et;
    b_full[k_N] = pa.b_full;
    b_comp[k_N] = pa.b_comp;

    tid.tic();
    S.MVM(d__y,d__x);
    tid.toc(comp_mvm_et + k_N,"Covariance MVM");
    HANDLE_ERROR( cudaMemcpy( y, d__y, data_size*NY, cudaMemcpyDeviceToHost) );
    /* printf("\nMVM:\n"); */
    /* for (k=0;k<NX;k++) { */
    /*   printf("(%2d) %4.2E\n",k,y[k]); */
    /* } */
    FILE *fid;
    char filename[100];
    sprintf(filename,"mvm%03d.bin",N);
    fid = fopen(filename,"wb");
    fwrite(y,sizeof(float),NY,fid);
    fclose(fid);

    if (N<=100) {
      MA = N*N;
      NA = 2*MA;
      data_size = sizeof(float)*MA*NA;
      HANDLE_ERROR( cudaMalloc((void**)&d__A, data_size ) );
      gridDim = dim3(1+MA/16,1+NA/16);
      tid.tic();
      fill LLL gridDim,blockDim RRR (d__A, MA , NA);
      tid.toc("Filling of A");
      tid.tic();
      status = cublasSgemv(handle, CUBLAS_OP_N, MA, NA, &alpha, d__A, MA, d__x, 1, &beta, d__y, 1);
      tid.toc(full_mvm_et + k_N,"A MVM");
      if (status!=CUBLAS_STATUS_SUCCESS)
	printf(">>> ERROR! CUBLAS FAILED! <<<\n");
      HANDLE_ERROR( cudaFree( d__A ) );
    } else full_mvm_et[k_N]=0;

    pa.cleanup();
    S.cleanup();
    HANDLE_ERROR( cudaFree( d__x ) );
    HANDLE_ERROR( cudaFree( d__y ) );
    free(x);
    free(y);
  }

  atm.cleanup();
  cublasDestroy(handle);

  printf("\n N   FULL MVM   COMP MVM   COMP EVAL\n");
  for (k_N=0;k_N<N_RUN;k_N++) {
    printf("%3d    %6.3f     %6.3f     %6.3f\n",
	   N_[k_N],full_mvm_et[k_N],comp_mvm_et[k_N],comp_eval_et[k_N]);
  }
}
