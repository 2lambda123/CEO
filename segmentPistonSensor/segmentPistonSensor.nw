% -*- mode: Noweb; noweb-code-mode: c-mode -*-
@
\section{The files}
\label{sec:files}

\subsection{Header}
\label{sec:header}

<<segmentPistonSensor.h>>=
#ifndef __SEGMENTPISTONSENSOR_H__
#define __SEGMENTPISTONSENSOR_H__

#ifndef __SOURCE_H__
#include "source.h"
#endif

#ifndef __RAYTRACING_H__
#include "rayTracing.h"
#endif 

#ifndef __IMAGING_H__
#include "imaging.h"
#endif

struct segmentPistonSensor {

  <<parameters>>
  void setup(gmt_m1 *M1, int N_SRC);
  void cleanup(void);
  void propagate(source *src);
};

#endif // __SEGMENTPISTONSENSOR_H__
@ 
\subsection{Source}
\label{sec:source}

<<segmentPistonSensor.cu>>=
#include "segmentPistonSensor.h"

<<lenslet trimming kernel>>

<<setup>>
<<cleanup>>
<<propagation>>
@
\subsection{Python}
\label{sec:python}

<<segmentPistonSensor.pxd>>=
from rayTracing cimport gmt_m1, GMT_M1
from source cimport complex_amplitude, Complex_amplitude, source, Source
from imaging cimport imaging, Imaging
cdef extern from "segmentPistonSensor.h":
    cdef cppclass segmentPistonSensor:
        int N_LENSLET, N_PX_LENSLET, N_PX
        complex_amplitude lenslet
        imaging camera
        void setup(gmt_m1 *, int)
        void cleanup()
        void propagate(source *)
<<class definition>>
@ 
<<class definition>>=
cdef class SegmentPistonSensor:
    cdef:
        segmentPistonSensor *_c_segmentPistonSensor
        readonly Complex_amplitude W
        readonly Imaging camera
@ 
<<segmentPistonSensor.pyx>>=
cdef class SegmentPistonSensor:
    def __cinit__(self,GMT_M1 M1, Source gs):
        self._c_segmentPistonSensor = new segmentPistonSensor()
        self._c_segmentPistonSensor.setup(M1._c_gmt_m12,gs._c_source.N_SRC)
        
        self.W = Complex_amplitude()
        self.W._c_complex_amplitude = &(self._c_segmentPistonSensor.lenslet)
        self.W.__alloc__((self._c_segmentPistonSensor.N_PX,
                          self._c_segmentPistonSensor.N_PX))
        self.camera = Imaging(self._c_segmentPistonSensor.N_LENSLET,
                              self._c_segmentPistonSensor.N_PX_LENSLET,
                              sps=self)

    def __dealloc__(self):
        self._c_segmentPistonSensor.cleanup()

    def propagate(self, Source gs):
        self._c_segmentPistonSensor.propagate(gs._c_source)
@ 

\section{The model}
\label{sec:model}

The segment piston sensor consists in 12 lenslets across the segment gaps as show in the figure below
\begin{tikzpicture}
  \coordinate (O) at (0,0);
  \fill[black!10] (O) circle [radius=10mm] node {7};
  \foreach \x in {1,...,6} {
    \coordinate (O) at (150-\x*60:22mm);
     \fill[black!10] (O) circle [radius=10mm] node {\x};
  }
  \foreach \x in {1,...,6} {
    \coordinate (O) at (150-\x*60:11mm);
    \fill[blue!30,fill opacity=0.5,draw=black,very thin,rotate=60-\x*60] ($(O)-(2mm,2mm)$) rectangle ($(O)+(2mm,2mm)$);
    \coordinate (O) at (120-\x*60:19mm);
    \fill[green!30,fill opacity=0.5,draw=black,thin,rotate=30-\x*60] ($(O)-(2mm,2mm)$) rectangle ($(O)+(2mm,2mm)$);
  }
  \draw[dotted] circle[radius=11mm];
  \draw[dotted] circle[radius=19mm];
\end{tikzpicture}

Projected onto M1, the inner six (blue) and outer six (green) lenslets are centered on circles of radius $ri=4.387$m and $ro=7.543$m, respectively.
The lenslet size is $L=1.5$m.
The lenslets are conjugated to an height of 82.5m above M1, hence shifting the lenslet location according to the guide star locations.

Each lenslet is cropped out of the pupil plane and embedded into a zero--padded array twice the size of the lenslet.
The 12 resulting arrays are arranged into a $4\times 4$ square zero--padded block array as if each block is a new lenslet twice the size of the original lenslet.
There are as many of these block arrays as there are guide stars.

\newcommand{\croppedLenslet}[5]{
  \coordinate (O) at (#3:#4mm);
  \begin{scope}[shift={($(#1mm,#2mm)-(O)$)}]
    \coordinate (O) at (#3:#4mm);
    \clip ($(O)-(4mm,4mm)$) rectangle ($(O)+(4mm,4mm)$);
    \coordinate (O) at (0,0);
    \fill[black!10] (O) circle [radius=10mm] node {7};
    \foreach \x in {1,...,6} {
      \coordinate (O) at (150-\x*60:22mm);
      \fill[black!10] (O) circle [radius=10mm] node {\x};
    }
    \coordinate (O) at (#3:#4mm);
    \fill[#5!30,fill opacity=0.5,draw=black,very thin,rotate=#3-90] ($(O)-(2mm,2mm)$) rectangle ($(O)+(2mm,2mm)$);  
  \end{scope}
}

\begin{tikzpicture}
  \croppedLenslet{-12}{12}{90}{11}{blue}
  \croppedLenslet{-4}{12}{30}{11}{blue}
  \croppedLenslet{4}{12}{-30}{11}{blue}
  \croppedLenslet{12}{12}{-90}{11}{blue}

  \croppedLenslet{-12}{4}{-150}{11}{blue}
  \croppedLenslet{-4}{4}{-210}{11}{blue}

  \croppedLenslet{4}{4}{120}{19}{green}
  \croppedLenslet{12}{4}{60}{19}{green}

  \croppedLenslet{-12}{-4}{0}{19}{green}
  \croppedLenslet{-4}{-4}{-60}{19}{green}
  \croppedLenslet{4}{-4}{-120}{19}{green}
  \croppedLenslet{12}{-4}{-180}{19}{green}

  \draw[step=8mm] (-16mm,-16mm) grid (16mm,16mm);
\end{tikzpicture}

\section{Parameters}
\label{sec:parameters}

The parameters for the segment piston sensor models are:
\begin{itemize}
\item the inner and outer radius of the lenslet locations:
<<parameters>>=
float ri, ro;
@
\item the conjugation height of the lenslet in meter:
<<parameters>>=
float lenslet_height;
@
\item the size of the lenslet in meter:
<<parameters>>=
float lenslet_size;
@
\item the re--ordered wavefront on the 12 lenslets:
<<parameters>>=
complex_amplitude lenslet;
@
\item the detector:
<<parameters>>=
imaging camera;
@ 
\item the pixel size of one [[lenslet]]:
<<parameters>>=
int N_PX_LENSLET, N_PX_LENSLET2;
@
\item the size in pixel of the [[lenslet]] array:
<<parameters>>=
int N_PX, N_PX2;
@
\item the number of [[masklet]] and [[lenslet]]:
<<parameters>>=
int N_LENSLET, N_LENSLET2;
@
\item some internal variables:
<<parameters>>=
int D_px, D_px2;
float m2px, R;
@
\end{itemize}

\section{Functions}
\label{sec:functions}

\subsection{Setup \& Cleanup}
\label{sec:setup--cleanup}

<<setup>>=
void segmentPistonSensor::setup(gmt_m1 *M1, int N_SRC)
{
  lenslet_size  = 1.5;
  lenslet_height = 82.5;
  ri = (M1->D_full+0.357)*0.5 ;
  ro = M1->L*sqrt(3)*0.5;
  m2px = M1->D_px/M1->D;
  R    = M1->D*0.5;
  D_px2 = D_px = M1->D_px;
  D_px2 *= D_px;

  N_PX_LENSLET2 =  N_PX_LENSLET = 2*ceil(lenslet_size*m2px);;
  N_PX_LENSLET2 *= N_PX_LENSLET;

  N_LENSLET2 =  N_LENSLET = ceil(sqrt(12*N_SRC));
  N_LENSLET2 *= N_LENSLET;

  N_PX2 =  N_PX = N_PX_LENSLET*N_LENSLET;
  N_PX2 *= N_PX;

  lenslet.setup(N_PX2, 1);
  HANDLE_ERROR( cudaMemset( lenslet.amplitude, 0 , sizeof(float)*lenslet.N_PX) );
  camera.setup(N_PX_LENSLET-1,N_LENSLET,2,2*N_PX_LENSLET,2,N_SRC);

}
@ 
The memory is freed with:
<<cleanup>>=
void segmentPistonSensor::cleanup(void)
{
  fprintf(stdout,"@(CEO)>segmentPistonSensor: freeing memory!\n");
  lenslet.cleanup();
  camera.cleanup();
}
@

\subsection{Propagation}
\label{sec:propagation}

<<propagation>>=
void segmentPistonSensor::propagate(source *gs)
{
  dim3 blockDim(16,16);
  dim3 gridDim(N_PX_LENSLET/16+1,N_PX_LENSLET/16+1,gs->N_SRC);
  
  lenslet_trim LLL gridDim, blockDim RRR (lenslet.phase, 
                                          lenslet.amplitude, 
                                          N_PX_LENSLET,
					  gs->wavefront.phase, 
					  gs->wavefront.amplitude, 
                                          D_px, ri, ro, N_LENSLET,
					  lenslet_size, 
					  lenslet_height, R,
					  gs->dev_ptr, m2px);

  source src;
  src.setup(gs[0].photometric_band,0.0,0.0,INFINITY);
  src.wavefront.N         = lenslet.N;
  src.wavefront.N_PX      = lenslet.N_PX;
  src.wavefront.amplitude = lenslet.amplitude;
  src.wavefront.phase     = lenslet.phase;
  src.wavefront.M         = lenslet.M;
  camera.propagateNoOverlap(&src);
}
@ 
<<lenslet trimming kernel>>=
__global__ void lenslet_trim(float *piecewise_phase, 
                             float *piecewise_amplitude, 
                             const int n_px_lenslet, 
			     float *pupil_phase, 
			     float *pupil_amplitude, 
                             const int n_in, 
			     const float ri, const float ro,
			     const int N_LENSLET,
			     const float lenslet_size,
			     const float lenslet_height,
			     const float R,
			     source *src,
			     const float m2px)
{
  int i, j, k_out, k_in, iSource, k_LA,
    i_lenslet, j_lenslet, k_lenslet, 
    i_in, j_in;
  float theta, xc, yc, x0, y0, O, 
    s, c, h, x, y, xr, yr, pupil;

  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  iSource = blockIdx.z;
  if ( (i<n_px_lenslet) && (j<n_px_lenslet) ) {

    O = R - lenslet_size;
    x0 = lenslet_height*src[iSource].zenith*cos(src[iSource].azimuth) + O;
    y0 = lenslet_height*src[iSource].zenith*sin(src[iSource].azimuth) + O;

    k_lenslet = 12*iSource;

    for (k_LA=0;k_LA<6;k_LA++) {
      theta = k_LA*PI/3.0;

      j_lenslet = k_lenslet/N_LENSLET;
      i_lenslet = k_lenslet - N_LENSLET*j_lenslet;

      sincosf(theta,&s,&c);
      xc = ri*c + y0;
      yc = ri*s + x0;

      <<lenslet trimming kernel block>>

      theta = (k_LA-0.5)*PI/3.0;
      
      j_lenslet = (k_lenslet+6)/N_LENSLET;
      i_lenslet = (k_lenslet+6) - N_LENSLET*j_lenslet;

      sincosf(theta,&s,&c);
      xc = ro*c + y0;
      yc = ro*s + x0;

      <<lenslet trimming kernel block>>

      ++k_lenslet;
    }
  }
}
@  where
<<lenslet trimming kernel block>>=
i_in = (int) floor(yc*m2px);
j_in = (int) floor(xc*m2px);

k_out = lenslet2array( i,  j,  n_px_lenslet,
  		     i_lenslet,  j_lenslet,  N_LENSLET,  0);
k_in = j + i_in;
k_in += (i + j_in + iSource*n_in)*n_in;

h = lenslet_size*0.5;
x = 2*lenslet_size*(i - (n_px_lenslet-1)*0.5)/(n_px_lenslet-1);
y = 2*lenslet_size*(j - (n_px_lenslet-1)*0.5)/(n_px_lenslet-1);
xr = c*x + y*s;
yr = -s*x + y*c;

pupil = ( ( (xr>=-h) && (xr<=h) ) && ( (yr>=-h) && (yr<=h) ) ) ? 1.0 : 0.0;

piecewise_phase[k_out]     = pupil*pupil_phase[k_in];
piecewise_amplitude[k_out] = pupil*pupil_amplitude[k_in];
@ 

\subsection{Input/Output}
\label{sec:inputoutput}

\section{Tests}
\label{sec:tests}

