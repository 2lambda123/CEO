% -*- mode: Noweb; noweb-code-mode: c-mode -*-
@
\subsection{The files}

\subsubsection{Header}

<<LMMSE.h>>=
#ifndef __LMMSE_H__
#define __LMMSE_H__

#ifndef __CEO_H__
#include "ceo.h"
#endif

#ifndef __AASTATS_H__
#include "aaStats.h"
#endif

#ifndef __BTBT_H__
#include "BTBT.h"
#endif

#ifndef __ITERATIVESOLVERS_H__
#include "iterativeSolvers.h"
#endif

//#define MINRES_DEBUG

struct LMMSE {

  <<parameters>>

  void setup(atmosphere *atm, source *guide_star, int N_guide_star, source *mmse_star, int N_mmse_star,
	     float sampling, int N, char *solver_id);
  void new_setup(atmosphere *atm, source *guide_star, int N_guide_star, source *mmse_star, int N_mmse_star,
	     float sampling, int N, char *solver_id);
  void fried_setup(atmosphere *atm, source *guide_star, int N_guide_star, source *mmse_star, int N_mmse_star,
	     float sampling, int N, char *solver_id);

  void cleanup(void);
  void new_cleanup(void);

  void estimation(float* d__c, int nMaxIteration, float *d__x0);
  void estimation(float* d__c, int nMaxIteration);
  void new_estimation(float* d__c, int nMaxIteration);
  void fried_estimation(float* d__c, int nMaxIteration);
  void fried_sparse_estimation(float* d__c, int nMaxIteration);

};
#endif // __LMMSE_H__
@
\subsubsection{Source}

<<LMMSE.cu>>=
#ifndef __LMMSE_H__
#include "LMMSE.h"
#endif

<<PA input>>
<<PA input with sizes>>

<<sparse matrix kernel>>

<<setup>>
<<setup (new)>>
<<setup (rect)>>

<<cleanup>>
<<cleanup (new)>>

<<wavefront estimation (I)>>
<<wavefront estimation (II)>>
<<wavefront estimation (III)>>
<<wavefront estimation (IV)>>
<<wavefront estimation (V)>>
@

\subsection{Functions}
\label{sec:functions}

\def\vo{\ensuremath{\bm \theta}\xspace}
\def\voe{\ensuremath{\hat{\bm \theta}}\xspace}
\def\vx{\ensuremath{\bm x}\xspace}
\def\vn{\ensuremath{\bm n}\xspace}
\def\vs{\ensuremath{\bm s}\xspace}
\def\wf{\ensuremath{\bm \varphi}\xspace}
\def\wfe{\ensuremath{\hat{\bm \varphi}}\xspace}
\def\vz{\ensuremath{\bm \zeta}\space}

\def\Ca{\ensuremath{\Theta}\xspace}
\def\Cax{\ensuremath{\Theta_{xx}}\xspace}
\def\Cay{\ensuremath{\Theta_{yy}}\xspace}
\def\Caxy{\ensuremath{\Theta_{xy}}\xspace}
\def\Cayx{\ensuremath{\Theta_{yx}}\xspace}
\def\Cpa{\ensuremath{\Xi}\xspace}
\def\Cpax{\ensuremath{\Xi_x}\xspace}
\def\Cpay{\ensuremath{\Xi_y}\xspace}
\newcommand{\mean}[1]{\left\langle #1 \right\rangle}

The LMMSE structure is used to compute the wavefront estimate $\hat \varphi$ used a vector of wavefront gradient $s$ assuming a linear relationship between both i.e.
\begin{equation}
  \label{eq:1}
  \hat \varphi = M s.
\end{equation}
$M$ is chosen such as it minimizes the Bayesian mean--square error~\cite{Kay10} (MSE):
\begin{equation}
  \label{eq:2}
  b_{MSE} = \left\langle (\varphi-\hat \varphi)^2 \right\rangle
\end{equation}
$\hat \varphi$ is the Linear--Minimum--Mean--Square--Error (LMMSE) estimator of $\varphi$ and $M$ is given by
\begin{equation}
  \label{eq:3}
  M = C_{\varphi s}C_{ss}^{-1}.
\end{equation}
$C_{ss}\equiv\Ca$ is the slope covariance and $C_{\varphi s}=\equiv\Cpa$ is the cross--correlation between the wavefront and the slopes.
Eq.~(\ref{eq:1}) is then rewritten 
\begin{equation}
  \label{eq:4}
  \varphi = \Cpa \zeta
\end{equation}
with $\zeta$ solution of
\begin{equation}
  \label{eq:5}
  \Ca \zeta = s.
\end{equation}

The covariances are expanded into
\begin{equation}
  \label{eq:6}
  \Ca = \mean{ ss^T } = \left[
  \begin{array}{cc}
    \mean{s_xs_x^T} & \mean{s_xs_y^T} \\
    \mean{s_ys_x^T} & \mean{s_ys_y^T} 
  \end{array}
  \right] = \left[
  \begin{array}{cc}
    \Cax & \Caxy \\
    \Cayx & \Cay
  \end{array}
  \right]  
\end{equation}
and
\begin{equation}
  \label{eq:7}
  \Cpa = \mean{ \wf s^T } = \left[
  \begin{array}{cc}
    \mean{ \wf s_x^T } & \mean{ \wf s_y^T }
  \end{array}
  \right] = \left[
    \begin{array}{cc}
      \Cpax & \Cpay
    \end{array}
    \right]  
\end{equation}


For a square $N\times N$ lenslet array, each covariance matrix \Cax, \Caxy, \Cayx and \Cay is a $N^2\times N^2$ 2--level recursive block Toeplitz matrix (2RBT) as shown in Fig.~\ref{fig:1}.
Eq.~(\ref{eq:5}) is then solved iteratively using the method in \cite{Lee86} to perform the matrix--to--vector product (MVP).
% COVARIANCE
\newcounter{idx}
\begin{figure*}[htbp]
  \centering
 \begin{tikzpicture}[scale=0.75]
 \draw[help lines,xstep=4cm,ystep=4cm,xshift=0.5cm,yshift=0.5cm] (0,0) grid (16,16);
\foreach \i/\xi/\yi in {1/0/0,2/0/1,3/0/2,4/0/3,5/1/0,6/1/1,7/1/2,8/1/3,9/2/0,10/2/1,11/2/2,12/2/3,13/3/0,14/3/1,15/3/2,16/3/3} {
\foreach \j/\xj/\yj in {1/0/0,2/0/1,3/0/2,4/0/3,5/1/0,6/1/1,7/1/2,8/1/3,9/2/0,10/2/1,11/2/2,12/2/3,13/3/0,14/3/1,15/3/2,16/3/3} {
\draw[->,>=stealth'] (\i,\j) -- +($0.175*( $($(\xj,\yj)-(1.5,1.5)$) - ($1*($(\xi,\yi)-(1.5,1.5)$) $) $ )$);
}}
\foreach \i in {1,...,16} {
 \node at (0,\i) {\scriptsize \i};
 \node at (\i,0) {\scriptsize \i};
}
\draw[red,dashed,thick,rounded corners] (0.5,0.5) -- ++(4,0) -- ++(0,1) -- ++(-3,0) -- ++(0,3) -- ++(-1,0) -- cycle;
\foreach \x in {1,...,3} {
\draw[red,dashed,thick,rounded corners,xshift=\x*4cm] (0.5,0.5) -- ++(4,0) -- ++(0,1) -- ++(-3,0) -- ++(0,3) -- ++(-1,0) -- cycle;
\draw[red,dashed,thick,rounded corners,yshift=\x*4cm] (0.5,0.5) -- ++(4,0) -- ++(0,1) -- ++(-3,0) -- ++(0,3) -- ++(-1,0) -- cycle;
}
\setcounter{idx}{0}
\foreach \x/\y in {0/0,0/-3,0/-6,0/-9,3/-9,6/-9,9/-9} {
\foreach \i/\j in {1/16,1/15,1/14,1/13,2/13,3/13,4/13} {
  \stepcounter{idx}
  \node[inner sep=0,xshift=\x cm,,yshift=\y cm] at (\i,\j) {\emph{\scriptsize\arabic{idx}}};
}
}
\end{tikzpicture}
  \caption{WFS vectors of measurement pairs.}
  \label{fig:1}
\end{figure*}
% CROSS-COVARIANCE
\begin{figure*}[htbp]
  \centering
 \begin{tikzpicture}[y=-1cm]
 \draw[help lines,xstep=4cm,ystep=5cm,xshift=0.5cm,yshift=-0.5cm] (0,0) grid (16,25);
\foreach \i/\xi/\yi in {1/0/0,2/0/1,3/0/2,4/0/3,5/1/0,6/1/1,7/1/2,8/1/3,9/2/0,10/2/1,11/2/2,12/2/3,13/3/0,14/3/1,15/3/2,16/3/3} {
\foreach \j/\xj/\yj in {1/0/0,2/0/1,3/0/2,4/0/3,5/0/4,6/1/0,7/1/1,8/1/2,9/1/3,10/1/4,11/2/0,12/2/1,13/2/2,14/2/3,15/2/4,16/3/0,17/3/1,18/3/2,19/3/3,20/3/4,21/4/0,22/4/1,23/4/2,24/4/3,25/4/4}{
\draw[->,>=stealth'] (\i,\j) -- +($0.175*( $($(\xj,\yj)-(2,2)$) - ($1*($(\xi,\yi)-(1.5,1.5)$) $) $ )$);
}}
\foreach \i in {1,...,16} {
 \node at (\i,0) {\scriptsize \i};
}
\foreach \i in {1,...,25} {
 \node at (0,\i) {\scriptsize \i};
}
\draw[red,dashed,thick,rounded corners] (0.5,0.5) -- ++(4,0) -- ++(0,1) -- ++(-3,0) -- ++(0,4) -- ++(-1,0) -- cycle;
\foreach \x in {1,...,3} {
\draw[red,dashed,thick,rounded corners,xshift=\x*4cm] (0.5,0.5) -- ++(4,0) -- ++(0,1) -- ++(-3,0) -- ++(0,4) -- ++(-1,0) -- cycle;
\draw[red,dashed,thick,rounded corners,yshift=-\x*5cm] (0.5,0.5) -- ++(4,0) -- ++(0,1) -- ++(-3,0) -- ++(0,4) -- ++(-1,0) -- cycle;
}
\draw[red,dashed,thick,rounded corners,yshift=-20cm] (0.5,0.5) -- ++(4,0) -- ++(0,1) -- ++(-3,0) -- ++(0,4) -- ++(-1,0) -- cycle;
\setcounter{idx}{0}
\foreach \x/\y in {0/0,0/-5,0/-10,0/-15,0/-20,4/-20,8/-20,12/-20} {
\foreach \i/\j in {1/25,1/24,1/23,1/22,1/21,2/21,3/21,4/21} {
  \stepcounter{idx}
  \node[inner sep=0,xshift=\x cm,yshift=-\y cm] at (\i,\j) {\emph{\scriptsize\arabic{idx}}};
}
}
\end{tikzpicture}
  \caption{vectors of WFS and measurement pairs.}
  \label{fig:1}
\end{figure*}
%% CROSS-COVARIANCE SAMPLING
\begin{figure}[htbp]
  \centering
  \begin{tikzpicture}%[scale=2]
    \draw[help lines,xstep=0.5cm,ystep=0.5cm] (-4,-4) grid (4,4);
\foreach \i/\xi/\yi in {1/0/0,2/0/1,3/0/2,4/0/3,5/1/0,6/1/1,7/1/2,8/1/3,9/2/0,10/2/1,11/2/2,12/2/3,13/3/0,14/3/1,15/3/2,16/3/3} {
\foreach \j/\xj/\yj in {1/0/0,2/0/1,3/0/2,4/0/3,5/0/4,6/1/0,7/1/1,8/1/2,9/1/3,10/1/4,11/2/0,12/2/1,13/2/2,14/2/3,15/2/4,16/3/0,17/3/1,18/3/2,19/3/3,20/3/4,21/4/0,22/4/1,23/4/2,24/4/3,25/4/4}{
\draw[->,>=stealth'] (0,0) -- +($1*( $($(\xj,\yj)-(2,2)$) - ($1*($(\xi,\yi)-(1.5,1.5)$) $) $ )$);
}}
  \end{tikzpicture}
  \caption{Cross-covariance unique set of baseline vectors.}
  \label{fig:5}
\end{figure}

For a system in the Fried geometry (Fig.~\ref{fig:2}, left side), the cross--covariance matrix \Cpax and \Cpay are not square 2RBT matrices.
So the geometry shown on the right of Fig.~\ref{fig:2} is used instead where the black circles are the wavefront samples, the red circles correspond to the measured slopes and the blue circles are the ``fake'' zero--valued measurements.
In the new geometry, \Cpax and \Cpay are square 2RBT matrices.

% WAVEFRONT NGS SAMPLING
\begin{figure}[htbp]
  \centering
  \begin{tikzpicture}
    \begin{scope}[xshift=-2.25cm]
    \draw[help lines] (-2,-2) grid (2,2);
\foreach \x in {0,1,...,4}
\foreach \y in {0,1,...,4}
{
\fill ($(\x,\y)-(2,2)$) circle (0.8mm);
}
\foreach \x in {0,1,...,3}
\foreach \y in {0,1,...,3}
{
\draw[red,thick] ($1*($(\x,\y)-(1.5,1.5)$)$) circle (1.2mm);
}
    \end{scope}
    \begin{scope}[xshift=2.25cm]
    \draw[help lines] (-2,-2) grid (2,2);
\foreach \x in {0,0.5,...,4}
\foreach \y in {0,0.5,...,4}
{
\fill ($(\x,\y)-(2,2)$) circle (0.8mm);
\draw[blue,thick] ($(\x,\y)-(2,2)$) circle (1.2mm);
}
\foreach \x in {0,1,...,3}
\foreach \y in {0,1,...,3}
{
\draw[red,thick] ($(\x,\y)-(1.5,1.5)$) circle (1.2mm);
}
    \end{scope}
  \end{tikzpicture}
  \caption{Wavefront and NGS measurement sampling with a $4\times4$ lenslet array. The Fried geometry is on the left and the 2RBT geometry is on the right.}
  \label{fig:2-exp}
\end{figure}

Fig.~\ref{fig:2} is valid for a NGS based AO system but this geometry is altered in the case of a LGS AO system.
The geometry resulting from the finite distance of the LGS is show in the left hand side of Fig.~\ref{fig:3}.
The geometry depicted in the right hand side of Fig.~\ref{fig:3} is used instead.
With this geometry, the wavefront sample locations are computed om the grid of filled blue circles and the slope measurements are augmented of zero--valued slopes on the same grid.
Wavefront and slopes are now defined on the same grid, their covariance is again a 2RBT matrix.
The wavefront samples on the grid made of the filled black circles is obtained with a bi--linear interpolation within the blue circles.
This sequence of operations need to be performed for each layer and the results from each layer are summed.
For a $N_{atm}$ layer atmospheric profile, Eq.~(\ref{eq:4}) becomes
\begin{equation}
  \label{eq:8}
  \varphi = \left[
    \begin{array}{c}
      H_1 \cdots H_{N_{atm}}
    \end{array}
\right]
\left[
    \begin{array}{cc}
      \Xi_{x1} & \Xi_{y1} \\
      \vdots  & \vdots \\ 
      \Xi_{xN_{atm}} & \Xi_{yN_{atm}} \\
    \end{array}
    \right] \left[
      \begin{array}{c}
        s_x \\
        s_y
      \end{array}
      \right]
\end{equation}
where $H_i$ is the sparse bi--linear interpolation matrix.

% WAVEFRONT LGS SAMPLING
\begin{figure}[htbp]
  \centering
  \begin{tikzpicture}
    \begin{scope}[xshift=-2.35cm]
    \draw[help lines] (-2,-2) grid (2,2);
\foreach \x in {0,1,...,4}
\foreach \y in {0,1,...,4}
{
\fill ($(\x,\y)-(2,2)$) circle (0.8mm);
}
\foreach \x in {0,1,...,3}
\foreach \y in {0,1,...,3}
{
\draw[red,thick] ($0.9*($(\x,\y)-(1.5,1.5)$)$) circle (1.2mm);
}
    \end{scope}
    \begin{scope}[xshift=2.35cm]
    \draw[help lines] (-2,-2) grid (2,2);
\foreach \x in {0,0.5,...,4}
\foreach \y in {0,0.5,...,4}
{
\fill ($(\x,\y)-(2,2)$) circle (0.8mm);
}
\foreach \x in {-1,-0.5,...,4}
\foreach \y in {-1,-0.5,...,4}
{
\fill[blue] ($0.9*($(\x,\y)-(1.5,1.5)$)$) circle (0.8mm);
\draw[blue,thick] ($0.9*($(\x,\y)-(1.5,1.5)$)$) circle (1.2mm);
}
\foreach \x in {0,1,...,3}
\foreach \y in {0,1,...,3}
{
\draw[red,thick] ($0.9*($(\x,\y)-(1.5,1.5)$)$) circle (1.2mm);
}
    \end{scope}
  \end{tikzpicture}
  \caption{Wavefront and LGS measurement sampling with a $4\times4$ lenslet array. The Fried geometry is on the left and the 2RBT geometry is on the right.}
  \label{fig:3}
\end{figure}

\subsubsection{Parameters}
\label{sec:parameters}

The parameters are defined in
<<parameters>>=
int *d__idx, PS_E_N_PX, N_guide_star, offset, NP, osf;
float *d__ce, *d__phase_est, *d__phase_est_i, *d__x;
aaStats aa;
BTBT aaCov;
paStats pa;
BTBT paCov;
iterativeSolvers iSolve;
stopwatch tid;

@
\subsubsection{Setup \& Cleanup}
\label{sec:setup--cleanup}

The setup method is initializing the required structures:
<<setup>>=
void LMMSE::setup(atmosphere *atm, source *guide_star, int _N_guide_star, source *mmse_star, int N_mmse_star,
		  float sampling,int N, char *solver_id)
{
  N_guide_star = _N_guide_star;
  aa.setup(N_SIDE_LENSLET,atm,sampling,guide_star, N_guide_star);
  aaCov.setup(2*N_guide_star,2*N_guide_star,N_SIDE_LENSLET,aa.d__cov);
  osf = 2;
  NP = osf*N_SIDE_LENSLET+1;
  PS_E_N_PX = NP;
  PS_E_N_PX *= PS_E_N_PX;
  pa.setup(N_SIDE_LENSLET,osf,atm,sampling,mmse_star, N_mmse_star, guide_star, N_guide_star);
  paCov.setup(N_mmse_star,2*N_guide_star,NP,pa.d__cov);
  if (strcmp(solver_id,"CG")==0)
    iSolve.cg_setup(N*N_guide_star);
  if (strcmp(solver_id,"MINRES")==0)
    iSolve.minres_setup(N*N_guide_star);
<<linear solver (prep.)>>
<<MVM (prep.)>>
HANDLE_ERROR( cudaMalloc((void**)&d__x, sizeof(float)* _N_LENSLET_*2*N_guide_star ) );
HANDLE_ERROR( cudaMemset(d__x, 0, sizeof(float)* _N_LENSLET_*2*N_guide_star ) );
}

<<setup (new)>>=
void LMMSE::new_setup(atmosphere *atm, source *guide_star, int _N_guide_star, source *mmse_star, int N_mmse_star,
		  float sampling,int N, char *solver_id)
{
  N_guide_star = _N_guide_star;

  aa.setup(N_SIDE_LENSLET,atm,sampling,guide_star, N_guide_star);
  aaCov.setup(2*N_guide_star,2*N_guide_star,N_SIDE_LENSLET,aa.d__cov);

  osf = 2;
  NP = osf*N_SIDE_LENSLET+1;
  NI = NP;
  offset = (int) ceilf( osf*N_SIDE_LENSLET*
			atm->turbulence.altitude[0]*0.5/guide_star[0].height );
  NP += offset*2;
  printf(" ==>> offset=%d - NP=%d\n",offset,NP);
  PS_E_N_PX = NP;
  PS_E_N_PX *= PS_E_N_PX;

  float mmse_star_height = mmse_star[0].height;
  mmse_star[0].height = guide_star[0].height;

  pa.setup(NP,1,atm,sampling/osf,mmse_star, N_mmse_star, guide_star, N_guide_star);
  paCov.setup(N_mmse_star,2*N_guide_star,NP,pa.d__cov);

  mmse_star[0].height = mmse_star_height;

  if (strcmp(solver_id,"CG")==0)
    iSolve.cg_setup(N*N_guide_star);
  if (strcmp(solver_id,"MINRES")==0)
    iSolve.minres_setup(N*N_guide_star);

  <<linear solver (prep.)>>
  <<MVM (prep.)>>
  HANDLE_ERROR( cudaMalloc((void**)&d__x, sizeof(float)* _N_LENSLET_*2*N_guide_star ) );
  HANDLE_ERROR( cudaMemset(d__x, 0, sizeof(float)* _N_LENSLET_*2*N_guide_star ) );

  <<sparse setup>>
}
<<setup (rect)>>=
void LMMSE::fried_setup(atmosphere *atm, source *guide_star, int _N_guide_star, 
                        source *mmse_star, int N_mmse_star,
		       float sampling,int N, char *solver_id)
{
  N_guide_star = _N_guide_star;
  aa.setup(N_SIDE_LENSLET,atm,sampling,guide_star, N_guide_star);
  aaCov.setup(2*N_guide_star,2*N_guide_star,N_SIDE_LENSLET,aa.d__cov);

  osf = 1;
  NP = osf*N_SIDE_LENSLET+1;
  NI = NP;

   if (mmse_star[0].height==guide_star[0].height) {

  offset = 1;
  printf(" ==>> offset=%d - NP=%d\n",offset,NP);
  PS_E_N_PX = NP;
  PS_E_N_PX *= PS_E_N_PX;

  float mmse_star_height = mmse_star[0].height;
  mmse_star[0].height = guide_star[0].height;

  pa.setup(NP,N_SIDE_LENSLET,osf,atm,sampling,
           mmse_star, N_mmse_star, guide_star, N_guide_star);
  paCov.setup(N_mmse_star,2*N_guide_star,NP,N_SIDE_LENSLET,pa.d__cov);

  mmse_star[0].height = mmse_star_height;
 
} else {
 


  source clone_mmse_star;
  clone_mmse_star.setup(mmse_star[0].zenith,mmse_star[0].azimuth,guide_star[0].height);

  pa.setup_multilayers(NP,N_SIDE_LENSLET,osf,atm,sampling,
           &clone_mmse_star, N_mmse_star, guide_star, N_guide_star);

  clone_mmse_star.cleanup();

  float g;
  g = 1 - atm->turbulence.altitude[0]/guide_star[0].height;
  offset = (int) ceilf( osf*0.5*N_SIDE_LENSLET*(1-g)/g );
  NP += offset*2;

  offset += 1;

  printf("@(CEO)>LMMSE: offset=%d - NP=%d\n",offset,NP);
//  PS_E_N_PX *= PS_E_N_PX;

  paCov.setup(N_mmse_star*_N_LAYER_,2*N_guide_star,pa.M_LAYER,N_SIDE_LENSLET,pa.d__cov);

  PS_E_N_PX = paCov.MT2_TOTAL;

  <<sparse setup>>
}

  if (strcmp(solver_id,"CG")==0)
    iSolve.cg_setup(N*N_guide_star);
  if (strcmp(solver_id,"MINRES")==0)
    iSolve.minres_setup(N*N_guide_star);

<<linear solver (prep.)>>
<<MVM (prep.)>>
HANDLE_ERROR( cudaMalloc((void**)&d__x, sizeof(float)* _N_LENSLET_*2*N_guide_star ) );
HANDLE_ERROR( cudaMemset(d__x, 0, sizeof(float)* _N_LENSLET_*2*N_guide_star ) );
}
@
Memory is freed with
<<cleanup>>= 
void LMMSE::cleanup(void)
{
  fprintf(stderr,"@(CEO)>LMMSE: freeing memory!\n");

  aa.cleanup();
  pa.cleanup();
  aaCov.cleanup();
  paCov.cleanup();
  iSolve.cleanup();

  HANDLE_ERROR( cudaFree( d__idx ) );
  HANDLE_ERROR( cudaFree( d__ce ) );
  HANDLE_ERROR( cudaFree( d__phase_est ) );
  HANDLE_ERROR( cudaFree(d__x) );
}
<<cleanup (new)>>= 
void LMMSE::new_cleanup(void)
{
  fprintf(stderr,"@(CEO)>LMMSE: freeing memory!\n");

  aa.cleanup();
  pa.cleanup();
  aaCov.cleanup();
  paCov.cleanup();
  iSolve.cleanup();

  HANDLE_ERROR( cudaFree( d__idx ) );
  HANDLE_ERROR( cudaFree( d__ce ) );
  HANDLE_ERROR( cudaFree( d__phase_est ) );
  HANDLE_ERROR( cudaFree(d__x) );

  <<sparse cleanup>>
}
@
\subsubsection{Wavefront estimation}

<<PA input>>=
__global__ void set_pa_input(float *pa_c, float *aa_c, int *idx, int N) 
{
  int i, j, k;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  if ( (i<N) && (j<N) ) {
    k = i*N + j;
    pa_c[idx[k]] = aa_c[k];
  }
}
<<PA input with sizes>>=
__global__ void set_pa_input(float *pa_c, float *aa_c, int N, int offset) 
{
  int i, j, k, ii, jj, idx;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  if ( (i<N) && (j<N) ) {
    ii  = 2*i + 1 + offset;
    jj  = 2*j + 1 + offset;
    idx = ii*(2*N + 1 + 2*offset) + jj;
    k   = i*N + j;
    pa_c[idx] = aa_c[k];
  }
}
@ 
<<wavefront estimation (I)>>=
  void LMMSE::estimation(float* d__c, int nMaxIteration, float *d__x0)
{

tid.tic();

iSolve.minres_vorst(d__x, &aaCov, d__c, nMaxIteration, d__x0);

<<MVM>>

tid.toc("WAVEFRONT ESTIMATION");


printf("\nSolver residue norm           : %.2E\n",iSolve.rnorm);
printf("\nSolver mean time per iteration: %.2E\n",iSolve.mean_time_per_iteration);
}

<<wavefront estimation (II)>>=
  void LMMSE::estimation(float* d__c, int nMaxIteration)
{

tid.tic();

iSolve.minres_vorst(d__x, &aaCov, d__c, nMaxIteration, d__x);

tid.toc("WAVEFRONT ESTIMATION (MINRES)");

tid.tic();

<<MVM>>

tid.toc("WAVEFRONT ESTIMATION (PA MVM)");


printf("\nSolver residue norm           : %.2E\n",iSolve.rnorm);
//printf("\nSolver mean time per iteration: %.2E\n",iSolve.mean_time_per_iteration);
}

<<wavefront estimation (III)>>=
void LMMSE::new_estimation(float* d__c, int nMaxIteration)
{

tid.tic();

iSolve.minres_vorst(d__x, &aaCov, d__c, nMaxIteration, d__x);

dim3 blockDim(16,16);
dim3 gridDim(N_SIDE_LENSLET/16+1,N_SIDE_LENSLET/16+1);
for (int k_guide_star=0;k_guide_star<N_guide_star;k_guide_star++) {
  set_pa_input LLL gridDim,blockDim RRR (d__ce + 2*k_guide_star*PS_E_N_PX,
					 d__x + 2*k_guide_star*_N_LENSLET_,    
                                          N_SIDE_LENSLET, offset);
  set_pa_input LLL gridDim,blockDim RRR (d__ce + (2*k_guide_star+1)*PS_E_N_PX,
					 d__x + (2*k_guide_star+1)*_N_LENSLET_,
                                         N_SIDE_LENSLET, offset);
 }

tid.toc("WAVEFRONT ESTIMATION (MINRES)");

/*
dev2file("ce.bin",d__ce,PS_E_N_PX*2);
pa.toFile("paCovarianceAltLmmse.bin");
*/

float alpha, beta;
alpha = 1;
beta  = 0;

tid.tic();

paCov.MVM(d__phase_est,d__ce);

HANDLE_ERROR_CUSPARSE( cusparseScsrmv(handle, CUSPARSE_OPERATION_NON_TRANSPOSE,
				      NI*NI, NP*NP, nnz, &alpha,
				      descr, csrValH, csrRowPtrH, csrColIndH,
				      d__phase_est, &beta, d__phase_est_i),
		       "Sparse to vector product failed!");

tid.toc("WAVEFRONT ESTIMATION (PA MVM)");

printf("\nSolver residue norm           : %.2E\n",iSolve.rnorm);
//printf("\nSolver mean time per iteration: %.2E\n",iSolve.mean_time_per_iteration);
}

<<wavefront estimation (IV)>>=
void LMMSE::fried_estimation(float* d__c, int nMaxIteration)
{

tid.tic();

iSolve.minres_vorst(d__x, &aaCov, d__c, nMaxIteration, d__x);

tid.toc("WAVEFRONT ESTIMATION (MINRES)");

/*
dev2file("ce.bin",d__ce,PS_E_N_PX*2);
pa.toFile("paCovarianceAltLmmse.bin");
*/

tid.tic();

paCov.MVM(d__phase_est,d__x);

tid.toc("WAVEFRONT ESTIMATION (PA MVM)");

printf("\nSolver residue norm           : %.2E\n",iSolve.rnorm);
//printf("\nSolver mean time per iteration: %.2E\n",iSolve.mean_time_per_iteration);
}

<<wavefront estimation (V)>>=
void LMMSE::fried_sparse_estimation(float* d__c, int nMaxIteration)
{

tid.tic();

iSolve.minres_vorst(d__x, &aaCov, d__c, nMaxIteration, d__x);

tid.toc("WAVEFRONT ESTIMATION (MINRES)");

float alpha, beta;
alpha = 1;
beta  = 0;

/*
dev2file("ce.bin",d__ce,PS_E_N_PX*2);
pa.toFile("paCovarianceAltLmmse.bin");
*/

tid.tic();

paCov.MVM(d__phase_est,d__x);

HANDLE_ERROR_CUSPARSE( cusparseScsrmv(handle, CUSPARSE_OPERATION_NON_TRANSPOSE,
				      NI*NI, NP*NP, nnz, &alpha,
				      descr, csrValH, csrRowPtrH, csrColIndH,
				      d__phase_est, &beta, d__phase_est_i),
		       "Sparse to vector product failed!");

tid.toc("WAVEFRONT ESTIMATION (PA MVM)");

printf("\nSolver residue norm           : %.2E\n",iSolve.rnorm);
//printf("\nSolver mean time per iteration: %.2E\n",iSolve.mean_time_per_iteration);
}
@ 
<<linear solver (prep.)>>=
  int *idx, i, j , k;
idx = (int *)malloc(sizeof(int)*_N_LENSLET_);
k = -1;
for (i=1;i<2*N_SIDE_LENSLET;i+=2) {
  for (j=1;j<2*N_SIDE_LENSLET;j+=2) {
    idx[++k] = i*(2*N_SIDE_LENSLET + 1) + j;
  }
 }
HANDLE_ERROR( cudaMalloc( (void**)&d__idx, sizeof(int)*_N_LENSLET_ ) );
HANDLE_ERROR( cudaMemcpy( d__idx, idx,
			  sizeof(int)*_N_LENSLET_,
			  cudaMemcpyHostToDevice ) );
free(idx);

<<MVM (prep.)>>=
HANDLE_ERROR( cudaMalloc((void**)&d__ce, sizeof(float)*PS_E_N_PX*2*N_guide_star ) );
HANDLE_ERROR( cudaMemset(d__ce, 0, sizeof(float)*PS_E_N_PX*2*N_guide_star ) );
HANDLE_ERROR( cudaMalloc( (void**)&d__phase_est           , sizeof(float)*PS_E_N_PX ) );

<<MVM>>=
dim3 blockDim(16,16);
dim3 gridDim(N_SIDE_LENSLET/16+1,N_SIDE_LENSLET/16+1);
for (int k_guide_star=0;k_guide_star<N_guide_star;k_guide_star++) {
  set_pa_input LLL gridDim,blockDim RRR (d__ce + 2*k_guide_star*PS_E_N_PX,
					 d__x + 2*k_guide_star*_N_LENSLET_,     d__idx, N_SIDE_LENSLET);
  set_pa_input LLL gridDim,blockDim RRR (d__ce + (2*k_guide_star+1)*PS_E_N_PX,
					 d__x + (2*k_guide_star+1)*_N_LENSLET_, d__idx, N_SIDE_LENSLET);
 }
paCov.MVM(d__phase_est,d__ce);

@ 

\subsubsection{Sparse bi--linear interpolation}
\label{sec:sparse-bi-linear}

A wavefront $\hat\varphi$ is sampled on a $N_p\times N_p$ square grid with sampling step $\delta_p$.
The wavefront $\varphi_{bli}$, sampled on a square grid $N\times N$ with sampling step $\delta$ is derived from a bi--linear interpolation of $\hat\varphi$.
The coordinates of $\hat\varphi$ samples are given by
\begin{equation}
  \label{eq:9}
  \left(
    \begin{array}{c}
      x_{i_p} \\
      y_{j_p}
    \end{array}
  \right) = \delta_p \left[ \left(
    \begin{array}{c}
      i_p \\
      j_p
    \end{array}
    \right) + {1-N_p \over 2} \right], \forall i,j \in [0,\dots,N_p-1]
\end{equation}
and the samples of $\varphi_{bli}$ are located at
\begin{equation}
  \label{eq:10}
  \left(
    \begin{array}{c}
      x_i \\
      y_j
    \end{array}
  \right) = \delta \left[ \left(
    \begin{array}{c}
      i \\
      j
    \end{array}
    \right) + {1-N \over 2} \right], \forall i,j \in [0,\dots,N-1]  
\end{equation}

@ The interpolation starts with normalizing the coordinates $(x_i,y_j)$ with respect to the coordinates $(x_{i_p},y_{j_p})$
<<bilinear interpolation>>=
scale = delta/(delta_p*(NP-1));
s = (scale*(i + (1-NI)/2) + 0.5)*(NP-1);
t = (scale*(j + (1-NI)/2) + 0.5)*(NP-1);
@  and taking the floor integer part to locate the bottom--left coordinate of the pixels surrounding [[xi]] and [[yi]]
<<bilinear interpolation>>=
fs  = floorf(s);
ft  = floorf(t);
ndx = __float2int_rd( ft + fs*NP );
@ Next, one checks if the edges of the array have been reached
<<bilinear interpolation>>=
if (s==(NP-1)) { s += 1 - fs; ndx -= NP; } else { s -= fs; }    
if (t==(NP-1)) { t += 1 - ft; ndx -= 1; }   else { t -= ft; }
@ and finally the interpolation is computed as
<<bilinear interpolation>>=	 
k = i*NI + j + k_LAYER*NI*NI;
idx = 4*k - 1;
onems = 1 - s;
onemt = 1 - t;
csrValH[++idx]  = onems*onemt;
csrColIndH[idx] = ndx;
csrValH[++idx]  = onems*t;
csrColIndH[idx] = ndx + 1;
csrValH[++idx]  = s*onemt;
csrColIndH[idx] = ndx + NP;
csrValH[++idx]  = s*t;
csrColIndH[idx] = ndx + NP + 1;
csrRowPtrH[k+1] = 4*(k+1);

@ The sparse matrix is stored in the compressed sparse row format and it is computed with the kernel
<<sparse matrix kernel>>=
__global__ void bilinearSparseOperator(float *csrValH, int *csrColIndH, int *csrRowPtrH,
				  int* MT, int NI, profile *turb, float z)
{
  int i, j, k, idx, ndx, NP, k_LAYER;
  float scale, s, t, fs, ft, onemt, onems, delta, delta_p;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  k_LAYER = blockIdx.z;
  if ( (i<NI) && (j<(NI)) ) {
    delta   = 1.0;
    delta_p = 1 - turb->altitude[k_LAYER]/z;
    NP = MT[k_LAYER];
    <<bilinear interpolation>>
  }
}
@ Lets define new parameters for the sparse matrix:
<<parameters>>=
int nnz, NI;
float *csrValH;
int *csrColIndH, *csrRowPtrH;
cudaError_t cudaStat;
cusparseStatus_t status;
cusparseHandle_t handle;
cusparseMatDescr_t descr;
@ and they are setup with:
<<sparse setup>>=
HANDLE_ERROR_CUSPARSE( cusparseCreate(&handle), 
		       "CUSPARSE Library initialization failed!");
HANDLE_ERROR_CUSPARSE( cusparseCreateMatDescr(&descr), 
		       "Matrix descriptor initialization failed!");

cusparseSetMatType(descr,CUSPARSE_MATRIX_TYPE_GENERAL);
cusparseSetMatIndexBase(descr,CUSPARSE_INDEX_BASE_ZERO);

nnz = 4*NI*NI*_N_LAYER_;
HANDLE_ERROR( cudaMalloc((void**)&csrValH,    sizeof(float)*nnz ) );
HANDLE_ERROR( cudaMalloc((void**)&csrColIndH, sizeof(int)*nnz ) );
HANDLE_ERROR( cudaMalloc((void**)&csrRowPtrH, sizeof(int)*(NI*NI+1) ) );
HANDLE_ERROR( cudaMemset(csrRowPtrH, 0, sizeof(int)*(NI*NI+1) ) );

dim3 blockDim(16,16);
dim3 gridDim(NI/16+1,NI/16+1,_N_LAYER_);
bilinearSparseOperator LLL gridDim,blockDim RRR 
  (csrValH, csrColIndH, csrRowPtrH, paCov.d__MT, NI, atm->d__turbulence, guide_star[0].height);

// For debugging purposes:
/* 
dev2file("csrValH.bin",csrValH,nnz);
dev2file("csrColIndH.bin",csrColIndH,nnz);
dev2file("csrRowPtrH.bin",csrRowPtrH,NI*NI+1);

float *H;
HANDLE_ERROR( cudaMalloc( (void**)&H, sizeof(float)*NI*NI*NP*NP ) );
HANDLE_ERROR_CUSPARSE(cusparseScsr2dense(handle, NI*NI, NP*NP, descr, 
					 csrValH, csrRowPtrH, csrColIndH,
					 H, NI*NI),
		      "Sparse to dense conversion failed!");
dev2file("H.bin",H,NI*NI*NP*NP);
HANDLE_ERROR( cudaFree( H ) );
*/

HANDLE_ERROR( cudaMalloc( (void**)&d__phase_est_i, sizeof(float)*NI*NI ) );

@ and then cleanup with:
<<sparse cleanup>>=
HANDLE_ERROR_CUSPARSE( cusparseDestroyMatDescr(descr),
		       "Matrix descriptor destruction failed!");
HANDLE_ERROR_CUSPARSE( cusparseDestroy(handle),
		       "CUSPARSE Library release of resources failed!");
HANDLE_ERROR( cudaFree( csrValH ) );
HANDLE_ERROR( cudaFree( csrColIndH ) );
HANDLE_ERROR( cudaFree( csrRowPtrH ) );
HANDLE_ERROR( cudaFree( d__phase_est_i ) );
@
\subsubsection{Tests}
\label{sec:tests}


The test routine is:
<<LMMSE.bin>>=
#ifndef __CEO_H__
#include "ceo.h"
#endif
#ifndef __SOURCE_H__
#include "source.h"
#endif
#ifndef __ATMOSPHERE_H__
#include "atmosphere.h"
#endif
#ifndef __IMAGING_H__
#include "imaging.h"
#endif
#ifndef __CENTROIDING_H__
#include "centroiding.h"
#endif
#ifndef __AASTATS_H__
#include "aaStats.h"
#endif
#ifndef __BTBT_H__
#include "BTBT.h"
#endif
#include "LMMSE.h"


__global__ void fill(float *data, int n_data, float value)
{
  int k = blockIdx.x * blockDim.x + threadIdx.x;
  if (k<n_data)
    data[k] = value;
}

// Solving Ax=b
int main( void) {

  
<<complete test>>
}
@
A more complete test:
<<complete test>>=
int N = _N_LENSLET_*2, NP, PS_N_PX, PS_E_N_PX, i, j ,k, osf;
float *d__x, *d__b, *b, *d__ce, *d__phase_est, *phase_screen_est, *x;
float D, d, delta, delta_e, wf_rms, phase2nm, slopes2Angle, cxy0;
int *idx, *d__idx;

D = 8;
d = D/N_SIDE_LENSLET;
delta = d/_N_PX_PUPIL_;
osf = 2;
delta_e = d/osf;

NP = osf*N_SIDE_LENSLET+1;
PS_E_N_PX = NP;
PS_E_N_PX *= PS_E_N_PX;
PS_N_PX = N_SIDE_LENSLET*_N_PX_PUPIL_;

printf("\nd    =%.4f\n",d);
printf("\ndelta=%.4f\n",delta);
printf("\ndelta_e=%.4f\n",delta_e);

source src, *d__src;
atmosphere atm;
imaging lenslet_array;
centroiding cog;
LMMSE E;
stats S;
S.setup();
stopwatch tid;

src.setup(ARCSEC(0) , 0, INFINITY);
HANDLE_ERROR( cudaMalloc( (void**)&d__src, sizeof(source)*_N_SOURCE_ ) );
HANDLE_ERROR( cudaMemcpy( d__src, &src,
			  sizeof(source)*_N_SOURCE_ ,
			  cudaMemcpyHostToDevice ) );
        
// Single layer turbulence profile
float altitude[] = {0},
  xi0[] = {1},
  wind_speed[] = {10},
  wind_direction[] = {0};
// Atmosphere
atm.setup(0.15,30,altitude,xi0,wind_speed,wind_direction);
//atm.reset();

phase2nm = 1E9*atm.wavelength/2/PI;
slopes2Angle = (atm.wavelength/2/d);

// SH WFS
lenslet_array.setup();

// Centroid
cog.setup();

// LMMSE
E.setup(&atm,N_SIDE_LENSLET,d,"MINRES");

atm.get_phase_screen(delta,PS_N_PX,delta,PS_N_PX,d__src,0);

wf_rms = phase2nm*S.std(d__src->phase, _N_PIXEL_);
printf("\n WF RMS: %7.2fnm\n",wf_rms);

float phase_screen[_N_PIXEL_];
HANDLE_ERROR( cudaMemcpy( phase_screen, d__src->phase,
			  sizeof(float)*_N_PIXEL_,
			  cudaMemcpyDeviceToHost ) );
FILE *fid;
fid = fopen("phaseScreen.bin","wb");
fwrite(phase_screen,sizeof(float),_N_PIXEL_,fid);
fclose(fid);

float *d__phase_screen_low_res;
HANDLE_ERROR( cudaMalloc( (void**)&d__phase_screen_low_res, sizeof(float)*PS_E_N_PX ) );
atm.get_phase_screen(d__phase_screen_low_res,delta_e,NP,delta_e,NP,d__src,0);

float *phase_screen_low_res;
phase_screen_low_res = (float*)malloc(sizeof(float)*PS_E_N_PX);
HANDLE_ERROR( cudaMemcpy( phase_screen_low_res, d__phase_screen_low_res,
			  sizeof(float)*PS_E_N_PX,
			  cudaMemcpyDeviceToHost ) );
fid = fopen("phaseScreenLowRes.bin","wb");
fwrite(phase_screen_low_res,sizeof(float),PS_E_N_PX,fid);
fclose(fid);

<<wavefront sensing>>

HANDLE_ERROR( cudaMalloc((void**)&d__x, sizeof(float)*N ) );

char filename[100];
/* for (k=1;k<6;k++) { */
k = 20;
sprintf(filename,"MINRES_phaseEst_%d.bin",k);
HANDLE_ERROR( cudaMemset(d__x, 0, sizeof(float)*N ) );

tid.tic();

E.estimation(cog.d__c,k,d__x);

tid.toc("WAVEFRONT ESTIMATION");

<<MVM (wrap.)>>

/* printf("\nSolver residue norm           : %.2E\n",iSolve.rnorm); */
/* printf("\nSolver mean time per iteration: %.2E\n",iSolve.mean_time_per_iteration); */

/* } */

HANDLE_ERROR( cudaFree( d__src) );
atm.cleanup();
lenslet_array.cleanup();
cog.cleanup();
E.cleanup();
S.cleanup();
HANDLE_ERROR( cudaFree( d__x ) );
HANDLE_ERROR( cudaFree( d__phase_screen_low_res ) );
free(phase_screen_low_res);
//free(b);
//free(phase_screen_est);
//free(x);
@ 
<<wavefront sensing>>=
lenslet_array.propagate(d__src);
cxy0 = (_N_PX_PUPIL_ - 1)/2.0;
cog.get_data(lenslet_array.d__frame, cxy0, cxy0, slopes2Angle);
HANDLE_ERROR( cudaMalloc((void**)&d__b, sizeof(float)*N ) );
HANDLE_ERROR( cudaMemcpy( d__b              , cog.d__cx,  
			  _N_LENSLET_*sizeof(float), cudaMemcpyDeviceToDevice) );
HANDLE_ERROR( cudaMemcpy( d__b + _N_LENSLET_, cog.d__cy,  
			  _N_LENSLET_*sizeof(float), cudaMemcpyDeviceToDevice) );
b = (float *)malloc(sizeof(float)*N);
HANDLE_ERROR( cudaMemcpy( b, d__b,
			  sizeof(float)*N,
			  cudaMemcpyDeviceToHost ) );
/* printf("\n   Cx       Cy\n"); */
/* for (k=0;k<_N_LENSLET_;k++) { */
/*   printf("%+6.4E  %+6.4E\n",b[k],b[k+_N_LENSLET_]); */
/* } */
fid = fopen("centroids.bin","wb");
fwrite(b,sizeof(float),N,fid);
fclose(fid);
@ 
<<MVM (wrap.)>>=
phase_screen_est     = (float*)malloc(sizeof(float)*PS_E_N_PX);
HANDLE_ERROR( cudaMemcpy( phase_screen_est, E.d__phase_est,
			  sizeof(float)*PS_E_N_PX,
			  cudaMemcpyDeviceToHost ) );
fid = fopen(filename,"wb");
//fid = fopen("phaseScreenEst.bin","wb");
fwrite(phase_screen_est,sizeof(float),PS_E_N_PX,fid);
fclose(fid);
