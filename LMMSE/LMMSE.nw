% -*- mode: Noweb; noweb-code-mode: c-mode -*-
@
\subsection{The files}

\subsubsection{Header}

<<LMMSE.h>>=
#ifndef __LMMSE_H__
#define __LMMSE_H__

#ifndef __CEO_H__
#include "ceo.h"
#endif

#ifndef __AASTATS_H__
#include "aaStats.h"
#endif

#ifndef __BTBT_H__
#include "BTBT.h"
#endif

#ifndef __ITERATIVESOLVERS_H__
#include "iterativeSolvers.h"
#endif

//#define MINRES_DEBUG

struct LMMSE {

  <<parameters>>

  void setup(atmosphere *atm,float sampling, int N, char *solver_id);
  void setup(atmosphere *atm, float source_height,float sampling, int N, char *solver_id);
  void setup(atmosphere *atm, source *guide_star, int N_guide_star, source *mmse_star, int N_mmse_star,
	     float sampling, int N, char *solver_id);

  void cleanup(void);

  void estimation(float* d__c, int nMaxIteration, float *d__x0);
  void estimation(float* d__c, int nMaxIteration);

};
#endif // __LMMSE_H__
@
\subsubsection{Source}

<<LMMSE.cu>>=
#ifndef __LMMSE_H__
#include "LMMSE.h"
#endif

<<PA input>>

<<setup>>
<<setup with source height>>
<<setup with sources>>

<<cleanup>>

  <<wavefront estimation (I)>>
  <<wavefront estimation (II)>>

@
The LMMSE structure gather several routines implementing iterative methods to reconstruct the wavefront from Shack--Hartmann wavefront sensor data.
The setup method is initializing the required structures:
<<setup>>=
void LMMSE::setup(atmosphere *atm,float sampling,int N, char *solver_id)
{
  int NP, osf;
  N_guide_star = 1;
  aa.setup(N_SIDE_LENSLET,atm,sampling);
  aaCov.setup(2,2,N_SIDE_LENSLET,aa.d__cov);
  osf = 2;
  NP = osf*N_SIDE_LENSLET+1;
  PS_E_N_PX = NP;
  PS_E_N_PX *= PS_E_N_PX;
  pa.setup(N_SIDE_LENSLET,osf,atm,sampling);
  paCov.setup(1,2,NP,pa.d__cov);
  if (strcmp(solver_id,"CG")==0)
    iSolve.cg_setup(N);
  if (strcmp(solver_id,"MINRES")==0)
    iSolve.minres_setup(N);
<<linear solver (prep.)>>
<<MVM (prep.)>>
HANDLE_ERROR( cudaMalloc((void**)&d__x, sizeof(float)* _N_LENSLET_*2 ) );
HANDLE_ERROR( cudaMemset(d__x, 0, sizeof(float)* _N_LENSLET_*2 ) );
}
<<setup with sources>>=
void LMMSE::setup(atmosphere *atm, source *guide_star, int _N_guide_star, source *mmse_star, int N_mmse_star,
		  float sampling,int N, char *solver_id)
{
  int NP, osf;
  N_guide_star = _N_guide_star;
  aa.setup(N_SIDE_LENSLET,atm,sampling,guide_star, N_guide_star);
  aaCov.setup(2*N_guide_star,2*N_guide_star,N_SIDE_LENSLET,aa.d__cov);
  osf = 2;
  NP = osf*N_SIDE_LENSLET+1;
  PS_E_N_PX = NP;
  PS_E_N_PX *= PS_E_N_PX;
  pa.setup(N_SIDE_LENSLET,osf,atm,sampling,mmse_star, N_mmse_star, guide_star, N_guide_star);
  paCov.setup(N_mmse_star,2*N_guide_star,NP,pa.d__cov);
  if (strcmp(solver_id,"CG")==0)
    iSolve.cg_setup(N*N_guide_star);
  if (strcmp(solver_id,"MINRES")==0)
    iSolve.minres_setup(N*N_guide_star);
<<linear solver (prep.)>>
<<MVM (prep.)>>
HANDLE_ERROR( cudaMalloc((void**)&d__x, sizeof(float)* _N_LENSLET_*2*N_guide_star ) );
HANDLE_ERROR( cudaMemset(d__x, 0, sizeof(float)* _N_LENSLET_*2*N_guide_star ) );
}
<<setup with source height>>=
void LMMSE::setup(atmosphere *atm, float source_height,float sampling,int N, char *solver_id)
{
  int NP, osf;
  N_guide_star = 1;
  aa.setup(N_SIDE_LENSLET,atm,sampling,source_height);
  aaCov.setup(2,2,N_SIDE_LENSLET,aa.d__cov);
  osf = 2;
  NP = osf*N_SIDE_LENSLET+1;
  PS_E_N_PX = NP;
  PS_E_N_PX *= PS_E_N_PX;
  pa.setup(N_SIDE_LENSLET,osf,atm,sampling,source_height);
  paCov.setup(1,2,NP,pa.d__cov);
  if (strcmp(solver_id,"CG")==0)
    iSolve.cg_setup(N);
  if (strcmp(solver_id,"MINRES")==0)
    iSolve.minres_setup(N);
<<linear solver (prep.)>>
<<MVM (prep.)>>
HANDLE_ERROR( cudaMalloc((void**)&d__x, sizeof(float)* _N_LENSLET_*2 ) );
HANDLE_ERROR( cudaMemset(d__x, 0, sizeof(float)* _N_LENSLET_*2 ) );
}
@ 
The structure parameters are
<<parameters>>=
  int *d__idx, PS_E_N_PX, N_guide_star;
float *d__ce, *d__phase_est, *d__x;
aaStats aa;
BTBT aaCov;
paStats pa;
BTBT paCov;
iterativeSolvers iSolve;
stopwatch tid;
@
Memory is freed with
<<cleanup>>= 
void LMMSE::cleanup(void)
{
  fprintf(stderr,"@(CEO)>LMMSE: freeing memory!\n");
  aa.cleanup();
  pa.cleanup();
  aaCov.cleanup();
  paCov.cleanup();
  iSolve.cleanup();
  HANDLE_ERROR( cudaFree( d__idx ) );
  HANDLE_ERROR( cudaFree( d__ce ) );
  HANDLE_ERROR( cudaFree( d__phase_est ) );
  HANDLE_ERROR( cudaFree(d__x) );
}
@ 
<<PA input>>=
__global__ void set_pa_input(float *pa_c, float *aa_c, int *idx, int N) 
{
  int i, j, k;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  if ( (i<N) && (j<N) ) {
    k = i*N + j;
    pa_c[idx[k]] = aa_c[k];
  }
}
@ 
<<wavefront estimation (I)>>=
  void LMMSE::estimation(float* d__c, int nMaxIteration, float *d__x0)
{

tid.tic();

iSolve.minres_vorst(d__x, &aaCov, d__c, nMaxIteration, d__x0);

<<MVM>>

tid.toc("WAVEFRONT ESTIMATION");


printf("\nSolver residue norm           : %.2E\n",iSolve.rnorm);
printf("\nSolver mean time per iteration: %.2E\n",iSolve.mean_time_per_iteration);
}
<<wavefront estimation (II)>>=
  void LMMSE::estimation(float* d__c, int nMaxIteration)
{

tid.tic();

iSolve.minres_vorst(d__x, &aaCov, d__c, nMaxIteration, d__x);

<<MVM>>

tid.toc("WAVEFRONT ESTIMATION");


printf("\nSolver residue norm           : %.2E\n",iSolve.rnorm);
printf("\nSolver mean time per iteration: %.2E\n",iSolve.mean_time_per_iteration);
}
@ 
<<linear solver (prep.)>>=
  int *idx, i, j , k;
idx = (int *)malloc(sizeof(int)*_N_LENSLET_);
k = -1;
for (i=1;i<2*N_SIDE_LENSLET;i+=2) {
  for (j=1;j<2*N_SIDE_LENSLET;j+=2) {
    idx[++k] = i*(2*N_SIDE_LENSLET + 1) + j;
  }
 }
HANDLE_ERROR( cudaMalloc( (void**)&d__idx, sizeof(int)*_N_LENSLET_ ) );
HANDLE_ERROR( cudaMemcpy( d__idx, idx,
			  sizeof(int)*_N_LENSLET_,
			  cudaMemcpyHostToDevice ) );
free(idx);

<<MVM (prep.) (old)>>=
HANDLE_ERROR( cudaMalloc((void**)&d__ce, sizeof(float)*PS_E_N_PX*2 ) );
HANDLE_ERROR( cudaMemset(d__ce, 0, sizeof(float)*PS_E_N_PX*2 ) );
HANDLE_ERROR( cudaMalloc( (void**)&d__phase_est           , sizeof(float)*PS_E_N_PX ) );

<<MVM (prep.)>>=
HANDLE_ERROR( cudaMalloc((void**)&d__ce, sizeof(float)*PS_E_N_PX*2*N_guide_star ) );
HANDLE_ERROR( cudaMemset(d__ce, 0, sizeof(float)*PS_E_N_PX*2*N_guide_star ) );
HANDLE_ERROR( cudaMalloc( (void**)&d__phase_est           , sizeof(float)*PS_E_N_PX ) );

<<MVM (old)>>=
dim3 blockDim(16,16);
dim3 gridDim(N_SIDE_LENSLET/16+1,N_SIDE_LENSLET/16+1);
set_pa_input LLL gridDim,blockDim RRR (d__ce, d__x, d__idx, N_SIDE_LENSLET);
set_pa_input LLL gridDim,blockDim RRR (d__ce + PS_E_N_PX, d__x + _N_LENSLET_, d__idx, N_SIDE_LENSLET);
paCov.MVM(d__phase_est,d__ce);

<<MVM>>=
dim3 blockDim(16,16);
dim3 gridDim(N_SIDE_LENSLET/16+1,N_SIDE_LENSLET/16+1);
for (int k_guide_star=0;k_guide_star<N_guide_star;k_guide_star++) {
  set_pa_input LLL gridDim,blockDim RRR (d__ce + 2*k_guide_star*PS_E_N_PX,
					 d__x + 2*k_guide_star*_N_LENSLET_,     d__idx, N_SIDE_LENSLET);
  set_pa_input LLL gridDim,blockDim RRR (d__ce + (2*k_guide_star+1)*PS_E_N_PX,
					 d__x + (2*k_guide_star+1)*_N_LENSLET_, d__idx, N_SIDE_LENSLET);
 }
paCov.MVM(d__phase_est,d__ce);

@
The test routine is:
<<LMMSE.bin>>=
#ifndef __CEO_H__
#include "ceo.h"
#endif
#ifndef __SOURCE_H__
#include "source.h"
#endif
#ifndef __ATMOSPHERE_H__
#include "atmosphere.h"
#endif
#ifndef __IMAGING_H__
#include "imaging.h"
#endif
#ifndef __CENTROIDING_H__
#include "centroiding.h"
#endif
#ifndef __AASTATS_H__
#include "aaStats.h"
#endif
#ifndef __BTBT_H__
#include "BTBT.h"
#endif
#include "LMMSE.h"


__global__ void fill(float *data, int n_data, float value)
{
  int k = blockIdx.x * blockDim.x + threadIdx.x;
  if (k<n_data)
    data[k] = value;
}

// Solving Ax=b
int main( void) {

  
<<complete test>>
}
@
A more complete test:
<<complete test>>=
int N = _N_LENSLET_*2, NP, PS_N_PX, PS_E_N_PX, i, j ,k, osf;
float *d__x, *d__b, *b, *d__ce, *d__phase_est, *phase_screen_est, *x;
float D, d, delta, delta_e, wf_rms, phase2nm, slopes2Angle, cxy0;
int *idx, *d__idx;

D = 8;
d = D/N_SIDE_LENSLET;
delta = d/_N_PX_PUPIL_;
osf = 2;
delta_e = d/osf;

NP = osf*N_SIDE_LENSLET+1;
PS_E_N_PX = NP;
PS_E_N_PX *= PS_E_N_PX;
PS_N_PX = N_SIDE_LENSLET*_N_PX_PUPIL_;

printf("\nd    =%.4f\n",d);
printf("\ndelta=%.4f\n",delta);
printf("\ndelta_e=%.4f\n",delta_e);

source src, *d__src;
atmosphere atm;
imaging lenslet_array;
centroiding cog;
LMMSE E;
stats S;
S.setup();
stopwatch tid;

src.setup(ARCSEC(0) , 0, INFINITY);
HANDLE_ERROR( cudaMalloc( (void**)&d__src, sizeof(source)*_N_SOURCE_ ) );
HANDLE_ERROR( cudaMemcpy( d__src, &src,
			  sizeof(source)*_N_SOURCE_ ,
			  cudaMemcpyHostToDevice ) );
        
// Single layer turbulence profile
float altitude[] = {0},
  xi0[] = {1},
  wind_speed[] = {10},
  wind_direction[] = {0};
// Atmosphere
atm.setup(0.15,30,altitude,xi0,wind_speed,wind_direction);
//atm.reset();

phase2nm = 1E9*atm.wavelength/2/PI;
slopes2Angle = (atm.wavelength/2/d);

// SH WFS
lenslet_array.setup();

// Centroid
cog.setup();

// LMMSE
E.setup(&atm,N_SIDE_LENSLET,d,"MINRES");

atm.get_phase_screen(delta,PS_N_PX,delta,PS_N_PX,d__src,0);

wf_rms = phase2nm*S.std(d__src->phase, _N_PIXEL_);
printf("\n WF RMS: %7.2fnm\n",wf_rms);

float phase_screen[_N_PIXEL_];
HANDLE_ERROR( cudaMemcpy( phase_screen, d__src->phase,
			  sizeof(float)*_N_PIXEL_,
			  cudaMemcpyDeviceToHost ) );
FILE *fid;
fid = fopen("phaseScreen.bin","wb");
fwrite(phase_screen,sizeof(float),_N_PIXEL_,fid);
fclose(fid);

float *d__phase_screen_low_res;
HANDLE_ERROR( cudaMalloc( (void**)&d__phase_screen_low_res, sizeof(float)*PS_E_N_PX ) );
atm.get_phase_screen(d__phase_screen_low_res,delta_e,NP,delta_e,NP,d__src,0);

float *phase_screen_low_res;
phase_screen_low_res = (float*)malloc(sizeof(float)*PS_E_N_PX);
HANDLE_ERROR( cudaMemcpy( phase_screen_low_res, d__phase_screen_low_res,
			  sizeof(float)*PS_E_N_PX,
			  cudaMemcpyDeviceToHost ) );
fid = fopen("phaseScreenLowRes.bin","wb");
fwrite(phase_screen_low_res,sizeof(float),PS_E_N_PX,fid);
fclose(fid);

<<wavefront sensing>>

HANDLE_ERROR( cudaMalloc((void**)&d__x, sizeof(float)*N ) );

char filename[100];
/* for (k=1;k<6;k++) { */
k = 20;
sprintf(filename,"MINRES_phaseEst_%d.bin",k);
HANDLE_ERROR( cudaMemset(d__x, 0, sizeof(float)*N ) );

tid.tic();

E.estimation(cog.d__c,k,d__x);

tid.toc("WAVEFRONT ESTIMATION");

<<MVM (wrap.)>>

/* printf("\nSolver residue norm           : %.2E\n",iSolve.rnorm); */
/* printf("\nSolver mean time per iteration: %.2E\n",iSolve.mean_time_per_iteration); */

/* } */

HANDLE_ERROR( cudaFree( d__src) );
atm.cleanup();
lenslet_array.cleanup();
cog.cleanup();
E.cleanup();
S.cleanup();
HANDLE_ERROR( cudaFree( d__x ) );
HANDLE_ERROR( cudaFree( d__phase_screen_low_res ) );
free(phase_screen_low_res);
//free(b);
//free(phase_screen_est);
//free(x);
@ 
<<wavefront sensing>>=
lenslet_array.propagate(d__src);
cxy0 = (_N_PX_PUPIL_ - 1)/2.0;
cog.get_data(lenslet_array.d__frame, cxy0, cxy0, slopes2Angle);
HANDLE_ERROR( cudaMalloc((void**)&d__b, sizeof(float)*N ) );
HANDLE_ERROR( cudaMemcpy( d__b              , cog.d__cx,  
			  _N_LENSLET_*sizeof(float), cudaMemcpyDeviceToDevice) );
HANDLE_ERROR( cudaMemcpy( d__b + _N_LENSLET_, cog.d__cy,  
			  _N_LENSLET_*sizeof(float), cudaMemcpyDeviceToDevice) );
b = (float *)malloc(sizeof(float)*N);
HANDLE_ERROR( cudaMemcpy( b, d__b,
			  sizeof(float)*N,
			  cudaMemcpyDeviceToHost ) );
/* printf("\n   Cx       Cy\n"); */
/* for (k=0;k<_N_LENSLET_;k++) { */
/*   printf("%+6.4E  %+6.4E\n",b[k],b[k+_N_LENSLET_]); */
/* } */
fid = fopen("centroids.bin","wb");
fwrite(b,sizeof(float),N,fid);
fclose(fid);
@ 
<<MVM (wrap.)>>=
phase_screen_est     = (float*)malloc(sizeof(float)*PS_E_N_PX);
HANDLE_ERROR( cudaMemcpy( phase_screen_est, E.d__phase_est,
			  sizeof(float)*PS_E_N_PX,
			  cudaMemcpyDeviceToHost ) );
fid = fopen(filename,"wb");
//fid = fopen("phaseScreenEst.bin","wb");
fwrite(phase_screen_est,sizeof(float),PS_E_N_PX,fid);
fclose(fid);
