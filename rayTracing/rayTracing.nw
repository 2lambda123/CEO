% -*- mode: Noweb; noweb-code-mode: c-mode -*-

The ray tracing method involves 4 steps \cite{}:
\begin{enumerate}
\item the ray coordinates are transformed into the coordinate system of the surface their interact with,
\item the intersection of the ray with the surface is found,
\item the directions of the ray after the surface is computed according to Snell''s law,
\item the coordinates and directions of the ray is transformed back into its original coordinate systems
\end{enumerate}

\section{The files}
\label{sec:files}

\subsection{Header}
\label{sec:header}

<<rayTracing.h>>=
#ifndef __RAYTRACING_H__
#define __RAYTRACING_H__

#ifndef __UTILITIES_H__
#include "utilities.h"
#endif

#define SNELL_N_ITERATION 100
#define TOL 1E-9

<<ray tracing data type>>

<<vector data type>>

<<ray data type>>

<<coordinate system data type>>

<<ray bundle structure>>

<<conic structure>>

<<zernikeS structure>>

__host__ __device__  rtd zernike_surface(rtd r, rtd o, int max_n, rtd *a);
__host__ __device__  rtd zernike_surface_x_derivative(rtd r, rtd o, int max_n, rtd *a);
__host__ __device__  rtd zernike_surface_y_derivative(rtd r, rtd o, int max_n, rtd *a);
int zern_dx_coef(rtd *b, int j, int n, int m, int jp, int np, int mp);
int zern_dy_coef(rtd *b,int j, int n, int m, int jp, int np, int mp);

<<conic equations>>

<<aperture structure>>

<<GMT M1 structure>>
<<GMT M2 structure>>

__host__ __device__  void forward_transform(vector *v_out, vector *v_in,
				   rtd *d__R, vector *d__origin);
__host__ __device__  void forward_transform_centered(vector *v_out, vector *v_in,
					    rtd *d__R);
__host__ __device__  void backward_transform(vector *v_out, vector *v_in,
                                    rtd *d__R, vector *d__origin);
__host__ __device__  void backward_transform_centered(vector *v_out, vector *v_in,
					     rtd *d__R);


#endif // __RAYTRACING_H__
@ 
\subsection{Source}
\label{sec:source}

<<rayTracing.cu>>=
#include "rayTracing.h"

<<vector functions>>
<<coordinates forward transform>>
<<coordinates backward transform>>

<<to z plane kernel>>
<<to sphere kernel>>
<<reference sphere origin from chief ray>>
<<ray bundle kernels>>
<<bundle reset kernel>>
<<zernike surface kernel>>
<<GMT chief ray tracing kernel>>
<<GMT ray tracing kernel>>
<<GMT blocking kernel>>
<<GMT aperture intersection>>

<<ray bundle functions>>

<<coordinate system functions>>

<<conic functions>>

<<zernikeS functions>>

<<zernike surface equation>>
<<zernike derivative x coefficient>>
<<zernike derivative y coefficient>>

<<vignetting kernel>>
<<aperture functions>>

<<GMT M1 functions>>
<<GMT M2 functions>>

@ 
\subsection{Python}
\label{sec:python}

<<rayTracing.pxd>>=
cdef extern from "rayTracing.h":
    ctypedef double rtd
    ctypedef struct vector:
        rtd x
        rtd y
        rtd z
    ctypedef struct ray:
        vector coordinates
        vector directions
        vector surface_normal
        rtd optical_path_length
    ctypedef struct coordinate_system:
        float *float_R        
@ 
<<rayTracing.pyx>>=
import numpy as np
cimport numpy as np
from utilities cimport cuDoubleArray
@
\subsubsection{Ray bundle}
\label{sec:ray-bundle-1}
<<rayTracing.pxd>>=
    cdef cppclass bundle:
        int N_RAY, N_BUNDLE
        ray *d__ray
	ray *d__chief_ray
        void setup(rtd, int, int , vector, int)
        void setup(rtd, int , vector, int)
        void cleanup()
        void to_z_plane(rtd)
        void to_sphere(vector , rtd)
        void to_sphere(rtd , rtd)
        void to_sphere(rtd *, rtd)
        void get_coordinates(double *)
        void get_chief_coordinates(double *)
        void get_directions(double *)
        void get_chief_directions(double *)
        void get_optical_path_length(double *)
        void get_chief_optical_path_length(double *)
        void get_optical_path_difference(double *)
        void get_optical_path_difference(double *,
					 float , int , 
					 float , int )
        void get_vignetting(double *)
@
<<class definitions>>=
from utilities cimport cuDoubleArray
from source cimport Source
# Bundle
cdef class Bundle:
    cdef bundle *_c_bundle
    cdef cuDoubleArray _coordinates_
    cdef cuDoubleArray _chief_coordinates_
    cdef cuDoubleArray _directions_
    cdef cuDoubleArray _chief_directions_
    cdef cuDoubleArray _optical_path_length_
    cdef cuDoubleArray _chief_optical_path_length_
    cdef cuDoubleArray _optical_path_difference_
    cdef cuDoubleArray _vignetting_
<<rayTracing.pyx>>=
# polar bundle
cdef class Bundle:
    """
    A class to represent a bundle of rays    

    This class is usually instanciated by the Source class

    Parameters
    ----------
    src : Source
        The Source object that contains the pointer to CEO bundle structure

    Attributes
    ----------
    N_BUNDLE : int, read only
        The number of ray bundle
    coordinates : cuDoubleArray, read only
        The coordinate vectors of the rays as a (N_RAYxN_BUNDLE)x3 array
    chief_coordinates : cuDoubleArray, read only
        The coordinate vector of the chief ray
    directions : cuDoubleArray, read only
        The direction vectors of the rays as a (N_RAYxN_BUNDLE)x3 array
    chief_directions : cuDoubleArray, read only
        The direction vector of the chief ray
    optical_path_length : cuDoubleArray, read only
        The optical path lengths of the rays as a N_BUNDLExN_RAY array
    chief_optical_path_length : cuDoubleArray, read only
        The optical path length  of the chief ray
    optical_path_difference : cuDoubleArray, read only
        The optical path differences of the rays as a N_BUNDLExN_RAY array
    vignetting : cuDoubleArray, read only
        The vignetting flag of the rays as a N_BUNDLExN_RAY array
    """

    def __cinit__(self, Source src):
        self._c_bundle = new bundle()
        self._c_bundle = &(src._c_source.rays)

        self._coordinates_               = cuDoubleArray(
            shape=(self._c_bundle.N_RAY*self._c_bundle.N_BUNDLE,3),dev_malloc=True)
        self._chief_coordinates_         = cuDoubleArray(
            shape=(self._c_bundle.N_BUNDLE,3),dev_malloc=True)
        self._directions_                = cuDoubleArray(
            shape=(self._c_bundle.N_RAY*self._c_bundle.N_BUNDLE,3),dev_malloc=True)
        self._chief_directions_          = cuDoubleArray(
            shape=(self._c_bundle.N_BUNDLE,3),dev_malloc=True)
        self._optical_path_length_       = cuDoubleArray(
            shape=(self._c_bundle.N_BUNDLE,self._c_bundle.N_RAY),dev_malloc=True)
        self._chief_optical_path_length_ = cuDoubleArray(
            shape=(self._c_bundle.N_BUNDLE,1),dev_malloc=True)
        self._optical_path_difference_   = cuDoubleArray(
            shape=(self._c_bundle.N_BUNDLE,self._c_bundle.N_RAY),dev_malloc=True)
        self._vignetting_                = cuDoubleArray(
            shape=(self._c_bundle.N_BUNDLE,self._c_bundle.N_RAY),dev_malloc=True)


    <<bundle common>>
@ 
<<bundle common>>=
"""
def __dealloc__(self):
    self._c_bundle.cleanup()
"""

def to_z_plane(self,rtd z_plane):
    """
    Propagates the rays to a given plane

    Parameters
    ----------
    z_plane : double
        The z coordinates of the plane
    """
    self._c_bundle.to_z_plane(z_plane)

def to_sphere(self, rtd radius, sphere_origin=None, sphere_distance=None):
    """
    Computes the optical path difference with respect to the reference sphere

    Parameters
    ----------
    radius : double
       The radius of the reference sphere
    sphere_origin : list of double, optional
        A 3 elements list containing the x,y and z coordinates of the sphere center; default: None
    sphere_distance : list of double, optional
        A list containing the distance from the last surface to the sphere center for the chief ray; default: None
    """

    if sphere_distance is not None:
        distance = cuDoubleArray( host_data=np.array(sphere_distance) )
        self._c_bundle.to_sphere(distance._c_gpu.dev_data,radius)

    cdef vector origin
    if sphere_origin is not None:
        origin.x = <double>sphere_origin[0]
        origin.y = <double>sphere_origin[1]
        origin.z = <double>sphere_origin[2]
        self._c_bundle.to_sphere(origin,radius)

def go_sphere(self, rtd s, rtd radius):
    """
    Computes the optical path difference with respect to the reference sphere

    Parameters
    ----------
    s: double
        The distance from the last surface to the object for the chief ray
    radius: double
       The radius of the reference sphere
    """
    distance = cuDoubleArray( host_data=np.array(s) )
    self._c_bundle.to_sphere(distance._c_gpu.dev_data,radius)

def get_optical_path_difference(self,
                                float delta_x, int N_x,
                                float delta_y, int N_y):
    opd = cuDoubleArray(shape=(N_x,N_y),dev_malloc=True)
    self._c_bundle.get_optical_path_difference(opd._c_gpu.dev_data,
                                               delta_x, N_x,
                                               delta_y, N_y)
    return opd

property N_BUNDLE:
    def __get__(self):
        return self._c_bundle.N_BUNDLE

property coordinates:
    def __get__(self):
        self._c_bundle.get_coordinates(self._coordinates_._c_gpu.dev_data)
        return self._coordinates_

property chief_coordinates:
    def __get__(self):
        self._c_bundle.get_chief_coordinates(self._chief_coordinates_._c_gpu.dev_data)
        return self._chief_coordinates_

property directions:
    def __get__(self):
        self._c_bundle.get_directions(self._directions_._c_gpu.dev_data)
        return self._directions_

property chief_directions:
    def __get__(self):
        self._c_bundle.get_chief_directions(self._chief_directions_._c_gpu.dev_data)
        return self._chief_directions_

property optical_path_length:
    def __get__(self):
        self._c_bundle.get_optical_path_length(self._optical_path_length_._c_gpu.dev_data)
        return self._optical_path_length_

property chief_optical_path_length:
    def __get__(self):
        self._c_bundle.get_chief_optical_path_length(self._chief_optical_path_length_._c_gpu.dev_data)
        return self._chief_optical_path_length_

property optical_path_difference:
    def __get__(self):
        self._c_bundle.get_optical_path_difference(self._optical_path_difference_._c_gpu.dev_data)
        return self._optical_path_difference_

property vignetting:
    def __get__(self):
        self._c_bundle.get_vignetting(self._vignetting_._c_gpu.dev_data)
        return self._vignetting_
@

\subsubsection{Conic surface}
\label{sec:surface-1}

<<rayTracing.pxd>>=
    cdef cppclass conic:
        coordinate_system ref_frame
        void setup(rtd , rtd , vector , vector , vector)
        void cleanup()
@
<<rayTracing.pyx>>=
# conic
cdef class Conic:
    """
    """
    cdef conic *_c_conic

    def __cinit__(self,rtd c, rtd k, 
                  origin=[0.0,0.0,0.0], euler_angles=[0.0,0.0,0.0],
                  conic_origin=[0.0,0.0,0.0]):
        self._c_conic = new conic()
        cdef vector __origin
        __origin.x = <float>origin[0]
        __origin.y = <float>origin[1]
        __origin.z = <float>origin[2]
        cdef vector __euler_angles
        __euler_angles.x = <float>euler_angles[0]
        __euler_angles.y = <float>euler_angles[1]
        __euler_angles.z = <float>euler_angles[2]
        cdef vector __conic_origin
        __conic_origin.x = <float>conic_origin[0]
        __conic_origin.y = <float>conic_origin[1]
        __conic_origin.z = <float>conic_origin[2]
        self._c_conic.setup(c, k, __origin, __euler_angles, __conic_origin)

    def __dealloc__(self):
        self._c_conic.cleanup()
@
\subsubsection{Aperture}
\label{sec:aperture-1}

<<rayTracing.pxd>>=
    cdef cppclass aperture:
        coordinate_system ref_frame
        void setup(float, float, int, vector , vector) 
        void setup_GMT_M1(float, int)
        void cleanup()
        void vignetting(bundle *)
@
<<rayTracing.pyx>>=
# aperture
cdef class Aperture:
    """
    """
    cdef aperture *_c_aperture
    
    def __cinit__(self, float D, float ri, int D_px, origin=[0.0,0.0,0.0], euler_angles=[0.0,0.0,0.0]):
        self._c_aperture = new aperture()
        cdef vector __origin
        __origin.x = <float>origin[0]
        __origin.y = <float>origin[1]
        __origin.z = <float>origin[2]
        cdef vector __euler_angles
        __euler_angles.x = <float>euler_angles[0]
        __euler_angles.y = <float>euler_angles[1]
        __euler_angles.z = <float>euler_angles[2]
        self._c_aperture.setup(D, ri, D_px, __origin, __euler_angles)

    def __dealloc__(self):
        self._c_aperture.cleanup()

    def vignetting(self, Bundle rays):
        self._c_aperture.vignetting(rays._c_bundle)
@
\subsubsection{GMT M1}
\label{sec:gmt-m1-1}

<<rayTracing.pxd>>=
    cdef cppclass gmt_m1:
        void test_ray_tracing()
        <<python GMT M12 functions>>
	void global_tiptilt(float , float )
@  where
<<python GMT M12 functions>>=
int *d__piston_mask
coordinate_system aperture_CS
coordinate_system conic_CS
coordinate_system rigid_body_CS
coordinate_system motion_CS
void setup(float , int )
void setup(float , int , int)
void setup(float , int, zernikeS *, int)
void cleanup()
void update(vector , vector ,int )
void reset()
void trace(bundle *)
void blocking(bundle *)
@
<<rayTracing.pyx>>=
# GMT M1
from utilities cimport cuIntArray
cdef class GMT_M1:
    <<GMT M12 docstring>>
    cdef gmt_m1 *_c_gmt_m1
    cdef public ZernikeS zernike
    cdef cuIntArray _piston_mask_
    
    def __cinit__(self, float D, int D_px, int radial_order=0, int N_SRC=1):
        self._c_gmt_m1 = new gmt_m1()
        self.zernike = ZernikeS(radial_order,N_SURF=7)
        self._c_gmt_m1.setup(D, D_px, <zernikeS *> self.zernike._c_zernikeS, N_SRC)
        self._piston_mask_ = cuIntArray(shape=(D_px*D_px*N_SRC))
        self._piston_mask_._c_gpu.dev_data = self._c_gmt_m1.d__piston_mask;

    def __dealloc__(self):
        self._c_gmt_m1.cleanup()

    def trace(self, Bundle rays):
        self._c_gmt_m1.trace(rays._c_bundle)

    def test(self):
        self._c_gmt_m1.test_ray_tracing();

    def blocking(self, Bundle rays):
        self._c_gmt_m1.blocking(rays._c_bundle)

    def update(self, origin=[0.0,0.0,0.0], euler_angles=[0.0,0.0,0.0], int idx=0):
        cdef vector __origin
        __origin.x = <float>origin[0]
        __origin.y = <float>origin[1]
        __origin.z = <float>origin[2]
        cdef vector __euler_angles
        __euler_angles.x = <float>euler_angles[0]
        __euler_angles.y = <float>euler_angles[1]
        __euler_angles.z = <float>euler_angles[2]
        self._c_gmt_m1.update(__origin, __euler_angles, idx)

    def global_tiptilt(self, float tip, float tilt):
        self._c_gmt_m1.global_tiptilt(tip, tilt);
        
    def reset(self):
        self._c_gmt_m1.reset()

    property piston_mask:
        def __get__(self):
            P = self._piston_mask_.host()
            return np.array( [P.flatten()==k for k in range(1,8)] )
@ with
<<GMT M12 docstring>>=
"""
A class to represent GMT M1 segmented mirror

Parameters
----------
D: float
    The size in meter of the pupil plane (must be equal or larger than the telescope diameter)
D_px: float
    The size in pxixel of the pupil plane
N_SRC: int, optionnal
    The number of sources, defaults to 1

Examples
-------
>>> import ceo
>>> M1 = GMT_M1(25.5,101)
or
>>> import ceo
>>> M2 = GMT_M2(25.5,101,N_SRC=4)

"""
@ 

\subsubsection{GMT M2}
\label{sec:gmt-m2-1}

<<rayTracing.pxd>>=
    cdef cppclass gmt_m2:
        <<python GMT M12 functions>>
        void tiptilt_neutral(float, float)
        void coma_neutral(float, float)
@
<<rayTracing.pyx>>=
# GMT M2
cdef class GMT_M2:
    <<GMT M12 docstring>>
    cdef gmt_m2 *_c_gmt_m2
    cdef public ZernikeS zernike
    
    def __cinit__(self, float D, int D_px, radial_order=0, int N_SRC=1):
        self._c_gmt_m2 = new gmt_m2()
        self.zernike = ZernikeS(radial_order,N_SURF=7)
        self._c_gmt_m2.setup(D, D_px, <zernikeS *> self.zernike._c_zernikeS, N_SRC)

    def __dealloc__(self):
        self._c_gmt_m2.cleanup()

    def trace(self, Bundle rays):
        self._c_gmt_m2.trace(rays._c_bundle)

    def blocking(self, Bundle rays):
        self._c_gmt_m2.blocking(rays._c_bundle)

    def update(self, origin=[0.0,0.0,0.0], euler_angles=[0.0,0.0,0.0], int idx=0):
        cdef vector __origin
        __origin.x = <float>origin[0]
        __origin.y = <float>origin[1]
        __origin.z = <float>origin[2]
        cdef vector __euler_angles
        __euler_angles.x = <float>euler_angles[0]
        __euler_angles.y = <float>euler_angles[1]
        __euler_angles.z = <float>euler_angles[2]
        self._c_gmt_m2.update(__origin, __euler_angles, idx)

    def tiptilt_neutral(self, float tip, float tilt):
        self._c_gmt_m2.tiptilt_neutral(tip, tilt);

    def coma_neutral(self, float tip, float tilt):
        self._c_gmt_m2.coma_neutral(tip, tilt);

    def reset(self):
        self._c_gmt_m2.reset()
@
\subsubsection{Zernike}
\label{sec:zernike}

<<rayTracing.pxd>>=
    cdef cppclass zernikeS:
          void setup(int , rtd *, vector , vector , int)
          void cleanup()
          void surface(rtd *, rtd *, rtd *, int , int)
          void update(rtd *)
          void surface_derivatives(rtd *, rtd *, 
                                   rtd *, rtd *, int )

    rtd zernike_surface(rtd , rtd , unsigned int , rtd *)

@ 
<<rayTracing.pyx>>=
# Zernike surface
cdef class ZernikeS:
    cdef zernikeS *_c_zernikeS
    cdef public int max_n, n_mode, N_SURF
    cdef public np.ndarray a

    def __cinit__(self, int _max_n_, np.ndarray _a_=None,
                  origin=[0.0,0.0,0.0], euler_angles=[0.0,0.0,0.0],
                  int N_SURF=1):
        self._c_zernikeS = new zernikeS()
        self.max_n = _max_n_
        self.n_mode = (_max_n_+1)*(_max_n_+2)/2
        self.N_SURF = N_SURF
        if _a_ is None:
            self.a = np.zeros((self.N_SURF,self.n_mode))
        else: 
            self.a = _a_
        cdef vector __origin
        __origin.x = <float>origin[0]
        __origin.y = <float>origin[1]
        __origin.z = <float>origin[2]
        cdef vector __euler_angles
        __euler_angles.x = <float>euler_angles[0]
        __euler_angles.y = <float>euler_angles[1]
        __euler_angles.z = <float>euler_angles[2]
        self._c_zernikeS.setup( self.max_n, <rtd *>self.a.data,
                                __origin, __euler_angles,
                                self.N_SURF) 

    def __dealloc__(self):
        self._c_zernikeS.cleanup();

    def update(self):
        self._c_zernikeS.update(<rtd *>self.a.data)

    def reset(self):
        self.a = np.zeros((self.N_SURF,self.n_mode))
        self.update()
        
    def surface(self, cuDoubleArray r, cuDoubleArray o, int surf_id=0):
        S = cuDoubleArray(shape=r.shape, dev_malloc = True)
        self._c_zernikeS.surface(S._c_gpu.dev_data, 
                                 r._c_gpu.dev_data, o._c_gpu.dev_data, 
                                 r._c_gpu.N, surf_id)
        return S

    def surface_derivatives(self, cuDoubleArray r, cuDoubleArray o):
        dSdx = cuDoubleArray(shape=r.shape, dev_malloc = True)
        dSdy = cuDoubleArray(shape=r.shape, dev_malloc = True)
        self._c_zernikeS.surface_derivatives(dSdx._c_gpu.dev_data, dSdy._c_gpu.dev_data, 
                                             r._c_gpu.dev_data, o._c_gpu.dev_data, r._c_gpu.N)
        return dSdx,dSdy

def Zernike_Surface(rtd r, rtd o, int max_n, np.ndarray a):
    return zernike_surface(r, o, max_n, <rtd *>a.data)

@ 
\section{Custom types}
\label{sec:custom-types}

The accuracy of the ray tracing is partly depending upon the data type used to hold data values of rays and surfaces.
GPU are faster in single precision than in double precision but double precision may still be required for accuracy.
So lets defined a ray tracing type:
<<ray tracing data type>>=
typedef double rtd;
@ 

\subsection{Vector}
\label{sec:vector}

A new vector data type is defined 
<<vector data type>>=
typedef struct {
  rtd x;
  rtd y;
  rtd z;
  __host__ __device__ rtd rho2(void);
  __host__ __device__ rtd rho2(rtd x0, rtd y0);
  __host__ __device__ rtd mag(void);
  __host__ __device__ rtd mag(rtd R);
  __host__ __device__ rtd angle(void);
} vector;
@ that represents the 3 coordinates in space of the tip of vector.
The square of the magnitude of a vector projected in the x,y--plane i.e. $[[x]]^2+[[y]]^2$ is computed with 
<<vector functions>>=
__host__ __device__ rtd vector::rho2(void) {
  return x*x + y*y;
}
@
The square of the magnitude of a vector projected in the x,y--plane with respect to origin ([[x0]],[[y0]]) i.e. $[[x-x0]]^2+[[y-y0]]^2$ is computed with 
<<vector functions>>=
__host__ __device__ rtd vector::rho2(rtd x0, rtd y0) {
  rtd xp, yp;
  xp = x - x0;
  yp = y - y0;
  return xp*xp + yp*yp;
}
@ 
The magnitude and angle of the projection of the vector in the x,y--plane is
<<vector functions>>=
__host__ __device__ rtd vector::mag(void) {
  return hypot(x,y);
}
__host__ __device__ rtd vector::angle(void) {
  return atan2(y,x);
}
@ 
The magnitude can also be normalized by radius [[R]]:
<<vector functions>>=
__host__ __device__ rtd vector::mag(rtd R) {
  return hypot(x,y)/R;
}
@

\subsection{Ray}
\label{sec:ray}

A type for the rays is also defined:
<<ray data type>>=
typedef struct {
  <<ray data>>
} ray;
@ 
It contains the ray coordinates:
<<ray data>>=
vector coordinates;
@ 
the direction cosines of the ray:
<<ray data>>=
vector directions;
@ 
the [[surface_normal]] at the surface it intersected with the last time:
<<ray data>>=
vector surface_normal;
@ 
the optical path length:
<<ray data>>=
rtd optical_path_length;
@ 
the optical path difference
<<ray data>>=
rtd optical_path_difference;
@ the vignetting flag [[v]], $[[v]]=0$ means the ray is vignetted:
<<ray data>>=
char v;
@ and the number of iterative steps for the Raphson--Newton method:
<<ray data>>=
int n_iteration;

@
\section{Ray bundle}
\label{sec:ray-bundle}

Collections of rays are gathered into bundles:
<<ray bundle structure>>=
struct bundle {
  <<ray bundle parameters>>
  void setup(rtd RADIUS, int N_RADIUS, int N_THETA, vector origin, int N_SRC);
  void setup(rtd L, int N_L, vector origin, int N_SRC);
  void cleanup(void);
  void to_z_plane(rtd z_in);
  void to_sphere(vector sphere_origin, rtd sphere_radius);
  void to_sphere(rtd s, rtd sphere_radius);
  void to_sphere(rtd *s, rtd sphere_radius);
  void get_coordinates(double *d__coord);
  void get_chief_coordinates(double *d__coord);
  void get_directions(double *d__dir);
  void get_chief_directions(double *d__dir);
  void get_chief_optical_path_length(double *d__opl);
  void get_optical_path_length(double *d__opl);
  void get_optical_path_difference(double *d__opd);
  void get_optical_path_difference(double *d__opd,
				   float const delta_x, int N_x, 
				   float const delta_y, int N_y);
  void get_vignetting(double *d__v);
};
@ 
A bundle allocates an array of [[N_RAY]] rays on the device
<<ray bundle parameters>>=
int N_RAY;
ray *d__ray;
@ 
The structure may contain several bundle of rays, each associated to a different source but with the same number of rays
<<ray bundle parameters>>=
int N_BUNDLE;
@
The x and y coordinates of the [[origin]] vector specifies the location of the center of the ray bundle when it crosses the (x,y) plane of the first surface.
The z coordinate specifies the height of the ray bundle with respect to the first surface.
<<ray bundle parameters>>=
vector *d__origin;
@ 
The chief ray is defined with
<<ray bundle parameters>>=
ray *d__chief_ray; 
vector *d__chief_origin;
@ 
The vignetting mask is defined with
<<ray bundle parameters>>=
mask V;
@
The ray geometry is defined either in polar coordinates (\textit{fan} mode)
<<ray bundle parameters>>=
char geom[8];
@ where the radius and azimuth angle are sampled with [[N_RADIUS]] and [[N_THETA]] rays,
<<ray bundle parameters>>=
int N_RADIUS, N_THETA;
@ 
or in cartesian coordinates (\textit{box} mode) where the rays sample a [[N_L]]$\times$[[N_L]] square
<<ray bundle parameters>>=
int N_L;
@
In \textit{fan} mode, the radius is saved in [[L]] and in \textit{box} mode the side of the box is saved in [[L]]:
<<ray bundle parameters>>=
rtd L;
@
\subsection{Setup \& Cleanup}
\label{sec:bundle-setup--cleanup}

A ray bundle is specified with either the polar or cartesian coordinates of the rays at a given origin.
The direction cosine are derived from the coordinates of a source object.

The polar coordinates are defined with the sampling of the radius [[N_RADIUS]] from 0 to [[RADIUS]] and with the sampling of the azimuth [[N_THETA]].
<<ray bundle functions>>=
void bundle::setup(rtd RADIUS, int _N_RADIUS_, 
		   int _N_THETA_, vector origin, int N_SRC)
{
  strcpy(geom,"fan");
  N_RADIUS = _N_RADIUS_;
  N_THETA  = _N_THETA_;
  L        = RADIUS;
  N_BUNDLE = N_SRC;
  N_RAY = (N_RADIUS-1)*N_THETA + 1;
  V.setup(N_RAY*N_BUNDLE);
  HANDLE_ERROR( cudaMalloc((void**)&d__ray, sizeof(ray)*N_RAY*N_BUNDLE ) );
  HANDLE_ERROR( cudaMalloc((void**)&d__origin, sizeof(vector) ) );
  HANDLE_ERROR( cudaMemcpy( d__origin, &origin, 
			    sizeof(vector), cudaMemcpyHostToDevice ) );
  <<chief ray allocation>>
}
@ 
The direction cosines $(k,l,m)$ of the rays are defined from the source zenith $\zeta$ and azimuth $\xi$ angles as
\begin{eqnarray}
  \label{eq:2}
  k &=& \sin(\zeta)\cos(\xi) \\
  l &=& \sin(\zeta)\sin(\xi) \\
  k &=& \cos(\zeta)
\end{eqnarray}
The polar coordinates $\rho$ and $\theta$ of the rays are given by
\begin{equation}
  \rho = [[RADIUS]] {k \over [[N_RADIUS]] - 1 } \forall k \in [0,[[N_RADIUS]] - 1]
\end{equation}
and
\begin{equation}
  \theta = 2\pi {k \over [[N_THETA]] } \forall k \in [0,[[N_THETA-1]]]
\end{equation}
<<bundle coordinates>>=
<<chief ray init>>
blockDim = dim3(16,16);
gridDim  = dim3(N_RADIUS/16+1,N_THETA/16+1, N_BUNDLE);
ray_coordinates LLL gridDim , blockDim RRR (d__ray, N_RAY, src->dev_ptr,
                                            L, N_RADIUS, N_THETA, d__origin);
@ 
<<bundle coordinates kernel>>=
__global__ void ray_coordinates(ray *d__ray, int N_RAY, source *src,
                            rtd RADIUS, int N_RADIUS, int N_THETA, vector *origin)
{
  int i, j, k, iSource;
  rtd rho, theta;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  iSource = blockIdx.z;
  //k = j * gridDim.x * blockDim.x + i;
  if ( (i<N_RADIUS) && (j<N_THETA) )
  {
    rho   = RADIUS*i/(N_RADIUS-1);
    if (i==0) {
      j = 0;
      k = 0;
    } else
      k = j + (i - 1)*N_THETA + 1;
    k += iSource*N_RAY;
    theta = 2*PI*j/N_THETA; 
    d__ray[k].coordinates.x = rho*cos(theta) + origin->x; 
    d__ray[k].coordinates.y = rho*sin(theta) + origin->y; 
    d__ray[k].coordinates.z = origin->z;
    d__ray[k].directions.x  = sin(src[iSource].zenith)*cos(src[iSource].azimuth);
    d__ray[k].directions.y  = sin(src[iSource].zenith)*sin(src[iSource].azimuth);
    d__ray[k].directions.z  = cos(src[iSource].zenith);
    d__ray[k].optical_path_length = 0.0;
    d__ray[k].optical_path_difference = 0.0;
    d__ray[k].coordinates.x -= d__ray[k].coordinates.z*d__ray[k].directions.x;
    d__ray[k].coordinates.y -= d__ray[k].coordinates.z*d__ray[k].directions.y;
    d__ray[k].v = 1;
  }
}
@
The chief ray is defined with
<<chief ray allocation>>=
vector chief_origin;
chief_origin.x = 0.0;
chief_origin.y = 0.0;
chief_origin.z = origin.z;
HANDLE_ERROR( cudaMalloc((void**)&d__chief_ray, sizeof(ray)*N_BUNDLE ) );
HANDLE_ERROR( cudaMalloc((void**)&d__chief_origin, sizeof(vector) ) );
HANDLE_ERROR( cudaMemcpy( d__chief_origin, &chief_origin, 
                         sizeof(vector), cudaMemcpyHostToDevice ) );
@ and is initialized with
<<chief ray init>>= 
ray_coordinates LLL gridDim , blockDim RRR (d__chief_ray, 1, src->dev_ptr,
					    0.0, 2, 1, d__origin);

@
The cartesian coordinates are defined with the sampling of the square box length [[N_L]] from $-[[L]]$ to [[L]].
<<ray bundle functions>>=
  void bundle::setup(rtd _L_, int _N_L_, vector origin, int N_SRC)
{
  strcpy(geom,"box");
  N_L = _N_L_;
  L = _L_;
  N_BUNDLE = N_SRC;
  N_RAY = N_L*N_L;
  V.setup(N_RAY*N_BUNDLE);
  HANDLE_ERROR( cudaMalloc((void**)&d__ray, sizeof(ray)*N_RAY*N_BUNDLE ) );
  HANDLE_ERROR( cudaMalloc((void**)&d__origin, sizeof(vector) ) );
  HANDLE_ERROR( cudaMemcpy( d__origin, &origin, 
			    sizeof(vector), cudaMemcpyHostToDevice ) );
  <<chief ray allocation>>
}
@ 
The direction cosines $(k,l,m)$ of the rays are defined from the source zenith $\zeta$ and azimuth $\xi$ angles as
\begin{eqnarray}
  \label{eq:2}
  k &=& \sin(\zeta)\cos(\xi) \\
  l &=& \sin(\zeta)\sin(\xi) \\
  k &=& \cos(\zeta)
\end{eqnarray}
The cartesian coordinates $x$ and $y$ of the rays are given by
\begin{eqnarray}
  x &=& L*(i-([[N_L]]-1)/2)/([[N_L]]-1) \\
  y &=& L*(j-([[N_L]]-1)/2)/([[N_L]]-1)
\end{eqnarray}
<<bundle coordinates (box)>>=
<<chief ray init>>
blockDim = dim3(16,16);
gridDim  = dim3(N_L/16+1,N_L/16+1, N_BUNDLE);
ray_coordinates_box LLL gridDim , blockDim RRR (d__ray, N_RAY, src->dev_ptr,
                                                            L, N_L, d__origin);
@ 
<<bundle coordinates kernel (box)>>=
__global__ void ray_coordinates_box(ray *d__ray, int N_RAY, source *src,
                                    rtd L, int N_L, vector *origin)
{
  int i, j, k, iSource;
  rtd x, y;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  iSource = blockIdx.z;
  if ( (i<N_L) && (j<N_L) )
  {
    x   = L*(i - (N_L-1)*0.5)/(N_L-1);
    y   = L*(j - (N_L-1)*0.5)/(N_L-1);
    k = i + j*N_L + iSource*N_RAY;
    d__ray[k].coordinates.x = x + origin->x; 
    d__ray[k].coordinates.y = y + origin->y; 
    d__ray[k].coordinates.z = origin->z;
    d__ray[k].directions.x  = sin(src[iSource].zenith)*cos(src[iSource].azimuth);
    d__ray[k].directions.y  = sin(src[iSource].zenith)*sin(src[iSource].azimuth);
    d__ray[k].directions.z  = cos(src[iSource].zenith);
    d__ray[k].optical_path_length = 0.0;
    d__ray[k].optical_path_difference = 0.0;
    d__ray[k].coordinates.x -= d__ray[k].coordinates.z*d__ray[k].directions.x;
    d__ray[k].coordinates.y -= d__ray[k].coordinates.z*d__ray[k].directions.y;
    d__ray[k].v = 1;
  }
}
@
Memory is freed with
<<ray bundle functions>>=
void bundle::cleanup(void) 
{
  fprintf(stdout,"@(CEO)>bundle: freeing memory!\n");
  HANDLE_ERROR( cudaFree( d__ray ) );
  HANDLE_ERROR( cudaFree( d__chief_ray ) );
  HANDLE_ERROR( cudaFree( d__origin ) );
  HANDLE_ERROR( cudaFree( d__chief_origin ) );
}
@

\subsection{Propagation parametric geometric equation}
\label{sec:prop-param-geom}

The rays are propagated to the plane $z=[[z__plane]]$ with
\begin{eqnarray}
  \label{eq:26}
  s &=& { [[z_plane]] - z \over m} \\\nonumber
  x &=& x + s k \\\nonumber
  y &=& y + s l \\\nonumber
  z &=& [[z_plane]]
\end{eqnarray}
<<ray bundle functions>>= 
void bundle::to_z_plane(rtd z_plane)
{
  to_z_plane_chief_kernel LLL 1, 1, N_BUNDLE RRR (d__chief_ray, 1, z_plane);
  dim3 blockDim(16,16);
  dim3 gridDim(N_RAY/256+1,1,N_BUNDLE);
  to_z_plane_kernel LLL gridDim , blockDim RRR (d__ray, N_RAY, z_plane, d__chief_ray);
}
@ where
<<to z plane kernel>>=
  __global__ void to_z_plane_kernel(ray *d__ray, int N_RAY, rtd z_plane, ray *d__chief_ray)
{
  int i, j, k0, k, iSource;
  rtd s;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  iSource = blockIdx.z;
  k = j * gridDim.x * blockDim.x + i;
  k0 = k;
  k += iSource*N_RAY;
  if ( (k0<N_RAY ) && (d__ray[k].v) )
  {
    if (d__ray[k].directions.z==0)
       return;
    s = (z_plane - d__ray[k].coordinates.z)/d__ray[k].directions.z;
    d__ray[k].coordinates.x = d__ray[k].coordinates.x + s*d__ray[k].directions.x;
    d__ray[k].coordinates.y = d__ray[k].coordinates.y + s*d__ray[k].directions.y;
    d__ray[k].coordinates.z = z_plane;
    d__ray[k].optical_path_length = s;
    d__ray[k].optical_path_difference += 
      d__ray[k].optical_path_length - d__chief_ray->optical_path_length;
  }
}
__global__ void to_z_plane_chief_kernel(ray *d__ray, int N_RAY, rtd z_plane)
{
  int k, iSource;
  rtd s;
  iSource = blockIdx.z;
  k = iSource;
  if (d__ray[k].directions.z==0)
    return;
  s = (z_plane - d__ray[k].coordinates.z)/d__ray[k].directions.z;
  d__ray[k].coordinates.x = d__ray[k].coordinates.x + s*d__ray[k].directions.x;
  d__ray[k].coordinates.y = d__ray[k].coordinates.y + s*d__ray[k].directions.y;
  d__ray[k].coordinates.z = z_plane;
  d__ray[k].optical_path_length = s;
}
@ 

\subsection{Reference sphere}
\label{sec:reference-sphere}

The optical path difference (OPD) is usually computed with respect to a reference sphere centered on the object.
The OPD is given by the difference between the rays optical path length (OPL) to the sphere and the OPL of the chief ray to the sphere.
The OPL $s$ is used to compute the intersection of a ray with the sphere from the parametric equation:
\begin{eqnarray}
  \label{eq:27}
  x &=& x_{-1} + s k_{-1} \\\nonumber
  y &=& y_{-1} + s l_{-1} \\\nonumber
  z &=& z_{-1} + s m_{-1} 
\end{eqnarray}
where $(x_{-1},y_{-1},z_{-1})$ and  $(k_{-1},l_{-1},m_{-1})$ are the coordinates at and direction cosines from the last surface.
Inserting $x$, $y$ and $z$ in the sphere equation,
\begin{equation}
  \label{eq:28}
  (x - x_O)^2 + (y-y_O)^2 + (z-z_O)^2 = R^2 
\end{equation}
where $(x_O,y_O,z_O)$ is the object coordinate and $R$ the sphere radius, and solving for $S$ lead to
\begin{equation}
  \label{eq:29}
  s = - \gamma + \sqrt{\gamma^2  - (\rho^2 - R^2)}
\end{equation}
with
\begin{equation}
  \label{eq:30}
  \gamma = (x_{-1} - x_O)k_{-1} + (y_{-1} - y_O)l_{-1} + (z_{-1} - z_O)m_{-1} 
\end{equation}
and
\begin{equation}
  \label{eq:31}
  \rho^2 = (x_{-1} - x_O)^2 + (y_{-1} - y_O)^2 + (z_{-1} - z_O)^2. 
\end{equation}
@ 
The code corresponding to the above equation is:
<<to sphere kernel common>>=
x = d__ray[k].coordinates.x - sphere_origin[iSource].x;
y = d__ray[k].coordinates.y - sphere_origin[iSource].y;
z = d__ray[k].coordinates.z - sphere_origin[iSource].z;
g = x*d__ray[k].directions.x + y*d__ray[k].directions.y + z*d__ray[k].directions.z;
rho2 = x*x + y*y + z*z;
s = sqrt( g*g - (rho2-sphere_radius*sphere_radius) ) - g;
d__ray[k].optical_path_length = s;
d__ray[k].coordinates.x += s*d__ray[k].directions.x; 
d__ray[k].coordinates.y += s*d__ray[k].directions.y;
d__ray[k].coordinates.z += s*d__ray[k].directions.z;
@ 
The routine is:
<<ray bundle functions>>= 
void bundle::to_sphere(vector sphere_origin, rtd sphere_radius)
{
  vector *d__sphere_origin;
  HANDLE_ERROR( cudaMalloc((void**)&d__sphere_origin, sizeof(vector) ) );
  HANDLE_ERROR( cudaMemcpy( d__sphere_origin, &sphere_origin, 
			    sizeof(vector), cudaMemcpyHostToDevice ) );
  to_sphere_chief_kernel LLL 1 , 1, N_BUNDLE RRR (d__chief_ray, 1, 
					d__sphere_origin, sphere_radius);
  dim3 blockDim(16,16);
  dim3 gridDim(N_RAY/256+1,1, N_BUNDLE);
  to_sphere_kernel LLL gridDim , blockDim RRR (d__ray, N_RAY, 
					       d__sphere_origin, sphere_radius, 
					       d__chief_ray);
  HANDLE_ERROR( cudaFree( d__sphere_origin ) );
}
@ where
<<to sphere kernel>>=
__global__ void to_sphere_kernel(ray *d__ray, int N_RAY, 
				 vector *sphere_origin, rtd sphere_radius,
				 ray *d__chief_ray)
{
  int i, j, k0, k, iSource;
  rtd s, x, y, z, g, rho2;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  k = j * gridDim.x * blockDim.x + i;
  iSource = blockIdx.z;
  k0 = k;
  k += iSource*N_RAY;
  if ( (k0<N_RAY ) && (d__ray[k].v) )
  {
    <<to sphere kernel common>>
    d__ray[k].optical_path_difference += 
      d__ray[k].optical_path_length - d__chief_ray[iSource].optical_path_length;
  }
}
__global__ void to_sphere_chief_kernel(ray *d__ray, int N_RAY, 
                                       vector *sphere_origin, rtd sphere_radius)
{
  int k, iSource;
  rtd s, x, y, z, g, rho2;
  iSource = blockIdx.z;
  k = iSource;
  <<to sphere kernel common>>
}
@ 
The chief ray defines the location of the object and the reference sphere is centered on the object e.g. the origin of the reference sphere is on the chief ray.
If the distance from the last surface to the object is known for the chief ray, then the origin of the reference sphere is given by:
<<reference sphere origin from chief ray>>=
__global__ void chief_parametric_equation(vector *d__v, ray *d__ray, int N_RAY, rtd *s)
{
  int k, iSource;
  iSource = blockIdx.z;
  k = iSource;
  d__v[k].x = d__ray[k].coordinates.x + d__ray[k].directions.x*s[k];
  d__v[k].y = d__ray[k].coordinates.y + d__ray[k].directions.y*s[k];
  d__v[k].z = d__ray[k].coordinates.z + d__ray[k].directions.z*s[k];
}
@ 
The rays intersection with the reference sphere is computed with
<<ray bundle functions>>= 
void bundle::to_sphere(rtd s, rtd sphere_radius)
{
  vector *d__sphere_origin;
  HANDLE_ERROR( cudaMalloc((void**)&d__sphere_origin, sizeof(vector)*N_BUNDLE ) );
  dim3 blockDim(1,1);
  dim3 gridDim(1,1, N_BUNDLE);
  chief_parametric_equation LLL gridDim , blockDim RRR (d__sphere_origin, d__chief_ray, 1, &s);
  to_sphere_chief_kernel LLL gridDim , blockDim RRR (d__chief_ray, 1, 
					d__sphere_origin, sphere_radius);
  blockDim = dim3(16,16);
  gridDim  = dim3(N_RAY/256+1,1, N_BUNDLE);
  to_sphere_kernel LLL gridDim , blockDim RRR (d__ray, N_RAY, 
					       d__sphere_origin, sphere_radius, 
					       d__chief_ray);
  HANDLE_ERROR( cudaFree( d__sphere_origin ) );
}

void bundle::to_sphere(rtd *s, rtd sphere_radius)
{
  vector *d__sphere_origin;
  HANDLE_ERROR( cudaMalloc((void**)&d__sphere_origin, sizeof(vector)*N_BUNDLE ) );
  dim3 blockDim(1,1);
  dim3 gridDim(1,1, N_BUNDLE);
  chief_parametric_equation LLL gridDim , blockDim RRR (d__sphere_origin, d__chief_ray, 1, s);
  to_sphere_chief_kernel LLL gridDim , blockDim RRR (d__chief_ray, 1, 
					d__sphere_origin, sphere_radius);
  blockDim = dim3(16,16);
  gridDim  = dim3(N_RAY/256+1,1, N_BUNDLE);
  to_sphere_kernel LLL gridDim , blockDim RRR (d__ray, N_RAY, 
					       d__sphere_origin, sphere_radius, 
					       d__chief_ray);
  HANDLE_ERROR( cudaFree( d__sphere_origin ) );
}
@  

\subsection{Gathering data}
\label{sec:gathering-data}

The coordinates, directions, optical path length and vignetting map are copied into arrays with the following functions:
<<ray bundle functions>>= 
<<gathering ray coordinates>>
<<gathering ray directions>>
<<gathering ray optical path length>>
<<gathering ray optical path difference>>
<<gathering ray vignetting map>>
<<OPD nearest neighbor interpolation>>
@ 
<<ray bundle kernels>>= 
<<gathering ray coordinates kernel>>
<<gathering ray directions kernel>>
<<gathering ray optical path length kernel>>
<<gathering ray optical path difference kernel>>
<<gathering ray vignetting map kernel>>
<<OPD nearest neighbor interpolation kernel>>
@ 
<<gathering ray coordinates>>=
void bundle::get_coordinates(double *d__coord)
{
  dim3 blockDim(16,16);
  dim3 gridDim(N_RAY/256+1,1, N_BUNDLE);
  get_coordinates_kernel LLL gridDim , blockDim RRR (d__coord, d__ray, N_RAY);
}
@ 
<<gathering ray coordinates>>=
void bundle::get_chief_coordinates(double *d__coord)
{
  dim3 blockDim(1,1);
  dim3 gridDim(1,1, N_BUNDLE);
  get_coordinates_kernel LLL gridDim, blockDim RRR (d__coord, d__chief_ray, 1);
}
@ 
<<gathering ray coordinates kernel>>=
__global__ void get_coordinates_kernel(double *d__coord, ray *d__ray, int N_RAY)
{
  int i, j, k, l, iSource;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  k = j * gridDim.x * blockDim.x + i;
  iSource = blockIdx.z;
  if ( k<N_RAY )
  {
    k += iSource*N_RAY;
    l = k*3;
    d__coord[l++] = d__ray[k].coordinates.x;
    d__coord[l++] = d__ray[k].coordinates.y;
    d__coord[l]   = d__ray[k].coordinates.z;
  }
}
@ 
<<gathering ray directions>>=
void bundle::get_directions(double *d__dir)
{
  dim3 blockDim(16,16);
  dim3 gridDim(N_RAY/256+1,1,N_BUNDLE);
  get_directions_kernel LLL gridDim , blockDim RRR (d__dir, d__ray, N_RAY);
}
@ 
<<gathering ray directions>>=
void bundle::get_chief_directions(double *d__dir)
{
  dim3 blockDim(1,1);
  dim3 gridDim(1,1,N_BUNDLE);
  get_directions_kernel LLL gridDim , blockDim RRR (d__dir, d__chief_ray, 1);
}
@ 
<<gathering ray directions kernel>>=
__global__ void get_directions_kernel(double *d__dir, ray *d__ray, int N_RAY)
{
  int i, j, k, l, iSource;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  k = j * gridDim.x * blockDim.x + i;
  iSource = blockIdx.z;
  if ( k<N_RAY )
  {
    k += iSource*N_RAY;
    l = k*3;
    d__dir[l++] = d__ray[k].directions.x;
    d__dir[l++] = d__ray[k].directions.y;
    d__dir[l]   = d__ray[k].directions.z;
  }
}
@ 
<<gathering ray optical path length>>=
void bundle::get_optical_path_length(double *d__opl)
{
  dim3 blockDim(16,16);
  dim3 gridDim(N_RAY/256+1,1,N_BUNDLE);
  get_optical_path_length_kernel LLL gridDim , blockDim RRR (d__opl, d__ray, N_RAY);
}
@ 
<<gathering ray optical path length>>=
void bundle::get_chief_optical_path_length(double *d__opl)
{
  dim3 blockDim(1,1);
  dim3 gridDim(1,1,N_BUNDLE);
  get_optical_path_length_kernel LLL gridDim , blockDim RRR (d__opl, d__chief_ray, 1);
}
@ 
<<gathering ray optical path length kernel>>=
__global__ void get_optical_path_length_kernel(double *d__opl, ray *d__ray, int N_RAY)
{
  int i, j, k, iSource;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  k = j * gridDim.x * blockDim.x + i;
  iSource = blockIdx.z;
  if ( k<N_RAY )
    {
      k += iSource*N_RAY;
      d__opl[k]   = d__ray[k].optical_path_length;
    }
}
@ 
<<gathering ray optical path difference>>=
void bundle::get_optical_path_difference(double *d__opd)
{
  HANDLE_ERROR( cudaMemset(d__opd, 0, sizeof(double)*N_RAY*N_BUNDLE ) );
  dim3 blockDim(16,16);
  dim3 gridDim(N_RAY/256+1,1,N_BUNDLE);
  get_optical_path_difference_kernel LLL gridDim , blockDim RRR (d__opd, d__ray, N_RAY);
}
@ 
<<gathering ray optical path difference kernel>>=
__global__ void get_optical_path_difference_kernel(double *d__opd, ray *d__ray, int N_RAY)
{
  int i, j, k, iSource;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  k = j * gridDim.x * blockDim.x + i;
  iSource = blockIdx.z;
  j = k;
  k += iSource*N_RAY;
  if ( (j<N_RAY) && (d__ray[k].v) )
    {
      d__opd[k]   = d__ray[k].optical_path_difference;
    }
}
@ 
The OPD is interpolated on a $N_x\times N_y$ grid with respective sampling $\delta_x$ and $\delta_y$.
The $x_i$ and $y_i$ interpolation coordinates are written:
\begin{eqnarray}
  \label{eq:32}
  x_i &=& \delta_x(i -(N_x-1)/2),\quad \forall 0\leq i \leq N_x-1 \\\nonumber
  y_i &=& \delta_y(j -(N_y-1)/2),\quad \forall 0\leq j \leq N_y-1 
\end{eqnarray}
The coordinates are re--centered with respect to the original coordinate grid
\begin{eqnarray} 
  \label{eq:33}
  x_i &\rightarrow& x_i + L/2 \\\nonumber
  y_i &\rightarrow& y_i + L/2
\end{eqnarray}
and scale to that grid
\begin{eqnarray}
  \label{eq:34}
  x_i &\rightarrow& x_i{N_L-1 \over L} \\\nonumber
  y_i &\rightarrow& y_i{N_L-1 \over L}
\end{eqnarray}
<<OPD nearest neighbor interpolation>>=
void bundle::get_optical_path_difference(double *d__opd,
					 float const delta_x, int N_x, 
					 float const delta_y, int N_y)
{
  /* cublasHandle_t handle; */
  /* cublasStatus_t status; */
  /* double *d__coord; */
  /* int N, idx; */

  /* cublasCreate(&handle); */

  /* N = N_RAY*3; */
  /* HANDLE_ERROR( cudaMalloc((void**)&d__coord, sizeof(double)*N ) ); */
  /* get_coordinates(d__coord); */

  /* CUBLAS_ERROR( cublasIdamin(handle, N_RAY, d__coord, 3, &idx) ); */
  /* printf("x min idx = %d\n",idx); */
  /* CUBLAS_ERROR( cublasIdamax(handle, N_RAY, d__coord, 3, &idx) ); */
  /* printf("x max idx = %d\n",idx); */
  /* CUBLAS_ERROR( cublasIdamin(handle, N_RAY, d__coord+1, 3, &idx) ); */
  /* printf("y min idx = %d\n",idx); */
  /* CUBLAS_ERROR( cublasIdamax(handle, N_RAY, d__coord+1, 3, &idx) ); */
  /* printf("y max idx = %d\n",idx); */

  HANDLE_ERROR( cudaMemset(d__opd, 0, sizeof(double)*N_x*N_y ) );
  dim3 blockDim(16,16);
  dim3 gridDim(N_RAY/256+1,1);
  get_optical_path_difference_interp_kernel LLL gridDim , blockDim RRR (d__opd, d__ray, N_RAY,
  									delta_x, N_x,
  									delta_y, N_y,
  									L, N_L);
  /* cublasDestroy(handle); */
  /* HANDLE_ERROR( cudaFree( d__coord) ); */
}
@ with
<<OPD nearest neighbor interpolation kernel>>=
__global__ void get_optical_path_difference_interp_kernel(double *d__opd,
                                                     ray* d__ray, int N_RAY,
						     float const delta_x, int N_x, 
						     float const delta_y, int N_y,
						     float const L, int const N_L)
{
  /*
  int i, j, k, kl;
  float x, y;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  k = j * gridDim.x * blockDim.x + i;
  if ( (k<N_RAY) && (d__ray[k].v) )
    {
      x = d__ray[k].coordinates.x;
      y = d__ray[k].coordinates.y;
      x /= delta_x;
      y /= delta_y;
      x += (N_x - 1)*0.5;
      y += (N_y - 1)*0.5;
      i = (int) roundf( x );
      j = (int) roundf( y );
      kl = i + N_x*j;
      if ( (i<0) || (i>=N_x) )
	{
	  d__opd[kl] = 0;
	  return;
	}  
      if ( (j<0) || (j>=N_y) )
	{
	  d__opd[kl] = 0;
	  return;
	}  
      d__opd[k] = d__ray[k].optical_path_difference;
    }
  */
  int i, j, k, l;
  rtd x, y;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  k = j * gridDim.x * blockDim.x + i;
  if ( (k<N_RAY) && (d__ray[k].v) )
    {
      x = d__ray[k].coordinates.x;
      y = d__ray[k].coordinates.y;
      x /= delta_x;
      y /= delta_y;
      x += (N_x - 1)*0.5;
      y += (N_y - 1)*0.5;
      i = (int) rint( x );
      j = (int) rint( y );
      l = i + N_x*j;
      if ( ( (i>=0) && (i<N_x) ) && ( (i>=0) && (i<N_y) ) )
	d__opd[l]   = d__ray[k].optical_path_difference;
    }
}
@ 
<<gathering ray vignetting map>>=
void bundle::get_vignetting(double *d__v)
{
  dim3 blockDim(16,16);
  dim3 gridDim(N_RAY/256+1,1,N_BUNDLE);
  get_vignetting_kernel LLL gridDim , blockDim RRR (d__v, d__ray, N_RAY);
}
@ 
<<gathering ray vignetting map kernel>>=
  __global__ void get_vignetting_kernel(double *d__v, ray *d__ray, int N_RAY)
{
  int i, j, k, iSource;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  k = j * gridDim.x * blockDim.x + i;
  iSource = blockIdx.z;
  if ( k<N_RAY )
    k += iSource*N_RAY;
    d__v[k]   = (d__ray[k].v==1) ? 1.0 : 0.0;
}
@ 
<<gathering wavefront>>=
void bundle::get_wavefront(source *src)
{
//  printf("Setting wavefront!\n");
  dim3 blockDim(16,16);
  dim3 gridDim(N_RAY/256+1,1, N_BUNDLE);
  get_wavefront_kernel LLL gridDim , blockDim RRR (src->wavefront.amplitude, 
                                                   src->wavefront.phase,
						   V.m,
                                                   d__ray, N_RAY);
  V.set_filter();
  src->wavefront.masked(&V);
}
@ 
<<gathering wavefront kernel>>=
__global__ void get_wavefront_kernel(float *amplitude, float *phase,
                                     char *m, ray *d__ray, int N_RAY)
{
  int i, j, k, iSource;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  iSource = blockIdx.z;
  k = j * gridDim.x * blockDim.x + i;
  if ( k<N_RAY )
    k += iSource*N_RAY;
    if (d__ray[k].v==1)
      {
	m[k]         = 1;
	amplitude[k] = 1.0;
	phase[k]     = d__ray[k].optical_path_difference;
      } else {
	m[k]         = 0;
	amplitude[k] = 0.0;
	phase[k]     = 0.0;
    }
}
@ 

\subsection{Resetting}
\label{sec:resetting}

The ray vignetting is reset with
<<ray bundle functions (opt-out)>>= 
void bundle::reset(source *src) 
{
  dim3 blockDim(1,1);
  dim3 gridDim(1,1, N_BUNDLE);
  if (strcmp(geom,"box")==0)
     <<bundle coordinates (box)>>
  if (strcmp(geom,"fan")==0)
     <<bundle coordinates>>
}
@ with 
<<bundle reset kernel>>=
__global__ void reset_kernel(ray *d__ray, int N_RAY)
{
  int i, j, k;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  k = j * gridDim.x * blockDim.x + i;
  if ( k<N_RAY )
    d__ray[k].v = 0;
}
@

\section{Coordinate system}
\label{sec:coordinate-system}

The surface location and orientation with respect to the GCS is specified with a coordinate vector:
<<coordinate system data>>=
vector *origin;
@ and with 3 Euler angles with respected to the x, y and z axis.
<<coordinate system data>>=
vector *euler_angles;
@ The surface can be made of [[N]] identical segments
<<coordinate system data>>=
int N; 
@
The rotation matrix [[R]] used to transform the ray coordinates into the surface coordinates (and back!) is defined with
<<coordinate system data>>=
rtd *R, *d__R;
float *float_R;
vector *d__origin;
@ 
Coordinate systems can be tagged:
<<coordinate system data>>=
char tag[32];
@ 
They are gathered in a new coordinate system data type
<<coordinate system data type>>=
typedef struct {
  <<coordinate system data>>
  void setup(void);
  void setup(vector _origin_, vector _euler_angles_);
  void setup(vector *_origin_, vector *_euler_angles_, int _N_);
  void setup(vector *_origin_, vector *_euler_angles_, int _N_, char *_tag_);
  void cleanup(void);
  void info(void);
  void update(vector _origin_, vector _euler_angles_,int idx);
} coordinate_system;
@ 

\subsection{Setup \& Cleanup}
\label{sec:setup--cleanup}

A coordinate system structure is initialized with
\begin{itemize}
\item a single origin and orientation,
<<coordinate system functions>>=
void coordinate_system::setup(vector _origin_, vector _euler_angles_)
{
  N = 1;
  HANDLE_ERROR( cudaMalloc((void**)&d__R, sizeof(rtd)*9*N ) );
  HANDLE_ERROR( cudaMalloc((void**)&d__origin, sizeof(vector)*N ) );
  int n_byte = sizeof(vector)*N;
  origin = (vector *)malloc( n_byte );
  euler_angles = (vector *)malloc( n_byte );
  memcpy( origin , &_origin_ , n_byte);
  memcpy(euler_angles,  &_euler_angles_, n_byte);
  <<rotation matrix eval>>
  strcpy(tag,"coordinate_system");
  info();
}
@ 
\item origin and orientation align to the main coordinate system,
<<coordinate system functions>>=
void coordinate_system::setup(void)
{
  N = 1;
  HANDLE_ERROR( cudaMalloc((void**)&d__R, sizeof(rtd)*9*N ) );
  HANDLE_ERROR( cudaMalloc((void**)&d__origin, sizeof(vector)*N ) );
  int n_byte = sizeof(vector)*N;
  origin = (vector *)malloc( n_byte );
  euler_angles = (vector *)malloc( n_byte );
  origin[0].x = 0;
  origin[0].y = 0;
  origin[0].z = 0;
  euler_angles[0].x = 0;
  euler_angles[0].y = 0;
  euler_angles[0].z = 0;
  <<rotation matrix eval>>
  strcpy(tag,"coordinate_system");
  info();
}
@ 
\item an array of [[N]] origins and orientations:
  \begin{itemize}
  \item without a tag:
<<coordinate system functions>>=
void coordinate_system::setup(vector *_origin_, vector *_euler_angles_, int _N_)
{
  strcpy(tag,"coordinate_system");
  <<coordinate system setup common>>
}
@
\item or with a tag:
<<coordinate system functions>>=
void coordinate_system::setup(vector *_origin_, vector *_euler_angles_, 
                              int _N_, char *_tag_)
{
  strcpy(tag,_tag_);
  <<coordinate system setup common>>
}
@  
\end{itemize}
where 
<<coordinate system setup common>>=
N = _N_;
HANDLE_ERROR( cudaMalloc((void**)&d__R, sizeof(rtd)*9*N ) );
HANDLE_ERROR( cudaMalloc((void**)&d__origin, sizeof(vector)*N ) );
int n_byte = sizeof(vector)*N;
origin = (vector *)malloc( n_byte );
euler_angles = (vector *)malloc( n_byte );
memcpy( origin , _origin_ , n_byte);
memcpy(euler_angles,  _euler_angles_, n_byte);
<<rotation matrix eval>>
info();
@ 
\end{itemize}

The rotation matrix to transform the ray coordinates in the LCS is given by
\begin{eqnarray}
R &=& \left[ 
  \begin{array}{ccc}
    c\gamma & -s\gamma & 0 \\
    s\gamma &  c\gamma & 0 \\
    0       &  0       & 1
  \end{array}
  \right] \left[
  \begin{array}{ccc}
    c\beta & 0 & s\beta \\
    0      & 1 &  0 \\
    -s\beta & 0 &  c\beta
  \end{array}
  \right] \left[
    \begin{array}{ccc}
      1       &  0       & 0 \\
      0       &  c\alpha & -s\alpha \\
      0       &  s\alpha &  c\alpha 
    \end{array}
\right] \\
&=& \left[
  \begin{array}{ccc}
    c\beta c\gamma &  s\alpha s\beta c\gamma - c\alpha s\gamma & c\alpha s\beta c\gamma + s\alpha s\gamma \\
    c\beta s\gamma &  s\alpha s\beta s\gamma + c\alpha c\gamma & c\alpha s\beta s\gamma - s\alpha c\gamma \\
    -s\beta         &  s\alpha c\beta                           &  c\alpha c\beta
  \end{array}
\right]
\end{eqnarray}
where $cx$ and $sx$ stands for $\sin(x)$ and $\cos(x)$, respectively.
$\alpha$, $\beta$ and $\gamma$ are the Euler angles along the x, y and z axis respectively.
The matrix is computed with
<<rotation matrix eval>>=
R = (rtd *)malloc( sizeof(rtd)*9*N );
rtd ca, sa, cb, sb, cg, sg;
int k, idx;
for (k=0; k<N; k++)
  {
    idx = k;
    <<rotation matrix definition>>
  }
<<CS from host to device>>
/* for (k=0;k<9*N;k++) */
/*    *(float_R+k) = (float) R[k]; */
@ with
<<rotation matrix definition>>=
ca = cos(euler_angles[idx].x);
sa = sin(euler_angles[idx].x);
cb = cos(euler_angles[idx].y);
sb = sin(euler_angles[idx].y);
cg = cos(euler_angles[idx].z);
sg = sin(euler_angles[idx].z);
idx *= 9;
R[idx++] = cb*cg;
R[idx++] = sa*sb*cg - ca*sg;
R[idx++] = ca*sb*cg + sa*sg;
R[idx++] = cb*sg;
R[idx++] = sa*sb*sg + ca*cg;
R[idx++] = ca*sb*sg - sa*cg;
R[idx++] = -sb;
R[idx++] = sa*cb;
R[idx++] = ca*cb;
@ and
<<CS from host to device>>=
HANDLE_ERROR( cudaMemcpy( d__R, R, 
			    sizeof(rtd)*9*N, cudaMemcpyHostToDevice ) );
HANDLE_ERROR( cudaMemcpy( d__origin, origin, 
			    sizeof(vector)*N, cudaMemcpyHostToDevice ) );
@ where the elements of $R$ are stored in the row major format.
<<coordinate system functions>>=
void coordinate_system::cleanup(void)
{
  fprintf(stdout,"@(CEO)>coordinate_system: freeing memory!\n");
  free( origin );
  free( euler_angles );
  free(R);
  HANDLE_ERROR( cudaFree( d__R ) );
  HANDLE_ERROR( cudaFree( d__origin ) );
}
@ 
The coordinate system is updated with
<<coordinate system functions>>=
void coordinate_system::update(vector _origin_, vector _euler_angles_,int idx)
{
  int n_byte = sizeof(vector);
  memcpy( origin + idx , &_origin_ , n_byte);
  memcpy(euler_angles + idx,  &_euler_angles_, n_byte);
  rtd ca, sa, cb, sb, cg, sg;
  <<rotation matrix definition>>
  <<CS from host to device>>
  /* for (int k=0;k<9*N;k++) */
  /*   *(float_R+k) = (float) R[k]; */
}
@ 
\subsection{Input/Output}
\label{sec:inputoutput}

The main parameters of the coordinate systems are displayed with the [[info]] routine:
<<coordinate system functions>>=
void coordinate_system::info(void)
{
  fprintf(stdout,"\n\x1B[1;42m@(CEO)>%s:\x1B[;42m\n",tag);
  fprintf(stdout," ID (Tx          Ty        Tz)[m]  (Ox         Oy         Oz)[deg]\n");
  float c = 180.0/PI;
  int k;//, i, j, idx;
  for (k=0; k<N; k++)
    {
      fprintf(stdout," %2d  %+.3e   %+.3e   %+.3e      %+.3e   %+.3e   %+.3e\n", k,
	      origin[k].x, origin[k].y, origin[k].z,
	      euler_angles[k].x*c, euler_angles[k].y*c, euler_angles[k].z*c);
      /*
      fprintf(stdout,"Direction cosine matrix:\n");
      for (i=0;i<3;i++)
	{
	  fprintf(stdout,"||  ");
	  for (j=0;j<3;j++)
	    {
	      idx = j + i*3 + k*9;
	      fprintf(stdout,"%+.3e  ",R[idx]);
	    }
	  fprintf(stdout,"||\n");
	}
      */
    }
  fprintf(stdout,"----------------------------------------------------\x1B[0m\n");
}
@ 

\section{Conic surface}
\label{sec:surface}

A conic surface is represented with the [[conic]] structure:
<<conic structure>>=
struct conic {

  <<conic parameters>>
  
  void setup(rtd _c_, rtd _k_);
  void setup(rtd _c_, rtd _k_, vector _origin_, vector _euler_angles_);
  void setup(rtd _c_, rtd _k_, vector _origin_, vector _euler_angles_, vector conic_origin);
  void cleanup(void);
};
@
A conic surface is defined at a given location within a given coordinate system:
<<conic parameters>>=
coordinate_system ref_frame; 
vector origin, *d__origin;
@
The conic shape is specified with two parameters:
<<conic parameters>>=
rtd c, k;
@ 
where [[c]] is the vertex curvature and [[k]] is the conic parameter.

The conic surface is defined with
\begin{equation}
 \label{eq:4}
  F(x,y,z) = z - {c\rho^2 \over 1 + \sqrt{1 - \kappa c^2 \rho^2} } = 0.
\end{equation}

<<conic equations>>=
__host__ __device__ inline rtd conic_equation(vector *v, vector *v0, const rtd k, const rtd c)
{
  if (c==0)
    return 0.0;
  else {    
    rtd rho2;
    rho2 = c*v->rho2(v0->x,v0->y);
    if (k==0)
      return rho2*0.5;
    else
      return rho2/( 1 + sqrt(1 - k*c*rho2) );
  }
}
@ 
<<conic equations>>=
__device__ inline rtd conic_surface(vector *v, vector *v0, const rtd k, const rtd c,
				    const int max_n, rtd *a, const rtd R)
{
  rtd zern_surf;
    zern_surf = zernike_surface(v->mag(R), v->angle(), max_n, a);
  if (c==0)
    return v->z - v0->z - zern_surf;
  else {    
    rtd rho2;
    rho2 = c*v->rho2(v0->x,v0->y);
    if (k==0)
      return v->z - rho2*0.5 - v0->z - zern_surf;
    else
      return v->z - rho2/( 1 + sqrt(1 - k*c*rho2) ) - v0->z - zern_surf;
  }
}
@ 
The partial derivative of the conic equation are written
\begin{itemize}
\item
  \begin{equation}
    { \partial F(x,y,z) \over \partial x } = -x {c \over \sqrt{ 1 - \kappa c^2 \rho^2 } }
  \end{equation}
<<conic equations>>=
 __device__ inline rtd partial_x_conic_surface(vector *v, vector *v0, 
					       const rtd k, const rtd c,
					       const int max_n, rtd *cx,
					       const rtd R)
{
  rtd px_zern_surf;
  px_zern_surf = zernike_surface(v->mag(R), v->angle(), max_n-1, cx);
  if (c==0)
    return -px_zern_surf;
  else    
    if (k==0)
      return -(v->x - v0->x)*c - px_zern_surf;
    else {
      rtd rho2;
      rho2 = c*v->rho2(v0->x,v0->y);
      return -(v->x - v0->x)*c*rsqrt(1 - k*c*rho2) - px_zern_surf;
    }
}
@
\item
  \begin{equation}
    { \partial F(x,y,z) \over \partial y } = -y {c \over \sqrt{ 1 - \kappa c^2 \rho^2 } }
  \end{equation}
<<conic equations>>=
__device__ inline rtd partial_y_conic_surface(vector *v, vector *v0, 
					      const rtd k, const rtd c,
					      const int max_n, rtd *cy,
					      const rtd R)
{
  rtd py_zern_surf;
  py_zern_surf = zernike_surface(v->mag(R), v->angle(), max_n-1, cy);
  if (c==0)
    return -py_zern_surf;
  else    
    if (k==0)
      return -(v->y - v0->y)*c - py_zern_surf;
    else {
      rtd rho2;
      rho2 = c*v->rho2(v0->x,v0->y);
      return -(v->y - v0->y)*c*rsqrt(1 - k*c*rho2) - py_zern_surf;
    }
}
@
\item
  \begin{equation}
    { \partial F(x,y,z) \over \partial z } = 1
  \end{equation}
<<conic equations>>=
__device__ inline rtd partial_z_conic_surface(void)
{
  return 1.0;
}
@
\end{itemize}

\subsection{Setup \& Cleanup}
\label{sec:surf-setup--cleanup}

A conic surface is initialized with the [[setup]] routine:
<<conic functions>>=
void conic::setup(rtd _c_, rtd _k_, vector _origin_, vector _euler_angles_)
{
  c = _c_;
  k = _k_;
  origin.x = 0;
  origin.y = 0;
  origin.z = 0;
  ref_frame.setup(_origin_, _euler_angles_);
  <<conic allocation>>
}
@ or with a surface centered on [[origin]]
<<conic functions>>=
void conic::setup(rtd _c_, rtd _k_, vector _origin_, vector _euler_angles_, vector conic_origin)
{
  c = _c_;
  k = _k_;
  origin.x = conic_origin.x;
  origin.y = conic_origin.y;
  origin.z = conic_origin.z;
  ref_frame.setup(_origin_, _euler_angles_);
  <<conic allocation>>
}
@
A conic surface that sets in the GCS is simply defined with
<<conic functions>>=
void conic::setup(rtd _c_, rtd _k_)
{
  c = _c_;
  k = _k_;
  origin.x = 0;
  origin.y = 0;
  origin.z = 0;
  ref_frame.setup();
  <<conic allocation>>
}
<<conic allocation>>=
HANDLE_ERROR( cudaMalloc((void**)&d__origin, sizeof(vector) ) );
HANDLE_ERROR( cudaMemcpy( d__origin, &origin, 
			    sizeof(vector), cudaMemcpyHostToDevice ) );
@ 
The GMT M1 segmented conic is defined with
<<conic functions (opt-out)>>=
void conic::setup_GMT_M1(void)
{
  c = 1./36.0;
  k = 1 - 0.9982857;
  D_seg = 8.365;
  ri    = 2.4412/8.365;
  N = 7;
  vector origin[7];
  vector euler_angles[7];
  origin[0].x = origin[0].y = origin[0].z = 0.0;
  euler_angles[0].x = euler_angles[0].y = euler_angles[0].z = 0.0;
  rtd D_c, o, zo, sa;
  sa = sin(13.522*PI/180);
  D_c = 8.710 - (0.691-0.445)*sa;
  zo = 8.417*sa*0.5 + 0.691 - 0.445;
  int k;  
  for (k=1; k<N; k++)
  {
    o = PI*(2*k-1)/6.0;
    origin[k].x = D_c*cosf(o);
    origin[k].y = D_c*sinf(o);
    origin[k].z = zo;
    euler_angles[k].x = 0.0;
    euler_angles[k].y = 0.0
    euler_angles[k].z = 0.0;
  }
  ref_frame.setup(origin, euler_angles, N);
}
@
Memory is freed with
<<conic functions>>=
void conic::cleanup(void)
{
  fprintf(stdout,"@(CEO)>conic: freeing memory!\n");
  ref_frame.cleanup();
  HANDLE_ERROR( cudaFree( d__origin ) );
}
@

\section{Zernike surface}
\label{sec:zernike-surface}

A Zernike surface is defined as the weighted sum of Zernike polynomials and it is represented with the [[zernikeS]] structure:
<<zernikeS structure>>=
struct zernikeS {
  <<zernikeS parameters>>
  void setup(int max_n, rtd *a);
  void setup(int _max_n_, rtd *_a_, int _N_);
  void setup(int max_n, rtd *a, vector _origin_, vector _euler_angles_);
  void setup(int max_n, rtd *a, vector _origin_, vector _euler_angles_, int _N_);
  void cleanup(void);
  void surface(rtd *S, rtd *r, rtd *o, const int N);
  void surface(rtd *S, rtd *r, rtd *o, const int N, int surf_id);
  void update(rtd *a);
  void surface_derivative_coefs(void);
  void surface_derivatives(rtd *d__dSdx, rtd *d__dSdy, rtd *d__r, rtd *d__o, const int N);
};
@ 
A Zernike surface is given by
\begin{equation}
  \label{eq:43}
  \varphi\left( \vec r \right) = \sum_{j=1}^J a_j Z_j\left(\vec r\right),
\end{equation}
where $a_j$ is the Zernike coefficients corresponding to the Zernike polynomials $Z_j\left(\vec r\right)$ and $\vec r$ is a vector defined such as $0\leq r \geq 1$.
Zernike polynomials are defined as:
\begin{equation}
  \label{eq:44}
  Z_j\left(\vec r\right) = \sqrt{n+1} R_{nm}(r) A_{jm}(\theta),
\end{equation}
where
\begin{equation}
  \label{eq:45}
  R_{nm}(r) = \sum_{k=0}^{n-m\over 2}(-1)^k{(n-k)! \over k!\left( {n+|m|\over 2} -k \right)!\left( {n-|m|\over 2} -k \right)!}r^{n-2k},
\end{equation}
and
\begin{equation}
  \label{eq:46}
  A_{jm}(\theta) = 2^{1-\delta_{m0}\over 2}\cos\left( m\theta + (1-\delta_{m0})((-1)^j-1){\pi\over 4} \right),
\end{equation}
with $\delta_{m0}$ the Kronecker symbol.

The parameters of the [[zernikeS]] structure are
\begin{itemize}
\item the Zernike mode [[j]], radial order [[n]] and azimuthal order [[m]]
<<zernikeS parameters>>=
int max_n;
unsigned int j, n, m, n_mode;
@
\item the Zernike coeffcients [[a]]
<<zernikeS parameters>>=
rtd *a, *d__a;
@
\item the Zernike derivative coefficients [[bx]] and [[by]]
<<zernikeS parameters>>=
rtd *bx, *by, *d__bx, *d__by;
@
\item the arrays for the sparse column format storage of [[bx]] and [[by]]
<<zernikeS parameters>>=
unsigned int *bx_row_idx, *bx_col_ptr, 
             *by_row_idx, *by_col_ptr,
             bx_nnz, by_nnz;
@
\item the Zernike surface derivative coefficients [[c]]
<<zernikeS parameters>>=
rtd *cx, *d__cx, *cy, *d__cy;
@
\item the number of Zernike surfaces [[N]]
<<zernikeS parameters>>=
int N;
@
\end{itemize}
Eq.~(\ref{eq:43}) is re--written
\begin{equation}
  \label{eq:51}
  \varphi\left( \vec r \right) = \sum_{n=0}^N \sqrt{n+1} \sum_{m=n}^{
    \begin{array}{c}
m=m-2\\
 m\geq 0
\end{array}
} R_{nm}(r) \left\{
    \begin{array}{l}
      \sqrt{2} \left[ a_j \cos(m\theta) + a_j\sin(m\theta) \right] \\
      a_j
    \end{array}
\right\}
\end{equation}

The Zernike surface is defined in a given coordinate system:
<<zernikeS parameters>>=
coordinate_system ref_frame; 
@ 

\subsection{Setup \& Cleanup}
\label{sec:setup--cleanup-3}

A [[zernikeS]] structure is initialized with the largest radial order in the surface and the series of Zernike coefficients for all the modes up to that radial order:
<<zernikeS functions>>=
void zernikeS::setup(int _max_n_, rtd *_a_)
{
  N = 1;
  max_n = _max_n_;
  n_mode = (max_n+1.0)*(max_n+2.0)*0.5;
  int n_byte = sizeof(rtd)*n_mode;
  a = (rtd *)malloc( n_byte );
  memcpy( a, _a_,  n_byte);
  HANDLE_ERROR( cudaMalloc((void**)&d__a, n_byte ) );
  HANDLE_ERROR( cudaMemcpy( d__a, a, 
			    n_byte, cudaMemcpyHostToDevice ) );

  ref_frame.setup();
  
  <<zernikeS setup common>>
}
@ 
The origin vector and Euler angles of the coordinate systems where the Zernike polynomials are defined can be passed as arguments:
<<zernikeS functions>>=
void zernikeS::setup(int _max_n_, rtd *_a_, vector _origin_, vector _euler_angles_)
{
  N = 1;
  max_n = _max_n_;
  n_mode = (max_n+1.0)*(max_n+2.0)*0.5;
  int n_byte = sizeof(rtd)*n_mode;
  a = (rtd *)malloc( n_byte );
  memcpy( a, _a_,  n_byte);
  HANDLE_ERROR( cudaMalloc((void**)&d__a, n_byte ) );
  HANDLE_ERROR( cudaMemcpy( d__a, a, 
			    n_byte, cudaMemcpyHostToDevice ) );

  ref_frame.setup(_origin_, _euler_angles_);
  
  <<zernikeS setup common>>
}
@ 
An array of [[N]] Zernike surface is created with
<<zernikeS functions>>=
void zernikeS::setup(int _max_n_, rtd *_a_, int _N_)
{
  N = _N_;
  max_n = _max_n_;
  n_mode = (max_n+1.0)*(max_n+2.0)*0.5;
  int n_byte = sizeof(rtd)*n_mode*N;
  a = (rtd *)malloc( n_byte );
  memcpy( a, _a_,  n_byte);
  HANDLE_ERROR( cudaMalloc((void**)&d__a, n_byte ) );
  HANDLE_ERROR( cudaMemcpy( d__a, a, 
			    n_byte, cudaMemcpyHostToDevice ) );

  ref_frame.setup();
  
  <<zernikeS setup common>>
}
@ or with
<<zernikeS functions>>=
void zernikeS::setup(int _max_n_, rtd *_a_, vector _origin_, vector _euler_angles_, int _N_)
{
  N = _N_;
  max_n = _max_n_;
  n_mode = (max_n+1.0)*(max_n+2.0)*0.5;
  int n_byte = sizeof(rtd)*n_mode*N;
  a = (rtd *)malloc( n_byte );
  memcpy( a, _a_,  n_byte);
  HANDLE_ERROR( cudaMalloc((void**)&d__a, n_byte ) );
  HANDLE_ERROR( cudaMemcpy( d__a, a, 
			    n_byte, cudaMemcpyHostToDevice ) );

  ref_frame.setup(_origin_, _euler_angles_);
  
  <<zernikeS setup common>>
}
@ where
<<zernikeS setup common>>=
if (max_n==0)
  return;

fprintf(stdout,"Computing Zernike derivative coefficients: ....");

int nel = n_mode*n_mode/2;
int n_col_ptr = (max_n+1.0)*max_n*0.5 + 1;

bx = (rtd *) malloc( sizeof(rtd)*nel);
bx_row_idx = (unsigned int *) malloc( sizeof(unsigned int)*nel);
bx_col_ptr = (unsigned int *) malloc( sizeof(unsigned int)*n_col_ptr);
memset( bx_col_ptr, 0 , sizeof(unsigned int)*n_col_ptr );

by = (rtd *) malloc( sizeof(rtd)*nel);
by_row_idx = (unsigned int *) malloc( sizeof(unsigned int)*nel);
by_col_ptr = (unsigned int *) malloc( sizeof(unsigned int)*n_col_ptr);
memset( by_col_ptr, 0 , sizeof(unsigned int)*n_col_ptr );

<<Zernike derivative coefficients>>
fprintf(stdout,"\b\b");
/*
fprintf(stdout,"bx_nnz=%d\n",bx_nnz);
fprintf(stdout,"b ; row_idx ; col_ptr\n");
for (int k=0;k<bx_nnz;k++) {
  if (k<n_col_ptr)
  fprintf(stdout,"b=%+4.2f ; %2d ; %2d\n",bx[k],bx_row_idx[k],bx_col_ptr[k]);
  else
  fprintf(stdout,"b=%+4.2f ; %2d\n",bx[k],bx_row_idx[k]);
}
fprintf(stdout,"by_nnz=%d\n",by_nnz);
fprintf(stdout,"b ; row_idy ; col_ptr\n");
for (int k=0;k<by_nnz;k++) {
  if (k<n_col_ptr)
  fprintf(stdout,"b=%+4.2f ; %2d ; %2d\n",by[k],by_row_idx[k],by_col_ptr[k]);
  else
  fprintf(stdout,"b=%+4.2f ; %2d\n",by[k],by_row_idx[k]);
}
*/

n_byte = N*sizeof(rtd)*(n_col_ptr-1);
cx = (rtd *) malloc( n_byte );
HANDLE_ERROR( cudaMalloc((void**)&d__cx, n_byte ) );

cy = (rtd *) malloc( n_byte );
HANDLE_ERROR( cudaMalloc((void**)&d__cy, n_byte ) );

surface_derivative_coefs();
fprintf(stdout,"\b\b");

HANDLE_ERROR( cudaMemcpy( d__cx, cx, 
			  n_byte, cudaMemcpyHostToDevice ) );
HANDLE_ERROR( cudaMemcpy( d__cy, cy, 
			  n_byte, cudaMemcpyHostToDevice ) );
fprintf(stdout,"\b\b!\n");
@ 
The Zernike derivative coefficients are saved into a sparse matrix using the compressed column storage:
<<Zernike derivative coefficients>>=
int j, n, m, jp, np, mp, kx=0, ky=0;
for (np=0;np<max_n;np++) {
  jp = np*(np+1)/2 + 1;
  mp = np%2;
  while (mp<=np) {
    <<Zernike derivative coefficients: part 2>>
      ++jp;
    if (mp>0) {
       <<Zernike derivative coefficients: part 2>>
	++jp;
    }
    mp += 2;
  }
 }
bx_col_ptr[jp-1] = kx;
bx_nnz = kx;
by_col_ptr[jp-1] = ky;
by_nnz = ky;
@
<<Zernike derivative coefficients: part 2>>=
for (n=np+1;n<=max_n;n++) {
  j = n*(n+1)/2 + 1;
  m = n%2;
  while (m<=n) {
    <<Zernike derivative coefficients: part 2a>>
    ++j;
    if (m>0) {
      <<Zernike derivative coefficients: part 2a>>
      ++j;
    }
    m += 2;
  }
 }
bx_col_ptr[jp] = kx;
by_col_ptr[jp] = ky;
@ 
<<Zernike derivative coefficients: part 2a>>=
  if (zern_dx_coef(bx+kx,j,n,m,jp,np,mp)) {
    bx_row_idx[kx] = j-1;
    ++kx;
  }
  if (zern_dy_coef(by+ky,j,n,m,jp,np,mp)) {
    by_row_idx[ky] = j-1;
    ++ky;
  }
@
From the Zernike derivative coefficients, the coefficients of the Zernike surface derivative are computed:
<<zernikeS functions>>=
void zernikeS::surface_derivative_coefs(void) 
{
  int k,l,n,p, idx_a, idx_c;
  n = (max_n+1.0)*max_n*0.5;
  for (p=0;p<N;p++) {
    idx_a = p*n_mode;
    idx_c = p*n;
    for (k=0;k<n;k++) {
      cx[idx_c] = 0.0;
      for (l=bx_col_ptr[k];l<bx_col_ptr[k+1];l++)
	cx[idx_c] += a[ bx_row_idx[l] + idx_a ] * bx[l];
      /* fprintf(stdout,"cx = %4.2f\n",cx[k]); */
      cy[idx_c] = 0.0;
      for (l=by_col_ptr[k];l<by_col_ptr[k+1];l++)
	cy[idx_c] += a[ by_row_idx[l] + idx_a ] * by[l];
      /* fprintf(stdout,"cy = %4.2f\n",cy[k]); */
      idx_c++;
    }
  }
}
@ 
The Zernike coefficients are updated with
<<zernikeS functions>>= 
void zernikeS::update(rtd *_a_)
{
  int n_byte = sizeof(rtd)*n_mode*N;
  memcpy( a, _a_,  n_byte);
  HANDLE_ERROR( cudaMemcpy( d__a, a, 
			    n_byte, cudaMemcpyHostToDevice ) );
  surface_derivative_coefs();

  int n_col_ptr = (max_n+1.0)*max_n*0.5 + 1;
  n_byte = N*sizeof(rtd)*(n_col_ptr-1);
  HANDLE_ERROR( cudaMemcpy( d__cx, cx, 
			    n_byte, cudaMemcpyHostToDevice ) );
  HANDLE_ERROR( cudaMemcpy( d__cy, cy, 
			    n_byte, cudaMemcpyHostToDevice ) );
}
@
Memory is freed with:
<<zernikeS functions>>=
void zernikeS::cleanup(void)
{
  free( a );
  free( bx );
  free( bx_row_idx );
  free( bx_col_ptr );
  free( by );
  free( by_row_idx );
  free( by_col_ptr );
  free( cx );
  free( cy );
  HANDLE_ERROR( cudaFree( d__a) );
  HANDLE_ERROR( cudaFree( d__cx) );
  HANDLE_ERROR( cudaFree( d__cy) );
}
@
\subsection{Zernike surface equation}
\label{sec:zern-surf-equat}

<<zernikeS functions>>=
void zernikeS::surface(rtd *d__S, rtd *d__r, rtd *d__o, const int N)
{
    dim3 blockDim(16,16);
    dim3 gridDim(N/256+1,1);
    surface_kern LLL gridDim, blockDim RRR (d__S, d__r, d__o, N, max_n, d__a);
}
@ 
<<zernikeS functions>>=
void zernikeS::surface(rtd *d__S, rtd *d__r, rtd *d__o, const int N, int surf_id)
{
  fprintf(stdout,"a offset = %d\n",surf_id*n_mode);
    dim3 blockDim(16,16);
    dim3 gridDim(N/256+1,1);
    surface_kern LLL gridDim, blockDim RRR (d__S, d__r, d__o, N, max_n, d__a + surf_id*n_mode);

}
@ with 
<<zernike surface kernel>>=
__global__ void surface_kern(rtd *S, rtd *r, rtd *o, const int N, 
			     int max_n, rtd *a)
{
  int i, j, k;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  k = j * gridDim.x * blockDim.x + i;
  if (k<N) {
    S[k] = zernike_surface(r[k], o[k], max_n, a);
  }
}
@ where
<<zernike surface equation>>=
__host__ __device__ rtd zernike_surface(rtd r, rtd o, int max_n, rtd *a)
{
  int n, m, mH, a_idx,j;
  rtd R, R2, R4, A, S_n, S, 
    H1, H2, H3, sm, cm, s2, c2, s ,c, sqrt2;
  if ( (r>1.0) || (max_n<0) )
    S = 0.0;
  else {
    R = 1.0;
    S = a[0]*R;
    <<zernike surface: radial order sum>>
    }
  return S;
}
@ 
The Zernike surface is computed by summing all the azimuthal order of a each radial order from the highest to the lowest azimuthal order.
The Zernike coefficients [[a]] are ordered by increasing azimuthal order.
<<zernike surface: radial order sum>>=
sqrt2 = sqrt(2.0);
sincos(2*o,&s2,&c2);
for (n=1;n<=max_n;n++) {
  j = (n+1)*(n+2)/2;
  a_idx = j - 1;

  m = n;
  R = pow(r,n);
  sincos(m*o, &sm, &cm);
  if (j%2) {
    A = a[a_idx--]*sm;
    A += a[a_idx--]*cm;
  } else {
    A = a[a_idx--]*cm;
    A += a[a_idx--]*sm;
  }
  j -= 2;
  A *= sqrt2;
  S_n = R*A;

  m -= 2;
  if (m>=0) {
    R2 = n*R - (n-1.0)*pow(r,m);
    <<azimuth>>
    S_n += R2*A;
  }

  m -= 2;
  while (m>=0) {
    mH = m + 4;
    if (r>0) {
      <<H3>>
      <<H2>>
      <<H1>>
      <<R recurrence>>
      <<azimuth>>
    } else {
      R4 = (m==0) ? pow(-1.0,0.5*n) : 0.0;
      A = 1.0;
    }
    S_n += R4*A;
    R  = R2;
    R2 = R4;
    m -= 2;
  }
  S += sqrt(n+1.0)*S_n;
}
@ 
The azimuthal function are computed in a decreasing $m$ order starting from $m=n$, to $n-2$, $n-4$,...
The azimuthal function are derived using the following recurrence relation
\begin{eqnarray}
  \label{eq:54}
  \cos(m-2\theta) &=& \cos(m\theta)\cos(2\theta) + \sin(m\theta)\sin(2\theta) \\
  \sin(m-2\theta) &=& \sin(m\theta)\cos(2\theta) - \cos(m\theta)\sin(2\theta) 
\end{eqnarray}
<<azimuth>>=
  if (m>0) {
    c = cm*c2 + sm*s2;
    s = sm*c2 - cm*s2;
    if (j%2) {
      A = a[a_idx--]*s;
      A += a[a_idx--]*c;
    } else {
      A = a[a_idx--]*c;
      A += a[a_idx--]*s;
    }
    j -= 2;
    A *= sqrt2;
    cm = c;
    sm = s;
  } else {
    A = a[a_idx--];
    --j;
  }
@ 
The radial functions $R_{nm}(r)$ are derived from the recurrence relation\cite{CRM03}:
\begin{equation}
  \label{eq:47}
  R_{n(m-4)}(r) = H_1R_{nm}(r) + \left( H_2 + {H_3 \over r^2} \right) R_{n(m-2)}(r),
\end{equation}
<<R recurrence>>=
R4 = H1*R + ( H2 + H3/(r*r) )*R2;
@
starting at $m=n$ and with
\begin{equation}
  \label{eq:52}
  R_{nn}(r) = r^n,
\end{equation}
and
\begin{equation}
  \label{eq:53}
  R_{n(n-2)}(r) = nR_{nn}(r) - (n-1)R_{(n-2)(n-2)}(r).
\end{equation}
@ 
where
\begin{equation}
  \label{eq:48}
  H_1 = {m(m-1) \over 2} - mH_2 + H_3{ (n+m+2)(n-m) \over 8 },
\end{equation}
<<H1>>=
H1 = mH*(mH-1.0)*0.5 - mH*H2 + H3*(n+mH+2.0)*(n-mH)*0.125;
@ 
\begin{equation}
  \label{eq:49}
  H_2 = H_3{(n+m)(n-m+2) \over 4(m-1) } + (m-2),
\end{equation}
<<H2>>=
H2 = H3*0.25*(n+mH)*(n-mH+2.0)/(mH-1.0) + mH - 2.0;
@ 
and
\begin{equation}
  \label{eq:50}
  H_3 = {-4(m-2)(m-3) \over (n+m-2)(n-m+4) }.
\end{equation}
<<H3>>=
H3 = -4.0*(mH-2.0)*(mH-3.0)/((n+mH-2.0)*(n-mH+4.0));
@

\subsection{Zernike surface derivative}
\label{sec:zern-surf-deriv}

The partial derivative of the Zernike surface given in Eq.~(\ref{eq:43}) is written
\begin{equation}
  \label{eq:55}
  {\partial \varphi \left( \vec r \right) \over \partial x } = \sum_{j=2}^N a_j   {\partial Z_j \left( \vec r \right) \over \partial x },
\end{equation}
where
\begin{equation}
  \label{eq:56}
  {\partial Z_j \left( \vec r \right) \over \partial x } = \sum_{k=1}^{j-1} b_{jk}^x Z_k \left( \vec r \right)
\end{equation}
Inserting Eq.~(\ref{eq:55}) into Eq.~(\ref{eq:56}) leads to
\begin{equation}
  \label{eq:57}
  {\partial \varphi \left( \vec r \right) \over \partial x } = \sum_{j=2}^N a_j \sum_{k=1}^{j-1} b_{jk}^x Z_k \left( \vec r \right) = \sum_{k=1}^{N-1} Z_k \left( \vec r \right) \sum_{j={k+1}}^N a_jb_{jk}^x  = \sum_{k=1}^{N-1} Z_k \left( \vec r \right) c_{k}^x,
\end{equation}
with
\begin{equation}
  \label{eq:58}
  c_k^x = \sum_{j={k+1}}^N a_jb_{jk}^x.
\end{equation}

The x and y derivatives of the Zernike surface are computed with
<<zernikeS functions>>=
void zernikeS::surface_derivatives(rtd *d__dSdx, rtd *d__dSdy, 
				   rtd *d__r, rtd *d__o, const int N)
{
  dim3 blockDim(16,16);
  dim3 gridDim(N/256+1,1);
  surface_kern LLL gridDim, blockDim RRR (d__dSdx, d__r, d__o, N, max_n-1, d__cx);
  surface_kern LLL gridDim, blockDim RRR (d__dSdy, d__r, d__o, N, max_n-1, d__cy);
}
@
Both derivatives depends on the projection coefficients of Zernike x and y derivatives:  
<<zernike derivative x coefficient>>=
int zern_dx_coef(rtd *b, int j, int n, int m, int jp, int np, int mp) 
{
  int delta_m, rule_0, rule_1, rule_2, rule_3;
  delta_m = mp - m;
  rule_0 = (delta_m==1) || (delta_m==-1);
  rule_1 = (j-jp)%2 == 0 && !( (m==0) || (mp==0) );
  rule_2 = ( (m==0) && (mp!=0) ) && (jp%2 == 0);
  rule_3 = ( (m!=0) && (mp==0) ) && (j%2  == 0);
  if ( rule_0 && (rule_1||rule_2||rule_3) )
    *b = sqrt( (n+1.0)*(np+1.0) );
  else 
    return 0;
  if ( (m==0) || (mp==0) )
    *b *= sqrt(2.0);
  return 1;
}
@ 
<<zernike derivative y coefficient>>=
int zern_dy_coef(rtd *b, int j, int n, int m, int jp, int np, int mp) 
{
  int delta_m, rule_0, rule_1, rule_2, rule_3, sign_rule_1, sign_rule_2;
  delta_m = mp - m;
  rule_0 = (delta_m==1) || (delta_m==-1);
  rule_1 = (j-jp)%2 == 1 && !( (m==0) || (mp==0) );
  rule_2 = ( (m==0) && (mp!=0) ) && (jp%2 == 1);
  rule_3 = ( (m!=0) && (mp==0) ) && (j%2  == 1);
  if ( rule_0 && (rule_1||rule_2||rule_3) )
    *b = sqrt( (n+1.0)*(np+1.0) );
  else
    return 0;
  sign_rule_1 = (delta_m==+1) && (j%2 == 1);
  sign_rule_2 = (delta_m==-1) && (j%2 == 0);
  if ( ( (m!=0) && (mp!=0) ) && ( sign_rule_1 || sign_rule_2 ) )
    *b *= -1;
  if ( (m==0) || (mp==0) )
    *b *= sqrt(2.0);
  return 1;
}

@
\section{Aperture}
\label{sec:aperture}

An aperture is a bounded surface used to clip a bundle of ray to the aperture shape.
<<aperture structure>>=
struct aperture {
  <<aperture parameters>>
  void setup(float _D_, int _D_px_, 
	     vector _origin_, vector _euler_angles_);
  void setup(float _D_, float _ri_, int _D_px_, 
	     vector _origin_, vector _euler_angles_);
  void setup(float _D_, float _ri_, float _D_seg_, int _D_px_, 
	     vector *_origin_, vector *_euler_angles_, int N_segment);
  void setup_GMT_M1(float _D_, int _D_px_);
  void cleanup(void);
  void vignetting(bundle *rays);

};
@
A circular aperture is defined by its diameter [[D]] in meter of [[D_px]] in pixel.
If the aperture is annular [[ri]] defines the ratio between the inner and outer diameter.
The aperture can be segmented with [[N]] identical segments of diameter [[D_seg]].
The location of the aperture segments is defined within a given coordinate system [[ref_frame]].
A mask [[V]] is used to select the rays that are not vignetted by the aperture.
<<aperture parameters>>= 
int D_px;
float D, ri, D_seg;
int N;
mask V;
coordinate_system ref_frame;

@
\subsection{Setup \& Cleanup}
\label{sec:aper-setup--cleanup}

An aperture is initialized with:
\begin{itemize}
\item for a circular aperture,
<<aperture functions>>=
void aperture::setup(float _D_, int _D_px_, 
		     vector _origin_, vector _euler_angles_) 
{
  D_px = _D_px_;
  D_seg = D = _D_;
  ri   = 0.0;
  N = 1;
  V.setup(D_px*D_px);
  ref_frame.setup(_origin_, _euler_angles_);
}
@  \item for an annular aperture,
<<aperture functions>>=
void aperture::setup(float _D_, float _ri_, int _D_px_, 
		     vector _origin_, vector _euler_angles_) 
{
  D_px = _D_px_;
  D_seg = D = _D_;
  ri   = _ri_;
  N = 1;
  V.setup(D_px*D_px);
  ref_frame.setup(_origin_, _euler_angles_);
}
@
\item for an aperture with [[N_segment]] circular segment of diameter [[D_seg]], each segment with a different coordinate system,
<<aperture functions>>=
void aperture::setup(float _D_, float _ri_, float _D_seg_, int _D_px_, 
		     vector *_origin_, vector *_euler_angles_, int N_segment)
{
  D_px  = _D_px_;
  D     = _D_;
  D_seg = _D_seg_;
  ri    = _ri_;
  N = N_segment;
  V.setup(D_px*D_px*N);
  ref_frame.setup(_origin_, _euler_angles_, N);
}
@
\end{itemize}

Based on the above, one can defined specific segmented apertures like
\begin{description}
\item[GMT M1] 
The GMT M1 segment have all the same clear aperture of 8.365m diameter.
The center segment has a hole of 2.4412m diameter.
The center aperture is centered on the vertex of the conic surface that defines M1.
The vertex is set as the origin of the global coordinate system (GCS).
The center of the peripheral segments are evenly located on a circle of radius 8.710m with a phase of 30 degrees.
The peripheral segments also tilted inwards by 13.522 degrees.
<<aperture functions>>=
void aperture::setup_GMT_M1(float _D_, int _D_px_)
{
  D_px  = _D_px_;
  D     = _D_;
  D_seg = 8.365;
  ri    = 2.4412/8.365;
  N = 7;
  vector origin[7];
  vector euler_angles[7];
  origin[0].x = origin[0].y = origin[0].z = 0.0;
  euler_angles[0].x = euler_angles[0].y = euler_angles[0].z = 0.0;
  rtd D_c, o, zo, sa;
  sa = sin(13.522*PI/180);
  D_c = 8.710 - (0.691-0.445)*sa;
  zo = 8.417*sa*0.5 + 0.691 - 0.445;
  int k;  
  for (k=1; k<N; k++)
  {
    o = PI*(2*k-1)/6.0;
    origin[k].x = D_c*cosf(o);
    origin[k].y = D_c*sinf(o);
    origin[k].z = zo;
    euler_angles[k].x = 0.0;
    euler_angles[k].y = 13.522*PI/180.0;
    euler_angles[k].z = o;
  }
  V.setup(D_px*D_px*N);
  ref_frame.setup(origin, euler_angles, N);
}
@ 
\end{description}


The memory is freed with
<<aperture functions>>=
void aperture::cleanup(void)
{
  fprintf(stdout,"@(CEO)>aperture: freeing memory!\n");
  V.cleanup();
  ref_frame.cleanup();
}
@ 
The vignetting of the rays are done with
<<aperture functions>>=
void aperture::vignetting(bundle *rays)
{
  float R2, Rri2;
  R2 = D_seg*D_seg*0.25;
  Rri2 = R2*ri*ri;
  fprintf(stdout,"R2=%5.2f - Rri2=%5.2f\n",R2,Rri2);  
  dim3 blockDim(16,16);
  dim3 gridDim(rays->N_RAY/256+1,1);
  HANDLE_ERROR( cudaMemset(V.m, 0, sizeof(char)*rays->N_RAY ) );
  vignetting_kernel LLL gridDim , blockDim RRR (V.m, rays->d__ray, rays->N_RAY, 
						Rri2, R2,
						ref_frame.d__R,
						ref_frame.d__origin);
  GMT_intersection LLL gridDim , blockDim RRR (V.m, rays->d__ray, rays->N_RAY);
}
@ calling the device kernel:
<<vignetting kernel>>=
__global__ void vignetting_kernel(char *mask, ray *d__ray, int N_RAY, 
				  float inner2, float outer2,
				  rtd *d__R, vector *d__origin)
{
  int i, j, ij, iCoordSys, idx;
  rtd rho2;
  rtd x, y, z, u, v, w, x1, y1, s0, k, l, m;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = threadIdx.y;
  iCoordSys = blockIdx.y;
  ij = j * gridDim.x * blockDim.x + i;
  if ( ij<N_RAY )
  {

    idx = iCoordSys;

    u = d__ray[ij].coordinates.x - d__origin[idx].x;
    v = d__ray[ij].coordinates.y - d__origin[idx].y;
    w = d__ray[ij].coordinates.z - d__origin[idx].z;

    idx = iCoordSys*9;

    x = d__R[0+idx]*u + d__R[3+idx]*v + d__R[6+idx]*w;
    y = d__R[1+idx]*u + d__R[4+idx]*v + d__R[7+idx]*w;
    z = d__R[2+idx]*u + d__R[5+idx]*v + d__R[8+idx]*w;

    u = d__ray[ij].directions.x;
    v = d__ray[ij].directions.y;
    w = d__ray[ij].directions.z;

    k = d__R[0+idx]*u + d__R[3+idx]*v + d__R[6+idx]*w;
    l = d__R[1+idx]*u + d__R[4+idx]*v + d__R[7+idx]*w;
    m = d__R[2+idx]*u + d__R[5+idx]*v + d__R[8+idx]*w;

    if (m==0) { return; }
    s0 = -z/m;
    x1 = x + k*s0;
    y1 = y + l*s0;
    rho2 = x1*x1 + y1*y1;
    if ( (iCoordSys==0) && (rho2<inner2) )
      {
	return;
      }
    if (rho2<=outer2)
      {
	mask[ij] = 1;
      }
  }
}
@

\section{Ray tracing routines}
\label{sec:ray-tracing-routines}

\subsection{Coordinates transformation}
\label{sec:coord-transf}

The coordinates and cosine directions of the rays need to be transformed into the surface coordinates system first.
The matrix [[R]] in the conic structure transforms the coordinates in the LCS $(x,y,z)$ into the GCS $(\bar x,\bar y,\bar z)$ i.e.
\begin{equation}
  \left[
  \begin{array}{c}
    \bar x - \bar x_o \\
    \bar y - \bar y_o \\
    \bar z - \bar z_o
  \end{array}
  \right] = R \left[
    \begin{array}{c}
      x \\
      y \\
      z
    \end{array}
\right]
\end{equation}
The reverse transform is simply
\begin{equation}
  \left[
    \begin{array}{c}
      x \\
      y \\
      z
    \end{array}
\right] = R^T \left[
  \begin{array}{c}
    \bar x - \bar x_o \\
    \bar y - \bar y_o \\
    \bar z - \bar z_o
  \end{array}
  \right] = \left( \left[
  \begin{array}{c}
    \bar x - \bar x_o \\
    \bar y - \bar y_o \\
    \bar z - \bar z_o
  \end{array}
  \right]^T R \right)^T 
\end{equation}
<<transformation to surface system>>=
void transform_to_S(bundle *rays, conic *F)
{
  dim3 blockDim(16,16);
  dim3 gridDim(rays->N_RAY/256+1,1);
  transform_to_S_kernel LLL gridDim , blockDim RRR (rays->d__ray, rays->N_RAY,
					     F->ref_frame.d__R, F->ref_frame.d__origin);
}
void transform_to_S(bundle *rays, aperture *A)
{
  dim3 blockDim(16,16);
  dim3 gridDim(rays->N_RAY/256+1,1);
  transform_to_S_kernel LLL gridDim , blockDim RRR (rays->d__ray, rays->N_RAY,
					     A->ref_frame.d__R, A->ref_frame.d__origin);
}
@ 
<<transformation to surface system kernel>>=
__global__ void transform_to_S_kernel(ray *d__ray, int N_RAY, 
				      rtd *d__R, vector *d__origin)
{
  int i, j, ij;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  ij = j * gridDim.x * blockDim.x + i;
  if ( (ij<N_RAY) && (d__ray[ij].v) )
  {
    forward_transform(&(d__ray[ij].coordinates), &(d__ray[ij].coordinates),
		      d__R, d__origin);
    forward_transform_centered(&(d__ray[ij].directions), &(d__ray[ij].directions),
			       d__R);
  }
}
@ with the projection of the ray coordinates in the surface reference frame LCS:
<<coordinates forward transform>>=
__host__ __device__  void forward_transform(vector *v_out, vector *v_in,
					 rtd *d__R, vector *d__origin)
{
  rtd u, v, w;
  u = v_in->x - d__origin->x;
  v = v_in->y - d__origin->y;
  w = v_in->z - d__origin->z;

  v_out->x = d__R[0]*u + d__R[3]*v + d__R[6]*w;
  v_out->y = d__R[1]*u + d__R[4]*v + d__R[7]*w;
  v_out->z = d__R[2]*u + d__R[5]*v + d__R[8]*w;
}  
__host__ __device__  void forward_transform_centered(vector *v_out, vector *v_in,
						  rtd *d__R)
{
  rtd u, v, w;
  u = v_in->x;
  v = v_in->y;
  w = v_in->z;

  v_out->x = d__R[0]*u + d__R[3]*v + d__R[6]*w;
  v_out->y = d__R[1]*u + d__R[4]*v + d__R[7]*w;
  v_out->z = d__R[2]*u + d__R[5]*v + d__R[8]*w;
}  
@ 
<<transformation to rays system>>=
void transform_to_R(bundle *rays, conic *F)
{
  dim3 blockDim(16,16);
  dim3 gridDim(rays->N_RAY/256+1,1);
  transform_to_R_kernel LLL gridDim , blockDim RRR (rays->d__ray, rays->N_RAY,
        	 				     F->ref_frame.d__R, F->ref_frame.d__origin);
}
void transform_to_R(bundle *rays, aperture *A)
{
  dim3 blockDim(16,16);
  dim3 gridDim(rays->N_RAY/256+1,1);
  transform_to_R_kernel LLL gridDim , blockDim RRR (rays->d__ray, rays->N_RAY,
        	 				     A->ref_frame.d__R, A->ref_frame.d__origin);
}
@ 
<<transformation to rays system kernel>>=
__global__ void transform_to_R_kernel(ray *d__ray, int N_RAY,
                                      rtd *d__R, vector *d__origin)
{
  int i, j, ij;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  ij = j * gridDim.x * blockDim.x + i;
  if ( (ij<N_RAY) && (d__ray[ij].v) )
  {
    backward_transform(&(d__ray[ij].coordinates), &(d__ray[ij].coordinates),
		       d__R, d__origin);
    backward_transform_centered(&(d__ray[ij].directions), &(d__ray[ij].directions),
				d__R);
  }
}
@ with the projection of the ray coordinates in the rays reference frame LCS:
@ 
<<coordinates backward transform>>=
__host__ __device__  void backward_transform(vector *v_out, vector *v_in,
                                    rtd *d__R, vector *d__origin)
{
  rtd u, v, w;

  u = v_in->x;
  v = v_in->y;
  w = v_in->z;

  v_out->x = d__R[0]*u + d__R[1]*v + d__R[2]*w;
  v_out->y = d__R[3]*u + d__R[4]*v + d__R[5]*w;
  v_out->z = d__R[6]*u + d__R[7]*v + d__R[8]*w;

  v_out->x += d__origin->x;
  v_out->y += d__origin->y;
  v_out->z += d__origin->z;    
}  
__host__ __device__  void backward_transform_centered(vector *v_out, vector *v_in,
						  rtd *d__R)
{
  rtd u, v, w;

  u = v_in->x;
  v = v_in->y;
  w = v_in->z;

  v_out->x = d__R[0]*u + d__R[1]*v + d__R[2]*w;
  v_out->y = d__R[3]*u + d__R[4]*v + d__R[5]*w;
  v_out->z = d__R[6]*u + d__R[7]*v + d__R[8]*w;
}  
@ 

\subsection{Surface intersection}
\label{sec:surface-intersection}

<<intersection with surface>>=
void intersect(bundle *rays, conic *F)
{
  intersect_chief_kernel LLL 1 , 1 RRR (rays->d__chief_ray, 1,
						     F->k, F->c, F->d__origin);
  dim3 blockDim(16,16);
  dim3 gridDim(rays->N_RAY/256+1,1);
  intersect_kernel LLL gridDim , blockDim RRR (rays->d__ray, rays->N_RAY, 
					       F->k, F->c, F->d__origin,
					       rays->d__chief_ray);
}

<<intersection with surface kernel>>=
__global__ void intersect_chief_kernel(ray *d__ray, int N_RAY, 
				 const rtd Fk, const rtd Fc,
				 vector *d__origin)
{
  int j, ij;
  rtd s0, s1, x1, y1, k, l, m, S, K, L ,M, dSds;
  vector vv;
  ij = 0;

  <<intersection with z=0 plane>>
  d__ray[ij].optical_path_length = s0;
  s0 = s1 = 0;
  for (j=0; j<SNELL_N_ITERATION; j++)
    {
      <<Newton-Raphson>>
      s0 = s1;
    }
}
__global__ void intersect_kernel(ray *d__ray, int N_RAY, 
				 const rtd Fk, const rtd Fc,
				 vector *d__origin,
                                 ray *d__chief_ray)
{
  int i, j, ij;
  rtd s0, s1, x1, y1, k, l, m, S, K, L ,M, dSds;
  vector vv;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  ij = j * gridDim.x * blockDim.x + i;
  if ( (ij<N_RAY) && (d__ray[ij].v) )
  {
    <<intersection with z=0 plane>>
    d__ray[ij].optical_path_length = s0;
    s0 = s1 = 0;
    for (j=0; j<SNELL_N_ITERATION; j++)
    {
      <<Newton-Raphson>>
	s0 = s1;
    }
  d__ray[ij].optical_path_difference += 
    d__ray[ij].optical_path_length - d__chief_ray->optical_path_length;
  }
}
@
The intersection of a ray with the surface is derived using the parametric equations of the ray
\begin{eqnarray}
  \label{eq:3}
  x &=& x_0 + ks \\
  y &=& y_0 + ls \\
  z &=& z_0 + ms   
\end{eqnarray}
where $s$ is the distance along the ray from the point $(x_0,y_0,z_0)$.
Eq.~(\ref{eq:3}) are inserted into the surface definition Eq.~(\ref{eq:4}) that is solved for $s$.

The intersection with the plane $z=0$ in the LCS is derived first leading to 
\begin{eqnarray}
  \label{eq:5}
  s_0 &=& -z_0/m \\
  x_1 &=& x_0 + ks_0 \\
  y_1 &=& y_0 + ls_0 
\end{eqnarray}
<<intersection with z=0 plane>>=
k  = d__ray[ij].directions.x;
l  = d__ray[ij].directions.y;
m  = d__ray[ij].directions.z;
if (m==0) { return; }
s0 = -d__ray[ij].coordinates.z/m;
x1 = d__ray[ij].coordinates.x + k*s0;
y1 = d__ray[ij].coordinates.y + l*s0;
@
and giving a new set of parametric equations
\begin{eqnarray}
  \label{eq:6}
  x &=& x_1 + ks \\
  y &=& y_1 + ls \\
  z &=& ms     
\end{eqnarray}
 
The distance $s$ to the surface is obtained with the Newton--Raphson iterative method
\begin{equation}
  \label{eq:7}
  s_{j+1} = s_j - { F(x_j,y_j,z_j) \over F^\prime(x_j,y_j,z_j) }
\end{equation}
where
\begin{eqnarray}
  \label{eq:8}
  x_j &=& x_1 + ks_j \\
  y_j &=& y_1 + ls_j \\
  z_j &=& ms_j       
\end{eqnarray}
<<Newton-Raphson>>=
vv.x = x1 + k*s0;
vv.y = y1 + l*s0;
vv.z = m*s0;
@ and where
\begin{eqnarray}
  \label{eq:9}
  F^\prime(x_j,y_j,z_j) &=& \left. { {\mathrm d} F \over {\mathrm d} s  } \right|_{s=s_j} \\
                      &=& k\left.{ \partial F(x,y,z) \over \partial x } \right|_j + l\left. { \partial F(x,y,z) \over \partial y }\right|_j + m\left.{ \partial F(x,y,z) \over \partial z }\right|_j
\end{eqnarray}
<<Newton-Raphson>>=
S = conic_surface(&vv, d__origin, Fk, Fc);
K = partial_x_conic_surface(&vv, d__origin, Fk, Fc);
L = partial_y_conic_surface(&vv, d__origin, Fk, Fc);
M = partial_z_conic_surface();
dSds = K*k + L*l + M*m;
if (dSds==0) { return; }
s1 = s0 - S/dSds;
if (abs(s1-s0)<TOL)
{
  d__ray[ij].coordinates.x = x1 + k*s1;
  d__ray[ij].coordinates.y = y1 + l*s1;
  d__ray[ij].coordinates.z = m*s1;
  d__ray[ij].surface_normal.x    = 
    partial_x_conic_surface(&(d__ray[ij].coordinates), d__origin, Fk, Fc);
  d__ray[ij].surface_normal.y    =
    partial_y_conic_surface(&(d__ray[ij].coordinates), d__origin, Fk, Fc);
  d__ray[ij].surface_normal.z    = partial_z_conic_surface();
  d__ray[ij].optical_path_length += s1;
  d__ray[ij].n_iteration = j;
  break;
}
@
The iterative process is started with
\begin{equation}
  \label{eq:11}
  s_1 = 0,
\end{equation}
and is terminated when
\begin{equation}
  \label{eq:12}
  \left|s_{j+1} - s_j \right| < \epsilon,
\end{equation}
where $\epsilon$ is a tolerance set by the required accuracy.

The final distance along a ray from the point $(x_0,y_0,z_0)$ is
\begin{equation}
  \label{eq:13}
  s = s_0 + s_{j+1}.
\end{equation}

The surface normal at the intersection point will be needed to compute the refracted ray:
\begin{eqnarray}
  \label{eq:1}
  K &=& \left.{ \partial F(x,y,z) \over \partial x } \right|_{j+1} \\
  L &=& \left.{ \partial F(x,y,z) \over \partial y } \right|_{j+1} \\
  M &=& \left.{ \partial F(x,y,z) \over \partial z } \right|_{j+1}.
\end{eqnarray}
@

\subsection{Snell's law}
\label{sec:snells-law}

\subsubsection{Refraction}
\label{sec:refraction}

\def\np{n^\prime}
\def\kp{k^\prime}
\def\lp{l^\prime}
\def\mp{m^\prime}
\def\Sp{S^\prime}

The Snell's law can be written as
\begin{equation}
  \label{eq:10}
  \np \vec \Sp \times \vec r = n \vec S \times \vec r.
\end{equation}
$\vec S:(k,l,m)$ and $\vec \Sp:(\kp,\lp,\mp)$ are both unit vectors along the incident and refracted rays, respectively.
$\vec r:(K,L,M)$ is a unit vector normal to the refraction surface at the ray intersection point.
$n$ and $\np$ are the refractive indices for the incident and refracted rays, respectively.

Eq.~(\ref{eq:10}) implies that the three vectors $\vec S$, $\vec \Sp$ and $\vec r$ are co--planar, from which it follows that
\begin{equation}
  \label{eq:14}
  \vec \Sp = \mu \vec S + \Gamma \vec r,
\end{equation}
where $\mu=n/\np$ and $\Gamma$ has to be determined.
$\Gamma$ is derived by solving
\begin{equation}
  \label{eq:15}
  \left| \vec \Sp \right|^2 - \left| \mu \vec S + \Gamma \vec r \right|^2 = 0
\end{equation}
Developing Eq.~(\ref{eq:15}) leads to $\Gamma$ being the solution of a quadratic equation
\begin{equation}
  \label{eq:16}
  \Gamma^2 + 2a\Gamma + b = 0
\end{equation}
where
\begin{equation}
  \label{eq:17}
  a = \mu { kK +lL + mM \over K^2 + L^2 + M^2 },
\end{equation}
<<a equation>>=
K = d__ray[ij].surface_normal.x;
L = d__ray[ij].surface_normal.y;
M = d__ray[ij].surface_normal.z;
G2 = K*K + L*L + M*M;
k = d__ray[ij].directions.x;
l = d__ray[ij].directions.y;
m = d__ray[ij].directions.z;
a = mu*(k*K + l*L + m*M)/G2;
@  and
\begin{equation}
  \label{eq:18}
  b = { \mu^2 -1 \over K^2 + L^2 + M^2 }.
\end{equation}
<<b equation>>=
b = (mu*mu-1)/G2;
@ 
Eq.~(\ref{eq:16}) is solved with the Newton--Raphson iterative method by introducing the new function
\begin{equation}
  \label{eq:19}
  V(\Gamma) = \Gamma^2 + 2a\Gamma + b,
\end{equation}
and writing $\Gamma$ as
\begin{equation}
  \label{eq:20}
  \Gamma_{j+1} = \Gamma_j - { V(\Gamma_j) \over V^\prime(\Gamma_j) }.
\end{equation}
Noting that
\begin{equation}
  \label{eq:21}
  V^\prime(\Gamma_j) = \left. { \mathrm d V \over \mathrm d \Gamma } \right|_j = 2\left( \Gamma_j + a \right),
\end{equation}
Eq.~(\ref{eq:20}) becomes
\begin{equation}
  \label{eq:22}
  \Gamma_{j+1} = { \Gamma_j^2 - b \over 2(\Gamma_j + a) }.
\end{equation}
with
\begin{equation}
  \label{eq:23}
  \Gamma_1 = {-b \over 2a }.
\end{equation}

<<refraction>>=
void refract(bundle *rays, const rtd mu)
{
  dim3 blockDim(16,16);
  dim3 gridDim(rays->N_RAY/256+1,1);
  refract_kernel LLL gridDim , blockDim RRR (rays->d__ray, rays->N_RAY, mu);
}
@ 
<<refraction kernel>>=
__global__ void refract_kernel(ray *d__ray, int N_RAY, const rtd mu)
{
  int i, j, ij;
  rtd k, l, m, K, L ,M, G2, a, b, gamma0, gamma1, gamma_relative_error;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  ij = j * gridDim.x * blockDim.x + i;
  if ( (ij<N_RAY) && (d__ray[ij].v) )
  {
    <<a equation>>
    <<b equation>>
    gamma0 = -0.5*b/a;
    for (j=0; j<SNELL_N_ITERATION; j++)
    {
      gamma1 = 0.5*(gamma0*gamma0-b)/(gamma0+a);
      gamma_relative_error = abs( gamma1/gamma0 - 1.0 );
      if (gamma_relative_error<0.01)
      {
        d__ray[ij].directions.x = mu*k + gamma1*K;
        d__ray[ij].directions.y = mu*l + gamma1*L;
        d__ray[ij].directions.z = mu*m + gamma1*M;
        return;
      }
      gamma0 = gamma1;
    }
  }
}
@
\subsubsection{Reflection}
\label{sec:reflection}

In the case of reflection, one have $\mu=1$, $b=0$ and
\begin{equation}
  \label{eq:24}
  \Gamma = -2a.
\end{equation}
Eq.~(\ref{eq:14}) thus becomes
\begin{equation}
  \label{eq:25}
    \vec \Sp = \vec S -2a \vec r.
\end{equation}
<<reflection>>=
void reflect(bundle *rays)
{
  dim3 blockDim(16,16);
  dim3 gridDim(rays->N_RAY/256+1,1);
  reflect_kernel LLL gridDim , blockDim RRR (rays->d__ray, rays->N_RAY, 1.0);
}
@ 
Setting $\mu=-1$ makes the mirror behaving like a thin lens:
<<thin lens>>=
void thin_lens(bundle *rays)
{
  dim3 blockDim(16,16);
  dim3 gridDim(rays->N_RAY/256+1,1);
  reflect_kernel LLL gridDim , blockDim RRR (rays->d__ray, rays->N_RAY, -1.0);
}
@ 
<<reflection kernel>>=
    __global__ void reflect_kernel(ray *d__ray, int N_RAY, float mu)
{
  int i, j, ij;
  rtd k, l, m, K, L ,M, G2, a;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  ij = j * gridDim.x * blockDim.x + i;
  if ( (ij<N_RAY) && (d__ray[ij].v) )
  {
    <<a equation>>
    a *= -2.0;
    d__ray[ij].directions.x = mu*k + a*K;
    d__ray[ij].directions.y = mu*l + a*L;
    d__ray[ij].directions.z = mu*m + a*M;
  }
}
@

\section{GMT M1}
\label{sec:gmt-m1}

A new structure to hold GMT M1 and M2 parameters and functions is defined.
<<GMT M1 structure>>=
struct gmt_m1 {
  <<GMT M12 parameters>>
  <<GMT M12 functions>>
  void global_tiptilt(float tip, float tilt);
};
@  with
<<GMT M12 functions>>=
void setup(float _D_, int _D_px_);
void setup(float _D_, int _D_px_, zernikeS *ZS);
void setup(float _D_, int _D_px_, int N_SRC);
void setup(float _D_, int _D_px_, zernikeS *ZS, int N_SRC);
void cleanup(void);
void update(vector _origin_, vector _euler_angles_,int idx);
void reset(void);
void trace(bundle *rays);
void blocking(bundle *rays);
void test_ray_tracing(void);
@ 
The GMT M12 parameters are:
\begin{itemize}
\item the mirror ID:
<<GMT M12 parameters>>=
int M_ID;
@
\item the segment clear aperture diameter $[[D_clear]]=8.365$m:
<<GMT M12 parameters>>=
rtd D_clear;
@
\item the segment full aperture diameter $[[D_full]]=8.417$m:
<<GMT M12 parameters>>=
rtd D_full;
@
\item the obscuration ratio of the center segment $[[ri]]=2.4412/8.365$
<<GMT M12 parameters>>=
rtd ri;
@
\item the tilt angle of the peripheral segment $[[beta]]=13.522$degree
<<GMT M12 parameters>>=
rtd beta;
@
\item the distance from the optical axis to the center of the tilted peripheral segments $[[L]]=8.710$m:
<<GMT M12 parameters>>=
rtd L;
@
\item the size of the square array containing M1 in meter and pixel [[D]] and [[D_px]]:
<<GMT M12 parameters>>=
rtd D;
int D_px;
@
\item the number of segment $[[N]]=7$
<<GMT M12 parameters>>=
int N;
@
\item the edge to center depth of the segment conic $[[depth]]=(0.691-0.445)$m:
<<GMT M12 parameters>>=
rtd depth;
@
\item the reference frames of the apertures:
<<GMT M12 parameters>>=
coordinate_system aperture_CS;
@
\item the reference frames and origins of the conics:
<<GMT M12 parameters>>=
coordinate_system conic_CS;
vector conic_origin[7], *d__conic_origin;
@
\item the conic parameters:
<<GMT M12 parameters>>=
rtd conic_c, conic_k;
@
\item the reference frames of the rigid bodies:
<<GMT M12 parameters>>=
coordinate_system rigid_body_CS;
@
\item the reference frames of the motions:
<<GMT M12 parameters>>=
coordinate_system motion_CS;
@
\item the mirror height
<<GMT M12 parameters>>=
rtd height;
@
\item the M1 pupil mask [[V]]:
<<GMT M12 parameters>>=
mask V;
@
\item the segment index offset (0 for M1 and 3 for M2):
<<GMT M12 parameters>>=
int idx_offset;
@
\item an array of Zernike surface, one per segment, [[ZS]]:
<<GMT M12 parameters>>=
zernikeS *ZS;
@
\item the segment piston mask
<<GMT M12 parameters>>=
int *d__piston_mask;
@ \end{itemize}
@

\subsection{Setup \& Cleanup}
\label{sec:setup--cleanup-1}

The GMT M1 segment have all the same clear aperture of 8.365m diameter.
The center segment has a hole of 2.4412m diameter.
The center aperture is centered on the vertex of the conic surface that defines M1.
The vertex is set as the origin of the global coordinate system (GCS).
The center of the peripheral segments are evenly located on a circle of radius 8.710m with a phase of 30 degrees.
The peripheral segments also tilted inwards by 13.522 degrees.
The [[GMT_M1]] structure is initialized with the size of the square array containing M1 in meter and pixel.
The size must be 25.5m or more to contain M1 fully.
<<GMT M1 functions>>=
void gmt_m1::setup(float _D_, int _D_px_)
{
  int  N_SRC = 1;
  ZS = NULL;
  <<M1 parameters>>
  <<GMT setup common>>
}
@ or
<<GMT M1 functions>>=
void gmt_m1::setup(float _D_, int _D_px_, zernikeS *_ZS_)
{
  int  N_SRC = 1;
  ZS = _ZS_;
  <<M1 parameters>>
  <<GMT setup common>>
}
@ where
<<M1 parameters>>=
 M_ID    = 1;
 D_px    = _D_px_;
 D       = _D_;
 D_full  = 8.417;
 D_clear = 8.365;
 ri      = 2.4412/8.365;
 beta    = 13.522*PI/180.0;
 L       = 8.710;
 N       = 7;
 conic_c = 1.0/36.0;
 conic_k = 1-0.9982857;
 height  = 0.0;
 idx_offset = 0;
@  
If an array of sources is propagated through the telescope then
<<GMT M1 functions>>=
void gmt_m1::setup(float _D_, int _D_px_, int N_SRC)
{
  ZS = NULL;
  <<M1 parameters>>
  <<GMT setup common>>
}
@ or
<<GMT M1 functions>>=
void gmt_m1::setup(float _D_, int _D_px_, zernikeS *_ZS_, int N_SRC)
{
  ZS = _ZS_;
  <<M1 parameters>>
  <<GMT setup common>>
}
@  where
<<GMT setup common>>=

HANDLE_ERROR( cudaMalloc((void**)&d__piston_mask, sizeof(int)*D_px*D_px*N_SRC ) );

vector __v0 = {0.0,0.0,0.0},
       __v = {D_full*0.5,0.0,0.0},
       origin[7],
       euler_angles[7];
rtd D_c, o, zo;
 int k, idx;    
char tag[16];

depth = conic_equation(&__v,&__v0,conic_k,conic_c);
D_c = L;
__v.x = L;
zo = conic_equation(&__v,&__v0,conic_k,conic_c);

<<M12 rigid body definition>>

<<M12 aperture definition>>

<<M12 conic definition>>

<<M12 motion definition>>

V.setup(D_px*D_px*N_SRC);
@
The rigid body coordinate systems are aligned with the segment coordinate systems.
The origins $[x_O, y_O, z_O]$ of the segment coordinate systems are given with respect to the global coordinate system which origin is at the vertex of M1 conic surface: 
\begin{eqnarray}
  \label{eq:35}
  x_{O,k} &=& L\cos(\theta_{O,k}), \\
  y_{O,k} &=& L\sin(\theta_{O,k}), \\
  z_O &=& F(L),\\
\end{eqnarray}
with, for M1, $L = 8.71$m, $\theta_{O,k}=\pi(3-2k)/6, \forall k \in [0,5]$, $x_{O,6}=y_{O,6}=0$ and
\begin{equation}
  \label{eq:36}
  F(\rho) = {c\rho^2 \over 1 + \sqrt{1 - \kappa c^2 \rho^2} }.
\end{equation}
In addition to the change of origin with respect to the GCS, the segment coordinate system is rotated around the z--axis of $-k\pi/3$radian and then tilted around the x--axis of $\beta$.
\begin{center}
\begin{tikzpicture}
  \draw[->] (-25mm,0) -- (35mm,0) node[below] {$\bar x$};
  \draw[->] (0,-25mm) -- (0,35mm) node[right] {$\bar y$};
  \draw[thin,dashed] (0,0) circle [radius=21mm];
  \coordinate (O) at (0,0);
  \draw (O) circle [radius=10mm] node[above left=3mm] {7};
  \draw[->,thick,red] ($(O)+(-5mm,0)$) -- ($(O)+(5mm,0)$) node[below] {$\hat x$};
  \draw[->,thick,red] ($(O)+(0,-5mm)$) -- ($(O)+(0,5mm)$) node[right] {$\hat y$};
  \foreach \x in {1,...,6} {
    \coordinate (O) at (150-\x*60:21mm);
    \draw (O) circle [radius=10mm] node[above left=3mm] {\x};
    \draw[->,thick,red,rotate=-60*(\x-1)] ($(O)+(-5mm,0)$) -- ($(O)+(5mm,0)$) node[below] {$\hat x$};
    \draw[->,thick,red,rotate=-60*(\x-1)] ($(O)+(0,-5mm)$) -- ($(O)+(0,5mm)$) node[right] {$\hat y$};

  }    
\end{tikzpicture}  
\end{center}
<<M12 rigid body definition>>=
origin[N-1].x = origin[N-1].y = 0.0;
origin[N-1].z = height;
euler_angles[N-1].x = euler_angles[N-1].y = euler_angles[N-1].z = 0.0;
for (k=0; k<N-1; k++)
{
  o = PI*(3-2*k)/6.0;
  <<segment index offset>>
  origin[idx].x = D_c*cosf(o);
  origin[idx].y = D_c*sinf(o);
  origin[idx].z = height + zo;
  euler_angles[idx].x = beta;
  euler_angles[idx].y = 0.0;
  euler_angles[idx].z = -PI*k/3.0;
}
sprintf(tag,"M%d RIGID BODY",M_ID);
rigid_body_CS.setup(origin, euler_angles, N, tag);
@ with
<<segment index offset>>=
idx = (k + idx_offset)%6;
@ 
The coordinate systems of the segment apertures are defined with respect to the coordinate systems of the rigid body motions.
The apertures are directly above the segments such as they rest on the rim of the segments. 
<<M12 aperture definition>>=
origin[N-1].x = origin[N-1].y = 0.0;
origin[N-1].z = depth;
euler_angles[N-1].x = euler_angles[N-1].y = euler_angles[N-1].z = 0.0;
for (k=0; k<N-1; k++)
{
  <<segment index offset>>
  origin[idx].x = 0.0;
  origin[idx].y = 0.0;
  origin[idx].z = depth;
  euler_angles[idx].x = 0.0;
  euler_angles[idx].y = 0.0;
  euler_angles[idx].z = 0.0;
}
sprintf(tag,"M%d APERTURE",M_ID);
aperture_CS.setup(origin, euler_angles, N, tag);
@ 
The coordinate systems of the segment conics are defined with respect to the coordinate systems of the rigid body motions.
Both coordinate systems share the same origin but x--axis and y--axis are parallel to the x--axis and y--axis of the GCS.
The origins of the segment conics are also given in the coordinate systems of the segment conics.
\begin{center}
\begin{tikzpicture}
  \draw[->] (-25mm,0) -- (35mm,0) node[below] {$\bar x$};
  \draw[->] (0,-25mm) -- (0,35mm) node[right] {$\bar y$};
  \draw[thin,dashed] (0,0) circle [radius=21mm];
  \coordinate (O) at (0,0);
  \draw (O) circle [radius=10mm] node[above left=3mm] {7};
  \draw[->,thick,red] ($(O)+(-5mm,0)$) -- ($(O)+(5mm,0)$) node[below] {$\hat x$};
  \draw[->,thick,red] ($(O)+(0,-5mm)$) -- ($(O)+(0,5mm)$) node[right] {$\hat y$};
  \foreach \x in {1,...,6} {
    \coordinate (O) at (150-\x*60:21mm);
    \draw (O) circle [radius=10mm] node[above left=3mm] {\x};
    \draw[->,thick,red] ($(O)+(-5mm,0)$) -- ($(O)+(5mm,0)$) node[below] {$\check x$};
    \draw[->,thick,red] ($(O)+(0,-5mm)$) -- ($(O)+(0,5mm)$) node[right] {$\check y$};

  }    
\end{tikzpicture}  
\end{center}
<<M12 conic definition>>=
origin[N-1].x = origin[N-1].y = origin[N-1].z = 0.0;
euler_angles[N-1].x = euler_angles[N-1].y = euler_angles[N-1].z = 0.0;
conic_origin[N-1].x = conic_origin[N-1].y = conic_origin[N-1].z = 0.0; 
for (k=0; k<N-1; k++)
{
  <<segment index offset>>
  o = PI*(3-2*k)/6.0;
  origin[idx].x = 0.0;
  origin[idx].y = 0.0;
  origin[idx].z = 0.0;
  euler_angles[idx].x = beta;
  euler_angles[idx].y = 0.0;
  euler_angles[idx].z = -PI*k/3.0;
  conic_origin[idx].x = -D_c*cosf(o);
  conic_origin[idx].y = -D_c*sinf(o);
  conic_origin[idx].z = -zo;
}
//euler_angles[0].x = 30.0*PI/180.0/3600.0;
sprintf(tag,"M%d CONIC",M_ID);
conic_CS.setup(origin, euler_angles, N, tag);
HANDLE_ERROR( cudaMalloc((void**)&d__conic_origin, sizeof(vector)*N ) );
HANDLE_ERROR( cudaMemcpy( d__conic_origin, conic_origin, 
			    sizeof(vector)*N, cudaMemcpyHostToDevice ) );
@ 
The motion coordinate systems are defined with respect to the coordinate systems of the rigid body motions.
For unperturbed segments, both coordinate systems coincide.
<<M12 motion definition>>=
for (k=0; k<N; k++)
{
  origin[k].x = 0.0;
  origin[k].y = 0.0;
  origin[k].z = 0.0;
  euler_angles[k].x = 0.0;
  euler_angles[k].y = 0.0;
  euler_angles[k].z = 0.0;
}
sprintf(tag,"M%d MOTION",M_ID);
motion_CS.setup(origin, euler_angles, N, tag);
@ 
Memory is freed with
<<GMT M1 functions>>=
void gmt_m1::cleanup(void)
{
  <<GMT cleanup common>>
}
@ with
<<GMT cleanup common>>=
fprintf(stdout,"@(CEO)>gmt_m1: freeing memory!\n");
V.cleanup();
aperture_CS.cleanup();
conic_CS.cleanup();
rigid_body_CS.cleanup();
motion_CS.cleanup();
HANDLE_ERROR( cudaFree( d__conic_origin ) );
HANDLE_ERROR( cudaFree( d__piston_mask ) );
@
The rigid body motion parameters are updated with:
<<GMT M1 functions>>=
void gmt_m1::update(vector _origin_, vector _euler_angles_,int idx)
{
    <<GMT M12 update>>
}
@ where
<<GMT M12 update>>=
  //fprintf(stdout,"\n\x1B[31m");
motion_CS.update( _origin_, _euler_angles_, --idx);
//motion_CS.info();
@ 
The rigid body motion are reset to 0 with:
<<GMT M1 functions>>=
void gmt_m1::reset(void)
{
    <<GMT M12 reset>>
}
@ where
<<GMT M12 reset>>=
vector zero;
zero.x = 0.0;
zero.y = 0.0;
zero.z = 0.0;
//fprintf(stdout,"\n\x1B[31m");
for (int k=0; k<N; k++)
   motion_CS.update( zero, zero, k);
//motion_CS.info();
@ 
\subsection{Blocking}
\label{sec:blocking}

The rays blocking with M1 is computed with
<<GMT M1 functions>>=
void gmt_m1::blocking(bundle *rays)
{
  <<GMT blocking common>>
}
@ where
<<GMT blocking common>>=
 rtd R2, Rri2;
 R2 = D_clear*D_clear*0.25;
 Rri2 = R2*ri*ri;
 // fprintf(stdout,"R2=%5.2f - Rri2=%5.2f\n",R2,Rri2);  
 // printf("N_BUNDLE=%d\n",rays->N_BUNDLE);
 int nel = rays->N_RAY*rays->N_BUNDLE;
 dim3 blockDim(256);
 dim3 gridDim(nel/256+1);
 fill_ones_char LLL gridDim,blockDim RRR (V.m,nel);
 blockDim = dim3(16,16);
 gridDim  = dim3(rays->N_RAY/256+1,1,rays->N_BUNDLE);
 m1_blocking_kernel LLL gridDim , blockDim RRR (V.m, rays->d__ray, rays->N_RAY, 
					     Rri2, R2,
					     aperture_CS.d__R,
					     aperture_CS.d__origin,
					     rigid_body_CS.d__R,
					     rigid_body_CS.d__origin,
					     motion_CS.d__R,
					     motion_CS.d__origin);
 GMT_intersection LLL gridDim , blockDim RRR (V.m, rays->d__ray, rays->N_RAY);
@ and with the kernel
<<GMT blocking kernel>>=
__global__ void m1_blocking_kernel(char *mask, ray *d__ray, int N_RAY, 
				rtd inner2, rtd outer2,
				rtd *d__aperture_R, vector *d__aperture_origin,
				rtd *d__rigid_body_R, vector *d__rigid_body_origin,
				rtd *d__motion_R, vector *d__motion_origin)
{
  int i, j, ij, iCoordSys, iSource;
  rtd rho2;
  rtd x, y, z, x1, y1, s0, k, l, m;
  vector xyz, klm, xyz_GS, klm_GS;
  char chief=0;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = threadIdx.y;
  //  iCoordSys = blockIdx.y;
  ij = j * gridDim.x * blockDim.x + i;
  iSource = blockIdx.z;
  j = ij;
  ij += iSource*N_RAY;
  if  ( ( j<N_RAY ) && (d__ray[ij].v) )// & (iCoordSys<1) )
  {

    for (iCoordSys=0; iCoordSys<7; iCoordSys++)
      {

        <<from global CS to motion CS>>

	<<from motion CS to aperture intersection>>

	if (rho2<=outer2)
	  {
	    mask[ij] = 0;
          }
       }
   }
}
@
\subsection{Ray tracing}
\label{sec:ray-tracing}

The rays propagation through M1 is computed with
<<GMT M1 functions>>=
void gmt_m1::trace(bundle *rays)
{
  <<GMT trace common>>
}
@ where
<<GMT trace common>>=
 rtd R2, Rri2;
 R2 = D_clear*D_clear*0.25;
 Rri2 = R2*ri*ri;
 // fprintf(stdout,"R2=%5.2f - Rri2=%5.2f\n",R2,Rri2);  
 dim3 blockDim(1,1);
 dim3 gridDim(1,1,rays->N_BUNDLE);
 m1_trace_chief_kernel LLL gridDim , blockDim RRR (V.m, rays->d__chief_ray, 1, 
						   conic_CS.d__R,
						   conic_CS.d__origin,
						   conic_k, conic_c,
						   d__conic_origin,
						   rigid_body_CS.d__R,
						   rigid_body_CS.d__origin,
						   motion_CS.d__R,
						   motion_CS.d__origin,
						   ZS->max_n, ZS->n_mode,
						   ZS->d__a, ZS->d__cx, ZS->d__cy,
						   0.5*D_full);
 blockDim = dim3(16,16);
 gridDim  = dim3(rays->N_RAY/256+1,1,rays->N_BUNDLE);
 HANDLE_ERROR( cudaMemset(V.m, 0, sizeof(char)*rays->N_RAY*rays->N_BUNDLE ) );
 HANDLE_ERROR( cudaMemset(d__piston_mask, 0, sizeof(int)*rays->N_RAY*rays->N_BUNDLE ) );
 m1_trace_kernel LLL gridDim , blockDim RRR (V.m, rays->d__ray, rays->N_RAY, 
					     Rri2, R2,
					     aperture_CS.d__R,
					     aperture_CS.d__origin,
					     conic_CS.d__R,
					     conic_CS.d__origin,
					     conic_k, conic_c,
					     d__conic_origin,
					     rigid_body_CS.d__R,
					     rigid_body_CS.d__origin,
					     motion_CS.d__R,
					     motion_CS.d__origin,
					     ZS->max_n, ZS->n_mode,
					     ZS->d__a, ZS->d__cx, ZS->d__cy,
					     0.5*D_full,
					     rays->d__chief_ray,
					     d__piston_mask);
 GMT_intersection LLL gridDim , blockDim RRR (V.m, rays->d__ray, rays->N_RAY);

@ and with the kernel
<<GMT ray tracing kernel>>=
__global__ void m1_trace_kernel(char *mask, ray *d__ray, int N_RAY, 
				rtd inner2, rtd outer2,
				rtd *d__aperture_R, vector *d__aperture_origin,
				rtd *d__conic_R, vector *d__conic_origin,
                                const rtd Fk, const rtd Fc,
                                vector *d__conic_self_origin,
				rtd *d__rigid_body_R, vector *d__rigid_body_origin,
				rtd *d__motion_R, vector *d__motion_origin,
				int max_n, int n_mode,
				rtd *d__a, rtd *d__cx, rtd *d__cy, rtd R,
				ray *d__chief_ray,
				int *d__piston_mask)
{
  int i, j, ij, iCoordSys, iSource, b_n_mode;
  rtd rho2;
  rtd x, y, z, x1, y1, s0, k, l, m;
  rtd s1, S, K, L ,M, dSds;
  rtd G2, a;
  vector d__origin, xyz, klm, xyz_GS, klm_GS;
  char chief=0;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = threadIdx.y;
  //  iCoordSys = blockIdx.y;
  ij = j * gridDim.x * blockDim.x + i;
  iSource = blockIdx.z;
  j = ij;
  ij += iSource*N_RAY;
  b_n_mode = max_n*(max_n+1)*0.5;
  if  ( ( j<N_RAY ) && (d__ray[ij].v) )// & (iCoordSys<1) )
  {

    for (iCoordSys=0; iCoordSys<7; iCoordSys++)
      {

	d__origin = d__conic_self_origin[iCoordSys];

        <<from global CS to motion CS>>

	<<from motion CS to aperture intersection>>

	if (rho2<=outer2)
	  {
	    mask[ij] = 1;
	    d__piston_mask[ij] = iCoordSys + 1;

            <<from motion CS to conic intersection and back to global CS>>
	    d__ray[ij].optical_path_difference += 
		d__ray[ij].optical_path_length - d__chief_ray[iSource].optical_path_length;
	  }
      }
  }
}
@ and the chief ray kernel
<<GMT chief ray tracing kernel>>=
__global__ void m1_trace_chief_kernel(char *mask, ray *d__ray, int N_RAY, 
				      rtd *d__conic_R, vector *d__conic_origin,
				      const rtd Fk, const rtd Fc,
				      vector *d__conic_self_origin,
				      rtd *d__rigid_body_R, vector *d__rigid_body_origin,
				      rtd *d__motion_R, vector *d__motion_origin,
				      int max_n, int n_mode,
				      rtd *d__a, rtd *d__cx, rtd *d__cy, rtd R)
{
  int j, ij, iCoordSys, iSource, b_n_mode;
  rtd x1, y1, s0, k, l, m;
  rtd s1, S, K, L ,M, dSds;
  rtd G2, a;
  vector d__origin, xyz, klm, xyz_GS, klm_GS;
  char chief=1;

  iSource = blockIdx.z;
  ij = iSource*N_RAY;
  iCoordSys = 0;
  b_n_mode = max_n*(max_n+1)*0.5;

  d__origin = d__conic_self_origin[iCoordSys];

  <<from global CS to motion CS>>

  <<from motion CS to conic intersection and back to global CS>>

}
@ The following is a test routine to validate the sequence of transformation in the ray tracing kernel:
<<GMT M1 functions>>=
void gmt_m1::test_ray_tracing(void)
{
  int iCoordSys;
  vector in, out;

  in.x = 8.71*cos(PI/6);
  in.y = 8.71*sin(PI/6);
  in.z = 0.0;

  printf("Output vector:\n");
  for (iCoordSys = 0; iCoordSys<N; iCoordSys++)
    {
      printf(" #%d\n",iCoordSys);
        forward_transform(&out, &in,
                          rigid_body_CS.R+iCoordSys*9,
                          rigid_body_CS.origin+iCoordSys);
        printf(". x = %.2e ; y = %.2e ; z = %.2e\n",out.x,out.y,out.z);

        forward_transform(&out, &out,
                          motion_CS.R+iCoordSys*9,
                          motion_CS.origin+iCoordSys);
        printf(". x = %.2e ; y = %.2e ; z = %.2e\n",out.x,out.y,out.z);

	backward_transform_centered(&out, &out,
				    conic_CS.R+iCoordSys*9);
        printf(". x = %.2e ; y = %.2e ; z = %.2e\n",out.x,out.y,out.z);

	forward_transform_centered(&out, &out,
				    conic_CS.R+iCoordSys*9);
        printf(". x = %.2e ; y = %.2e ; z = %.2e\n",out.x,out.y,out.z);

        backward_transform(&out, &out,
                          motion_CS.R+iCoordSys*9,
                          motion_CS.origin+iCoordSys);
        printf(". x = %.2e ; y = %.2e ; z = %.2e\n",out.x,out.y,out.z);

        backward_transform(&out, &out,
                          rigid_body_CS.R+iCoordSys*9,
                          rigid_body_CS.origin+iCoordSys);
        printf(". x = %.2e ; y = %.2e ; z = %.2e\n",out.x-in.x,out.y-in.y,out.z-in.z);
    }
    
}
@ 
The transformation of the coordinates and directions of the rays is performed in 3 steps, (i) the rays are transformed into the CS of the segment, (ii) the segments are perturbed
<<from global CS to motion CS>>=
// RIGID BODY >>> 
forward_transform(&xyz_GS, &(d__ray[ij].coordinates),
		  d__rigid_body_R+iCoordSys*9, d__rigid_body_origin+iCoordSys);
forward_transform_centered(&klm_GS, &(d__ray[ij].directions),
			   d__rigid_body_R+iCoordSys*9);

 if (chief==0)
   {
// MOTION >>>  
forward_transform(&xyz_GS, &xyz_GS,
		  d__motion_R+iCoordSys*9, d__motion_origin+iCoordSys);
forward_transform_centered(&klm_GS, &klm_GS,
			    d__motion_R+iCoordSys*9);
   }
@  and (iii) the rays are transformed into the CS of the aperture:
<<from motion CS to aperture intersection>>=
// APERTURE >>>
forward_transform(&xyz, &xyz_GS,
		  d__aperture_R+iCoordSys*9,
		  d__aperture_origin+iCoordSys);
forward_transform_centered(&klm, &klm_GS,
			   d__aperture_R+iCoordSys*9);
 
	x = xyz.x;
	y = xyz.y;
	z = xyz.z;
	k = klm.x;
	l = klm.y;
	m = klm.z;

        <<GMT intersection with aperture plane>>

        rho2 = x1*x1 + y1*y1;
	if ( (iCoordSys==6) && (rho2<inner2) )
	  {
	    return;
	  }
@
The intersection with and reflection from the surface is dome with
<<from motion CS to conic intersection and back to global CS>>=
  // CONIC >>>
  backward_transform_centered(&xyz, &xyz_GS,
			      d__conic_R+iCoordSys*9);
 backward_transform_centered(&klm, &klm_GS,
			     d__conic_R+iCoordSys*9);

 <<GMT intersection with conic>>

 G2 = K*K + L*L + M*M;
 a  = k*K + l*L + m*M;

 a *= -2.0/G2;
 klm.x += a*K;
 klm.y += a*L;
 klm.z += a*M;

 // CONIC <<<
 forward_transform_centered(&xyz_GS, &xyz,
			    d__conic_R+iCoordSys*9);
 forward_transform_centered(&klm_GS, &klm,
			    d__conic_R+iCoordSys*9);
 if (chief==0)
   {
 // MOTION <<<
 backward_transform(&xyz_GS, &xyz_GS,
		    d__motion_R+iCoordSys*9, d__motion_origin+iCoordSys);
 backward_transform_centered(&klm_GS, &klm_GS,
			     d__motion_R+iCoordSys*9);
   }
 // RIGID_BODY <<<
 backward_transform(&(d__ray[ij].coordinates), &xyz_GS,
		    d__rigid_body_R+iCoordSys*9,
		    d__rigid_body_origin+iCoordSys);
 backward_transform_centered(&(d__ray[ij].directions), &klm_GS,
			     d__rigid_body_R+iCoordSys*9);

@
The vignetting by the aperture is computed as the intersection between the aperture mask and the ray vignetting flags: 
<<GMT aperture intersection>>=
__global__ void GMT_intersection(char *mask, ray *d__ray, int N_RAY)
{
  int i, j, ij, iSource;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = threadIdx.y;
  ij = j * gridDim.x * blockDim.x + i;
  iSource = blockIdx.z;
  if  ( ij<N_RAY )
  {
    ij += iSource*N_RAY;
    d__ray[ij].v &= mask[ij];
  }
}
@
The intersection with the aperture plane is computed with
<<GMT intersection with aperture plane>>=
if (m==0) { return; }
s0 = -z/m;
x1 = x + k*s0;
y1 = y + l*s0;
@ 
The intersection with the plane $z=0$ in the conic coordinate transformed is computed with  
<<GMT intersection with conic>>=
k  = klm.x;
l  = klm.y;
m  = klm.z;
if (m==0) { return; }
s0 = -xyz.z/m;
x1 = xyz.x + k*s0;
y1 = xyz.y + l*s0;
d__ray[ij].optical_path_length = s0;
s0 = s1 = 0;
for (j=0; j<SNELL_N_ITERATION; j++)
{
  xyz.x = x1 + k*s0;
  xyz.y = y1 + l*s0;
  xyz.z = m*s0;
  S = conic_surface(&xyz, &d__origin, Fk, Fc, max_n, 
		    d__a + iCoordSys*n_mode, R);
  K = partial_x_conic_surface(&xyz, &d__origin, Fk, Fc, max_n, 
			      d__cx + iCoordSys*b_n_mode, R);
  L = partial_y_conic_surface(&xyz, &d__origin, Fk, Fc, max_n, 
			      d__cy + iCoordSys*b_n_mode, R);
  M = partial_z_conic_surface();
  dSds = K*k + L*l + M*m;
  if (dSds==0) { break; }
  s1 = s0 - S/dSds;
  if (abs(s1-s0)<TOL)
    {
      xyz.x = x1 + k*s1;
      xyz.y = y1 + l*s1;
      xyz.z = m*s1;
      K    = 
	partial_x_conic_surface(&xyz, &d__origin, Fk, Fc, max_n, 
				d__cx + iCoordSys*b_n_mode, R);
      L    =
	partial_y_conic_surface(&xyz, &d__origin, Fk, Fc, max_n, 
				d__cy + iCoordSys*b_n_mode, R);
      M    = partial_z_conic_surface();
      d__ray[ij].optical_path_length += s1;
      d__ray[ij].n_iteration = j;
      break;
    }
  s0 = s1;
}
@
\subsection{Global tip--tilt}
\label{sec:global-tip-tilt}

\def\ijk{\ensuremath{\left[\vec i,\vec j, \vec k\right]}}
\def\uvw{\ensuremath{\left[\vec u,\vec v, \vec w\right]_k}}
\def\uvwp{\ensuremath{\left[\vec u^\prime,\vec v^\prime, \vec w^\prime\right]}}
\def\RS{\ensuremath{R_{{\cal S},k}}}
\def\RT{\ensuremath{R_{\cal T}}}
\def\RM{\ensuremath{R_{\cal M}}}

The GCS is defined with the 3 ortho--normal unit vectors \ijk.
The segment coordinate systems also called rigid body CSs are defined with the 3 ortho-normal vectors \uvw.
\uvw are derived from \ijk with the matrix \RS
\begin{equation}
  \label{eq:37}
  \uvw = \RS^T \ijk.
\end{equation}
Within the rigid body CSs, motion CSs (\uvwp) are defined with
\begin{equation}
  \label{eq:38}
  \uvwp = \RM^T \uvw = \RM^T \RS^T \ijk,
\end{equation}
where \RM is the 3D rotation matrix of each segment.

When a global tip--tilt is applied to M1, \ijk becomes $\RT^T\ijk$ with \RT the tip--tilt matrix, and the motion CSs are given by
\begin{equation}
  \label{eq:39}
  \uvwp = \RS^T\RT^T\ijk.
\end{equation}

From Eq.~(\ref{eq:38}) and Eq.~(\ref{eq:39}), the 3D rotation matrix of each segment as a result of a global tip--tilt is given by
\begin{equation}
  \label{eq:40}
  \RM = \RS^T \RT \RS.
\end{equation}
<<global tip-tilt transformation>>=
 cublasDgemm(handle,
	     CUBLAS_OP_N, CUBLAS_OP_N,
	     3,3,3,
	     &alpha,
	     rigid_body_CS.d__R+k9, 3,
	     TT_CS.d__R, 3,
	     &beta,
	     d__C, 3);
 cublasDgemm(handle,
	     CUBLAS_OP_N, CUBLAS_OP_T,
	     3,3,3,
	     &alpha,
	     d__C, 3,
	     rigid_body_CS.d__R+k9, 3,
	     &beta,
	     motion_CS.d__R+k9, 3);

 HANDLE_ERROR( cudaMemcpy( motion_CS.R+k9, motion_CS.d__R+k9, 
			   sizeof(double)*9, cudaMemcpyDeviceToHost ) );
 /* 
 int i, j, idx = 0;
for (i=0;i<3;i++)
   {
     fprintf(stdout,"||  ");
     for (j=0;j<3;j++)
       {
	 idx = j + i*3 + k9;
	 fprintf(stdout,"%+.4e  ",motion_CS.R[idx]);
       }
     fprintf(stdout,"||\n");
   }
 */
@
From \RM, the Euler angles corresponding to the 3 rotations of each segment are derived
\begin{eqnarray}
  \label{eq:41}
  \alpha &=& \arctan\left( \RM(32) \over \RM(33) \right) \\\nonumber
  \beta  &=& \arcsin\left( -\RM(31) \right) \\\nonumber
  \gamma &=& \arctan\left( \RM(21) \over \RM(11) \right) 
\end{eqnarray}
<<global tip-tilt transformation>>=
motion_CS.euler_angles[k].x = atan2(motion_CS.R[7+k9],motion_CS.R[8+k9]);
motion_CS.euler_angles[k].y = asin(-1.0*motion_CS.R[6+k9]);
motion_CS.euler_angles[k].z = atan2(motion_CS.R[3+k9],motion_CS.R[k9]);
@
The tip--tilt transformation is also applied to the origin of each segment $\vec O_k$ and the difference between the two origins is the translation of the motion CS, i.e.
\begin{equation}
  \label{eq:42}
  \vec O_k^\prime = \vec O_k - \vec O_R - \RT^T\left( \vec O_k -\vec O_R \right)
\end{equation}
where $\vec O_R$ is the rotation point.
<<global tip-tilt transformation>>=
 forward_transform(motion_CS.origin + k, rigid_body_CS.origin + k,
		   TT_CS.R, TT_CS.origin);
 motion_CS.origin[k].x = rigid_body_CS.origin[k].x - TT_CS.origin->x - motion_CS.origin[k].x;
 motion_CS.origin[k].y = rigid_body_CS.origin[k].y - TT_CS.origin->y - motion_CS.origin[k].y;
 motion_CS.origin[k].z = rigid_body_CS.origin[k].z - TT_CS.origin->z - motion_CS.origin[k].z;
 forward_transform_centered(motion_CS.origin + k, motion_CS.origin + k, rigid_body_CS.R + k9);
 HANDLE_ERROR( cudaMemcpy( motion_CS.d__origin+k, motion_CS.origin+k, 
			   sizeof(vector), cudaMemcpyHostToDevice ) );

 fprintf(stdout,"#%d >> MOTION CS origins [micron]  : %+.3e, %+.3e, %+.3e\n",k,
	 motion_CS.origin[k].x*1e6,
	 motion_CS.origin[k].y*1e6,
	 motion_CS.origin[k].z*1e6);

 float r2d;
 r2d = 1000*3600*180.0/PI;
 fprintf(stdout,"#%d >> MOTION CS Euler angles [mas]: %+.3e, %+.3e, %+.3e\n",k,
	 r2d*motion_CS.euler_angles[k].x,
	 r2d*motion_CS.euler_angles[k].y,
	 r2d*motion_CS.euler_angles[k].z);


<<GMT M1 functions>>=
void gmt_m1::global_tiptilt(float tip, float tilt)
{
  double alpha, beta, *d__C;
  vector origin, euler_angles;
  cublasHandle_t handle;
  coordinate_system TT_CS;

  origin.x = origin.y = origin.z = 0.0;
  euler_angles.x = tip;
  euler_angles.y = tilt;
  euler_angles.z = 0.0;

  TT_CS.setup(origin, euler_angles);
  cublasCreate(&handle);

  alpha = 1;
  beta  = 0;
  HANDLE_ERROR( cudaMalloc((void**)&d__C, sizeof(double)*9 ) );
  int k, k9;
  for (k=0;k<N;k++)
    {
      k9 = k*9;
      <<global tip-tilt transformation>>
    }

  cublasDestroy(handle);
  TT_CS.cleanup();
  HANDLE_ERROR( cudaFree( d__C ) );
}    

@ 
\section{GMT M2}
\label{sec:gmt-m2}

A new structure to hold GMT M1 parameters and functions is defined.
<<GMT M2 structure>>=
struct gmt_m2 {
  <<GMT M12 parameters>>
  <<GMT M12 functions>>
  void tiptilt_neutral(float tip, float tilt);
  void coma_neutral(float tip, float tilt);
};
@
\subsection{Setup \& Cleanup}
\label{sec:setup--cleanup-2}

<<GMT M2 functions>>=
void gmt_m2::setup(float _D_, int _D_px_)
{
  int N_SRC = 1;
  <<M2 parameters>>
  <<GMT setup common>>
}
@ with
<<M2 parameters>>=
 M_ID    = 2;
 D_px    = _D_px_;
 D       = _D_;
 D_full  = 1.0425*1.005; // slightly larger to always encompass M1; needed for the Zernike
 D_clear = 1.0415;
 ri      = 0.0;
 beta    = -14.706*PI/180.0;
 L       = 1.08774;
 N       = 7;
 conic_c = -1.0/4.163901;
 conic_k = 1-0.7169273;
 height  = 20.262476;
 idx_offset = 3;
@  
If an array of sources is propagated through the telescope then
<<GMT M2 functions>>=
void gmt_m2::setup(float _D_, int _D_px_, int N_SRC)
{
  ZS = NULL;
  M_ID    = 2;
  <<M2 parameters>>
  <<GMT setup common>>
}
@ 
<<GMT M2 functions>>=
void gmt_m2::setup(float _D_, int _D_px_, zernikeS *_ZS_, int N_SRC)
{
  ZS = _ZS_;
  M_ID    = 2;
  <<M2 parameters>>
  <<GMT setup common>>
}
@ 
Memory is freed with
<<GMT M2 functions>>=
void gmt_m2::cleanup(void)
{
  <<GMT cleanup common>>
}
@
\subsection{Blocking}
\label{sec:blocking-2}

The rays blocking with M2 is computed with
<<GMT M2 functions>>=
void gmt_m2::blocking(bundle *rays)
{
  <<GMT blocking common>>
}
@
\subsection{Ray tracing}
\label{sec:ray-tracing-2}

The rays propagation through M1 is computed with
<<GMT M2 functions>>=
void gmt_m2::trace(bundle *rays)
{ 
 <<GMT trace common>>
}
@
The rigid body motion parameters are updated with:
<<GMT M2 functions>>=
void gmt_m2::update(vector _origin_, vector _euler_angles_,int idx)
{
    <<GMT M12 update>>
}
@ 
The rigid body motion are reset to 0 with:
<<GMT M2 functions>>=
void gmt_m2::reset(void)
{
    <<GMT M12 reset>>
}
@
\subsection{Global motions}
\label{sec:global-motions}

\subsubsection{Tip--tilt neutral}
\label{sec:tip-tilt-neutral}

<<GMT M2 functions>>=
void gmt_m2::tiptilt_neutral(float tip, float tilt)
{
  double alpha, beta, *d__C;
  vector origin, euler_angles;
  cublasHandle_t handle;
  coordinate_system TT_CS;

  origin.x = origin.y = 0.0;
  origin.z = height + 5344e-3;
  euler_angles.x = tip;
  euler_angles.y = tilt;
  euler_angles.z = 0.0;

  TT_CS.setup(origin, euler_angles);
  cublasCreate(&handle);

  alpha = 1;
  beta  = 0;
  HANDLE_ERROR( cudaMalloc((void**)&d__C, sizeof(double)*9 ) );
  int k, k9;
  for (k=0;k<N;k++)
    {
      k9 = k*9;
      <<global tip-tilt transformation>>
    }

  cublasDestroy(handle);
  TT_CS.cleanup();
  HANDLE_ERROR( cudaFree( d__C ) );
}
@
\subsubsection{Coma neutral}
\label{sec:coma-neutral}

<<GMT M2 functions>>=
void gmt_m2::coma_neutral(float tip, float tilt)
{
  double alpha, beta, *d__C;
  vector origin, euler_angles;
  cublasHandle_t handle;
  coordinate_system TT_CS;

  origin.x = origin.y = 0.0;
  origin.z = height + 2246e-3;
  euler_angles.x = tip;
  euler_angles.y = tilt;
  euler_angles.z = 0.0;

  TT_CS.setup(origin, euler_angles);
  cublasCreate(&handle);

  alpha = 1;
  beta  = 0;
  HANDLE_ERROR( cudaMalloc((void**)&d__C, sizeof(double)*9 ) );
  int k, k9;
  for (k=0;k<N;k++)
    {
      k9 = k*9;
      <<global tip-tilt transformation>>
    }

  cublasDestroy(handle);
  TT_CS.cleanup();
  HANDLE_ERROR( cudaFree( d__C ) );
}
@
\section{Input/Output}
\label{sec:inputoutput}

\section{Tests}
\label{sec:tests}

@ 
Adding the class definitions to the definition file
<<rayTracing.pxd>>=
<<class definitions>>
