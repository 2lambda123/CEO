% -*- mode: Noweb; noweb-code-mode: c-mode -*-

The ray tracing method involves 4 steps \cite{}:
\begin{enumerate}
\item the ray coordinates are transformed into the coordinate system of the surface their interact with,
\item the intersection of the ray with the surface is found,
\item the directions of the ray after the surface is computed according to Snell''s law,
\item the coordinates and directions of the ray is transformed back into its original coordinate systems
\end{enumerate}

\section{The files}
\label{sec:files}

\subsection{Header}
\label{sec:header}

<<rayTracing.h>>=
#ifndef __RAYTRACING_H__
#define __RAYTRACING_H__

#ifndef __SOURCE_H__
#include "source.h"
#endif

#define N_ITERATION 100
#define TOL 50E-9

<<ray tracing data type>>

<<vector data type>>

<<ray data type>>

<<ray bundle structure>>

<<coordinate system data type>>

<<conic structure>>

<<conic surface>>

<<conic surface x partial>>
<<conic surface y partial>>
<<conic surface z partial>>

<<aperture structure>>

void transform_to_S(bundle *rays, conic *F);
void transform_to_S(bundle *rays, aperture *A);
void transform_to_R(bundle *rays, conic *F);
void transform_to_R(bundle *rays, aperture *A);
void intersect(bundle *rays, conic *F);
void refract(bundle *rays, const rtd mu);
void reflect(bundle *rays);
void thin_lens(bundle *rays);

#endif // __RAYTRACING_H__
@ 
\subsection{Source}
\label{sec:source}

<<rayTracing.cu>>=
#include "rayTracing.h"

<<vector functions>>

<<bundle coordinates kernel>>
<<bundle coordinates kernel (box)>>
<<gathering ray coordinates kernel>>
<<gathering ray directions kernel>>
<<gathering ray optical path length kernel>>
<<gathering ray vignetting map kernel>>
<<bundle reset kernel>>

<<ray bundle setup>>
<<ray bundle setup (box)>>
<<ray bundle cleanup>>
<<gathering ray coordinates>>
<<gathering ray directions>>
<<gathering ray optical path length>>
<<gathering ray vignetting map>>
<<bundle reset>>

<<coordinate system functions>>

<<conic setup>>
<<conic cleanup>>
<<conic setup generic>>

<<vignetting kernel>>
<<aperture functions>>

<<transformation to surface system kernel>>
<<transformation to rays system kernel>>

<<transformation to surface system>>
<<transformation to rays system>>

<<intersection with surface kernel>>
<<intersection with surface>>

<<refraction kernel>>
<<refraction>>

<<reflection kernel>>
<<reflection>>
<<thin lens>>

@ 
\subsection{Python}
\label{sec:python}

<<ceo.pxd>>=
cdef extern from "rayTracing.h":
    ctypedef double rtd
    ctypedef struct vector:
        rtd x
        rtd y
        rtd z
    ctypedef struct ray:
        vector coordinates
        vector directions
        vector surface_normal
        rtd optical_path_length
    ctypedef struct coordinate_system:
        float *float_R        
    cdef cppclass bundle:
        int N_RAY
        ray *d__ray
        void setup(source *, rtd , int , int , vector )
        void setup(source *, rtd , int , vector )
        void cleanup()
        void get_coordinates(double *)
        void get_directions(double *)
        void get_optical_path_length(double *)
        void get_vignetting(double *)
	void reset()
    cdef cppclass conic:
        coordinate_system ref_frame
        void setup(rtd , rtd , vector , vector )
        void cleanup()
    cdef cppclass aperture:
        coordinate_system ref_frame
        void setup(float, float, int, vector , vector) 
        void setup_GMT_M1(float, int)
        void cleanup()
        void vignetting(bundle *)
    void transform_to_S(bundle *, conic *)
    void transform_to_S(bundle *, aperture *)
    void transform_to_R(bundle *, conic *)
    void transform_to_R(bundle *, aperture *)
    void intersect(bundle *, conic *)
    void reflect(bundle *)
    void thin_lens(bundle *)
@ 
<<ceo.pyx>>=
# polar bundle
cdef class Bundle:
    """
    """
    cdef ceo.bundle *_c_bundle

    def __cinit__(self, Source src, rtd RADIUS, int N_RADIUS, int N_THETA=0,
                  _origin_=[0.0,0.0,0.0], type="polar"):
        self._c_bundle = new ceo.bundle()
        cdef vector origin
        origin.x = <float>_origin_[0]
        origin.y = <float>_origin_[1]
        origin.z = <float>_origin_[2]
        if type=="box":
            self._c_bundle.setup(src._c_source, RADIUS, N_RADIUS, origin)
        else:
            self._c_bundle.setup(src._c_source, RADIUS, N_RADIUS, N_THETA, origin)

    <<bundle common>>
@ 
<<bundle common>>=
def __dealloc__(self):
    self._c_bundle.cleanup()

def reset(self):
    self._c_bundle.reset()

property coordinates:
    def __get__(self):
        x = cuDoubleArray(shape=(self._c_bundle.N_RAY,3),dev_malloc=True)
        self._c_bundle.get_coordinates(x._c_gpu.dev_data)
        return x

property directions:
    def __get__(self):
        x = cuDoubleArray(shape=(self._c_bundle.N_RAY,3),dev_malloc=True)
        self._c_bundle.get_directions(x._c_gpu.dev_data)
        return x

property optical_path_length:
        def __get__(self):
            x = cuDoubleArray(shape=(self._c_bundle.N_RAY,1),dev_malloc=True)
            self._c_bundle.get_optical_path_length(x._c_gpu.dev_data)
            return x

property vignetting:
        def __get__(self):
            x = cuDoubleArray(shape=(self._c_bundle.N_RAY,1),dev_malloc=True)
            self._c_bundle.get_vignetting(x._c_gpu.dev_data)
            return x
<<ceo.pyx>>=
# conic
cdef class Conic:
    """
    """
    cdef ceo.conic *_c_conic
    cdef public np.ndarray R

    def __cinit__(self,rtd c, rtd k, origin=[0.0,0.0,0.0], euler_angles=[0.0,0.0,0.0]):
        self._c_conic = new ceo.conic()
        self.R = np.zeros((3,3),order='c',dtype=np.float32)
        cdef vector __origin
        __origin.x = <float>origin[0]
        __origin.y = <float>origin[1]
        __origin.z = <float>origin[2]
        cdef vector __euler_angles
        __euler_angles.x = <float>euler_angles[0]
        __euler_angles.y = <float>euler_angles[1]
        __euler_angles.z = <float>euler_angles[2]
        self._c_conic.ref_frame.float_R = <float *> self.R.data;
        self._c_conic.setup(c, k, __origin, __euler_angles)

    def __dealloc__(self):
        self._c_conic.cleanup()
# aperture
cdef class Aperture:
    """
    """
    cdef ceo.aperture *_c_aperture
    cdef public np.ndarray R
    
    def __cinit__(self, float D, float ri, int D_px, origin=[0.0,0.0,0.0], euler_angles=[0.0,0.0,0.0]):
        self._c_aperture = new ceo.aperture()
        self.R = np.zeros((3,3),order='c',dtype=np.float32)
        cdef vector __origin
        __origin.x = <float>origin[0]
        __origin.y = <float>origin[1]
        __origin.z = <float>origin[2]
        cdef vector __euler_angles
        __euler_angles.x = <float>euler_angles[0]
        __euler_angles.y = <float>euler_angles[1]
        __euler_angles.z = <float>euler_angles[2]
        self._c_aperture.ref_frame.float_R = <float *> self.R.data;
        self._c_aperture.setup(D, ri, D_px, __origin, __euler_angles)

    def __dealloc__(self):
        self._c_aperture.cleanup()

    def vignetting(self, Bundle rays):
        self._c_aperture.vignetting(rays._c_bundle)
# GMT M1
cdef class GMT_M1:
    """
    """
    cdef ceo.aperture *_c_aperture
    cdef public np.ndarray R
    
    def __cinit__(self, float D, int D_px):
        self._c_aperture = new ceo.aperture()
        self.R = np.zeros((3*7,3),order='c',dtype=np.float32)
        self._c_aperture.ref_frame.float_R = <float *> self.R.data;
        self._c_aperture.setup_GMT_M1(D, D_px)

    def __dealloc__(self):
        self._c_aperture.cleanup()

    def vignetting(self, Bundle rays):
        self._c_aperture.vignetting(rays._c_bundle)
# ray tracing
def Transform_to_S(Bundle rays, Conic F):
    transform_to_S(rays._c_bundle, F._c_conic)
def Transform_to_S_from_A(Bundle rays, Aperture A):
    transform_to_S(rays._c_bundle, A._c_aperture)
def Transform_to_R(Bundle rays, Conic F):
    transform_to_R(rays._c_bundle, F._c_conic)
def Transform_to_R_from_A(Bundle rays, Aperture A):
    transform_to_R(rays._c_bundle, A._c_aperture)
def Intersect(Bundle rays, Conic F):
    intersect(rays._c_bundle, F._c_conic)
def Reflect(Bundle rays):
    reflect(rays._c_bundle)
def ThinLens(Bundle rays):
    thin_lens(rays._c_bundle)

@ 
\section{Custom types}
\label{sec:custom-types}

The accuracy of the ray tracing is partly depending upon the data type used to hold data values of rays and surfaces.
GPU are faster in single precision than in double precision but double precision may still be required for accuracy.
So lets defined a ray tracing type:
<<ray tracing data type>>=
typedef double rtd;
@ 
A new vector data type is defined 
<<vector data type>>=
typedef struct {
  rtd x;
  rtd y;
  rtd z;
  __host__ __device__ rtd rho2(void);
} vector;
@ that represents the 3 coordinates in space of the tip of vector.
The square of the magnitude of a vector projected in the x,y--plane i.e. $[[x]]^2+[[y]]^2$ is computed with 
<<vector functions>>=
__host__ __device__ rtd vector::rho2(void) {
  return x*x + y*y;
}
@

\section{Ray}
\label{sec:ray}

A type for the rays is also defined:
<<ray data type>>=
typedef struct {
  <<ray data>>
} ray;
@ 
It contains the ray coordinates:
<<ray data>>=
vector coordinates;
@ 
the direction cosines of the ray:
<<ray data>>=
vector directions;
@ 
the [[surface_normal]] at the surface it intersected with the last time:
<<ray data>>=
vector surface_normal;
@ 
the optical path length:
<<ray data>>=
rtd optical_path_length;
@ the vignetting flag [[v]], $[[v]]=0$ means the ray is vignetted:
<<ray data>>=
char v;
@ and the number of iterative steps for the Raphson--Newton method:
<<ray data>>=
int n_iteration;

@
\section{Ray bundle}
\label{sec:ray-bundle}

Collections of rays are gathered into bundles:
<<ray bundle structure>>=
struct bundle {
  <<ray bundle parameters>>
  void setup(source *src, rtd RADIUS, int N_RADIUS, int N_THETA, vector origin);
  void setup(source *src, rtd L, int N_L, vector origin);
  void cleanup(void);
  void get_coordinates(double *d__coord);
  void get_directions(double *d__dir);
  void get_optical_path_length(double *d__opl);
  void get_vignetting(double *d__v);
  void reset(void);
};
@ 
A bundle allocates an array of [[N_RAY]] rays on the device
<<ray bundle parameters>>=
int N_RAY;
ray *d__ray;
vector *d__origin;
@
\subsection{Setup \& Cleanup}
\label{sec:bundle-setup--cleanup}

A ray bundle is specified with either the polar or cartesian coordinates of the rays at a given origin.
The direction cosine are derived from the coordinates of a source object.

The polar coordinates are defined with the sampling of the radius [[N_RADIUS]] from 0 to [[RADIUS]] and with the sampling of the azimuth [[N_THETA]].
<<ray bundle setup>>=
void bundle::setup(source *src, rtd RADIUS, int N_RADIUS, 
		   int N_THETA, vector origin)
{
  N_RAY = (N_RADIUS-1)*N_THETA + 1;
  HANDLE_ERROR( cudaMalloc((void**)&d__ray, sizeof(ray)*N_RAY ) );
  HANDLE_ERROR( cudaMalloc((void**)&d__origin, sizeof(vector) ) );
  HANDLE_ERROR( cudaMemcpy( d__origin, &origin, 
			    sizeof(vector), cudaMemcpyHostToDevice ) );
  <<bundle coordinates>>
}
@ 
The direction cosines $(k,l,m)$ of the rays are defined from the source zenith $\zeta$ and azimuth $\xi$ angles as
\begin{eqnarray}
  \label{eq:2}
  k &=& \sin(\zeta)\cos(\xi) \\
  l &=& \sin(\zeta)\sin(\xi) \\
  k &=& \cos(\zeta)
\end{eqnarray}
The polar coordinates $\rho$ and $\theta$ of the rays are given by
\begin{equation}
  \rho = [[RADIUS]] {k \over [[N_RADIUS]] - 1 } \forall k \in [0,[[N_RADIUS]] - 1]
\end{equation}
and
\begin{equation}
  \theta = 2\pi {k \over [[N_THETA]] } \forall k \in [0,[[N_THETA-1]]]
\end{equation}
<<bundle coordinates>>=
dim3 blockDim(16,16);
dim3 gridDim(N_RADIUS/16+1,N_THETA/16+1);
ray_coordinates LLL gridDim , blockDim, src->N_SRC RRR (d__ray, N_RAY, src->dev_ptr,
                                            RADIUS, N_RADIUS, N_THETA, d__origin);
@ 
<<bundle coordinates kernel>>=
__global__ void ray_coordinates(ray *d__ray, int N_RAY, source *src,
                            rtd RADIUS, int N_RADIUS, int N_THETA, vector *origin)
{
  int i, j, k, iSource;
  rtd rho, theta;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  iSource = blockIdx.z;
  //k = j * gridDim.x * blockDim.x + i;
  if ( (i<N_RADIUS) && (j<N_THETA) )
  {
    rho   = RADIUS*i/(N_RADIUS-1);
    if (i==0) {
      j = 0;
      k = 0;
    } else
      k = j + (i - 1)*N_THETA + 1;
    theta = 2*PI*j/N_THETA; 
    d__ray[k].coordinates.x = rho*cos(theta) + origin->x; 
    d__ray[k].coordinates.y = rho*sin(theta) + origin->y; 
    d__ray[k].coordinates.z = origin->z;
    d__ray[k].directions.x  = sin(src[iSource].zenith)*cos(src[iSource].azimuth);
    d__ray[k].directions.y  = sin(src[iSource].zenith)*sin(src[iSource].azimuth);
    d__ray[k].directions.z  = cos(src[iSource].zenith);
    d__ray[k].optical_path_length = 0.0;
    d__ray[k].coordinates.x -= d__ray[k].coordinates.z*d__ray[k].directions.x;
    d__ray[k].coordinates.y -= d__ray[k].coordinates.z*d__ray[k].directions.y;
    d__ray[k].v = 1;
  }
}
@ 

The cartesian coordinates are defined with the sampling of the square box length [[N_L]] from $-[[L]]$ to [[L]].
<<ray bundle setup (box)>>=
void bundle::setup(source *src, rtd L, int N_L, vector origin)
{
  N_RAY = N_L*N_L;
  HANDLE_ERROR( cudaMalloc((void**)&d__ray, sizeof(ray)*N_RAY ) );
  HANDLE_ERROR( cudaMalloc((void**)&d__origin, sizeof(vector) ) );
  HANDLE_ERROR( cudaMemcpy( d__origin, &origin, 
			    sizeof(vector), cudaMemcpyHostToDevice ) );
  <<bundle coordinates (box)>>
}
@ 
The direction cosines $(k,l,m)$ of the rays are defined from the source zenith $\zeta$ and azimuth $\xi$ angles as
\begin{eqnarray}
  \label{eq:2}
  k &=& \sin(\zeta)\cos(\xi) \\
  l &=& \sin(\zeta)\sin(\xi) \\
  k &=& \cos(\zeta)
\end{eqnarray}
The cartesian coordinates $x$ and $y$ of the rays are given by
\begin{eqnarray}
  x &=& L*(i-([[N_L]]-1)/2)/([[N_L]]-1) \\
  y &=& L*(j-([[N_L]]-1)/2)/([[N_L]]-1)
\end{eqnarray}
<<bundle coordinates (box)>>=
dim3 blockDim(16,16);
dim3 gridDim(N_L/16+1,N_L/16+1);
ray_coordinates_box LLL gridDim , blockDim, src->N_SRC RRR (d__ray, N_RAY, src->dev_ptr,
                                                            L, N_L, d__origin);
@ 
<<bundle coordinates kernel (box)>>=
__global__ void ray_coordinates_box(ray *d__ray, int N_RAY, source *src,
                                    rtd L, int N_L, vector *origin)
{
  int i, j, k, iSource;
  rtd x, y;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  iSource = blockIdx.z;
  if ( (i<N_L) && (j<N_L) )
  {
    x   = L*(i - (N_L-1)*0.5)/(N_L-1);
    y   = L*(j - (N_L-1)*0.5)/(N_L-1);
    k = i + j*N_L;
    d__ray[k].coordinates.x = x + origin->x; 
    d__ray[k].coordinates.y = y + origin->y; 
    d__ray[k].coordinates.z = origin->z;
    d__ray[k].directions.x  = sin(src[iSource].zenith)*cos(src[iSource].azimuth);
    d__ray[k].directions.y  = sin(src[iSource].zenith)*sin(src[iSource].azimuth);
    d__ray[k].directions.z  = cos(src[iSource].zenith);
    d__ray[k].optical_path_length = 0.0;
    d__ray[k].coordinates.x -= d__ray[k].coordinates.z*d__ray[k].directions.x;
    d__ray[k].coordinates.y -= d__ray[k].coordinates.z*d__ray[k].directions.y;
    d__ray[k].v = 1;
  }
}
@
Memory is freed with
<<ray bundle cleanup>>=
void bundle::cleanup(void) 
{
  fprintf(stdout,"@(CEO)>bundle: freeing memory!\n");
  HANDLE_ERROR( cudaFree( d__ray ) );
  HANDLE_ERROR( cudaFree( d__origin ) );
}
@ 
<<gathering ray coordinates>>=
void bundle::get_coordinates(double *d__coord)
{
  dim3 blockDim(16,16);
  dim3 gridDim(N_RAY/256+1,1);
  get_coordinates_kernel LLL gridDim , blockDim RRR (d__coord, d__ray, N_RAY);
}
@ 
<<gathering ray coordinates kernel>>=
__global__ void get_coordinates_kernel(double *d__coord, ray *d__ray, int N_RAY)
{
  int i, j, k;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  k = j * gridDim.x * blockDim.x + i;
  if ( k<N_RAY )
  {
    d__coord[3*k]   = d__ray[k].coordinates.x;
    d__coord[3*k+1] = d__ray[k].coordinates.y;
    d__coord[3*k+2] = d__ray[k].coordinates.z;
  }
}
@ 
<<gathering ray directions>>=
void bundle::get_directions(double *d__dir)
{
  dim3 blockDim(16,16);
  dim3 gridDim(N_RAY/256+1,1);
  get_directions_kernel LLL gridDim , blockDim RRR (d__dir, d__ray, N_RAY);
}
@ 
<<gathering ray directions kernel>>=
__global__ void get_directions_kernel(double *d__dir, ray *d__ray, int N_RAY)
{
  int i, j, k;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  k = j * gridDim.x * blockDim.x + i;
  if ( k<N_RAY )
  {
    d__dir[3*k]   = d__ray[k].directions.x;
    d__dir[3*k+1] = d__ray[k].directions.y;
    d__dir[3*k+2] = d__ray[k].directions.z;
  }
}
@ 
<<gathering ray optical path length>>=
void bundle::get_optical_path_length(double *d__opl)
{
  dim3 blockDim(16,16);
  dim3 gridDim(N_RAY/256+1,1);
  get_optical_path_length_kernel LLL gridDim , blockDim RRR (d__opl, d__ray, N_RAY);
}
@ 
<<gathering ray optical path length kernel>>=
__global__ void get_optical_path_length_kernel(double *d__opl, ray *d__ray, int N_RAY)
{
  int i, j, k;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  k = j * gridDim.x * blockDim.x + i;
  if ( k<N_RAY )
    d__opl[k]   = d__ray[k].optical_path_length;
}
@ 
<<gathering ray vignetting map>>=
void bundle::get_vignetting(double *d__v)
{
  dim3 blockDim(16,16);
  dim3 gridDim(N_RAY/256+1,1);
  get_vignetting_kernel LLL gridDim , blockDim RRR (d__v, d__ray, N_RAY);
}
@ 
<<gathering ray vignetting map kernel>>=
__global__ void get_vignetting_kernel(double *d__v, ray *d__ray, int N_RAY)
{
  int i, j, k;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  k = j * gridDim.x * blockDim.x + i;
  if ( k<N_RAY )
    d__v[k]   = (d__ray[k].v) ? 1.0 : 0.0;
}
@ 
The ray vignetting is reset with
<<bundle reset>>=
void bundle::reset(void) 
{
  dim3 blockDim(16,16);
  dim3 gridDim(N_RAY/256+1,1);  
  reset_kernel LLL gridDim , blockDim RRR (d__ray, N_RAY);
}
@ with 
<<bundle reset kernel>>=
__global__ void reset_kernel(ray *d__ray, int N_RAY)
{
  int i, j, k;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  k = j * gridDim.x * blockDim.x + i;
  if ( k<N_RAY )
    d__ray[k].v = 0;
}
@

\section{Coordinate system}
\label{sec:coordinate-system}

The surface location and orientation with respect to the GCS is specified with a coordinate vector:
<<coordinate system data>>=
vector *origin;
@ and with 3 Euler angles with respected to the x, y and z axis.
<<coordinate system data>>=
vector *euler_angles;
@ The surface can be made of [[N]] identical segments
<<coordinate system data>>=
int N; 
@
The rotation matrix [[R]] used to transform the ray coordinates into the surface coordinates (and back!) is defined with
<<coordinate system data>>=
rtd *R, *d__R;
float *float_R;
vector *d__origin;
@ 
They are gathered in a new coordinate system data type
<<coordinate system data type>>=
typedef struct {
  <<coordinate system data>>
  void setup(void);
  void setup(vector _origin_, vector _euler_angles_);
  void setup(vector *_origin_, vector *_euler_angles_, int _N_);
  void cleanup(void);
  void info(void);
} coordinate_system;
@ 

\subsection{Setup \& Cleanup}
\label{sec:setup--cleanup}

A coordinate system structure is initialized with
\begin{itemize}
\item a single origin and orientation,
<<coordinate system functions>>=
void coordinate_system::setup(vector _origin_, vector _euler_angles_)
{
  N = 1;
  int n_byte = sizeof(vector)*N;
  origin = (vector *)malloc( n_byte );
  memcpy( origin , &_origin_ , n_byte);
  euler_angles = (vector *)malloc( n_byte );
  memcpy(euler_angles,  &_euler_angles_, n_byte);
  <<rotation matrix eval>>
  <<allocation>>  
  info();
}
@ 
\item origin and orientation align to the main coordinate system,
<<coordinate system functions>>=
void coordinate_system::setup(void)
{
  N = 1;
  int n_byte = sizeof(vector)*N;
  origin = (vector *)malloc( n_byte );
  euler_angles = (vector *)malloc( n_byte );
  origin[0].x = 0;
  origin[0].y = 0;
  origin[0].z = 0;
  euler_angles[0].x = 0;
  euler_angles[0].y = 0;
  euler_angles[0].z = 0;
  <<rotation matrix eval>>
  <<allocation>>  
  info();
}
@ 
\item an array of [[N]] origins and orientations
<<coordinate system functions>>=
void coordinate_system::setup(vector *_origin_, vector *_euler_angles_, int _N_)
{
  N = _N_;
  int n_byte = sizeof(vector)*N;
  origin = (vector *)malloc( n_byte );
  memcpy( origin , _origin_ , n_byte);
  euler_angles = (vector *)malloc( n_byte );
  memcpy(euler_angles,  _euler_angles_, n_byte);
  <<rotation matrix eval>>
  <<allocation>>  
  info();
}
@
\end{itemize}

Device allocation
<<allocation>>=
HANDLE_ERROR( cudaMalloc((void**)&d__R, sizeof(rtd)*9*N ) );
HANDLE_ERROR( cudaMemcpy( d__R, R, 
			    sizeof(rtd)*9*N, cudaMemcpyHostToDevice ) );
HANDLE_ERROR( cudaMalloc((void**)&d__origin, sizeof(vector)*N ) );
HANDLE_ERROR( cudaMemcpy( d__origin, origin, 
			    sizeof(vector)*N, cudaMemcpyHostToDevice ) );
@
The rotation matrix to transform the ray coordinates in the LCS is given by
\begin{eqnarray}
R &=& \left[ 
  \begin{array}{ccc}
    c\gamma & -s\gamma & 0 \\
    s\gamma &  c\gamma & 0 \\
    0       &  0       & 1
  \end{array}
  \right] \left[
  \begin{array}{ccc}
    c\beta & 0 & -s\beta \\
    0      & 1 &  0 \\
    s\beta & 0 &  c\beta
  \end{array}
  \right] \left[
    \begin{array}{ccc}
      1       &  0       & 0 \\
      0       &  c\alpha & -s\alpha \\
      0       &  s\alpha &  c\alpha 
    \end{array}
\right] \\
&=& \left[
  \begin{array}{ccc}
    c\beta c\gamma &  s\alpha s\beta s\gamma + s\alpha s\gamma & -c\alpha s\beta c\gamma + s\alpha s\gamma \\
    c\beta s\gamma & -s\alpha s\beta s\gamma + c\alpha c\gamma & -c\alpha s\beta s\gamma - s\alpha c\gamma \\
    s\beta         &  s\alpha c\beta                           &  c\alpha c\beta
  \end{array}
\right]
\end{eqnarray}
@ where $cx$ and $sx$ stands for $\sin(x)$ and $\cos(x)$, respectively.
$\alpha$, $\beta$ and $\gamma$ are the Euler angles along the x, y and z axis respectively.
The matrix is computed with
<<rotation matrix eval>>=
R = (rtd *)malloc( sizeof(rtd)*9*N );
rtd ca, sa, cb, sb, cg, sg;
int k, idx;
for (k=0; k<N; k++)
  {
    idx = k;
    ca = cos(euler_angles[idx].x);
    sa = sin(euler_angles[idx].x);
    cb = cos(euler_angles[idx].y);
    sb = sin(euler_angles[idx].y);
    cg = cos(euler_angles[idx].z);
    sg = sin(euler_angles[idx].z);
    idx *= 9;
    R[idx++] = cb*cg;
    R[idx++] = -sa*sb*cg - ca*sg;
    R[idx++] = -ca*sb*cg + sa*sg;
    R[idx++] = cb*sg;
    R[idx++] = -sa*sb*sg + ca*cg;
    R[idx++] = -ca*sb*sg - sa*cg;
    R[idx++] = sb;
    R[idx++] = sa*cb;
    R[idx++] = ca*cb;
  }
for (int k=0;k<9;k++)
   *(float_R+k) = (float) R[k];
@ where the elements of $R$ are stored in the row major format.
<<coordinate system functions>>=
void coordinate_system::cleanup(void)
{
  free( origin );
  free( euler_angles );
  free(R);
  HANDLE_ERROR( cudaFree( d__R ) );
  HANDLE_ERROR( cudaFree( d__origin ) );
}
@ 
\subsection{Input/Output}
\label{sec:inputoutput}

The main parameters of the coordinate systems are displayed with the [[info]] routine:
<<coordinate system functions>>=
void coordinate_system::info(void)
{
  fprintf(stdout,"\n\x1B[1;42m@(CEO)>%s:\x1B[;42m\n","coordinate_system");
  fprintf(stdout," ID   (Tx     Ty      Tz)[m]     (Ox      Oy     Oz)[deg]\n");
  float c = 180.0/PI;
  int k;
  for (k=0; k<N; k++)
     fprintf(stdout," %2d %6.2f %6.2f %6.2f   %6.2f %6.2f %6.2f\n", k,
	  origin[k].x, origin[k].y, origin[k].z,
	  euler_angles[k].x*c, euler_angles[k].y*c, euler_angles[k].z*c);
  fprintf(stdout,"----------------------------------------------------\x1B[0m\n");
}
@ 

\section{Surface}
\label{sec:surface}

A conic surface is represented with the [[conic]] structure:
<<conic structure>>=
struct conic {

  <<conic parameters>>
  
  void setup(rtd _c_, rtd _k_);
  void setup(rtd _c_, rtd _k_, vector _origin_, vector _euler_angles_);
  void cleanup(void);
};
@
<<conic parameters>>=
coordinate_system ref_frame; 
@
The conic shape is specified with two parameters:
<<conic parameters>>=
rtd c, k;
@ 
where [[c]] is the vertex curvature and [[k]] is the conic parameter.

The conic surface is defined with
\begin{equation}
 \label{eq:4}
  F(x,y,z) = z - {c\rho^2 \over 1 + \sqrt{1 - \kappa c^2 \rho^2} } = 0.
\end{equation}

<<conic surface>>=
__device__ inline rtd conic_surface(vector *v, const rtd k, const rtd c)
{
  if (c==0)
    return v->z;
  else {    
    rtd rho2;
    rho2 = c*v->rho2();
    if (k==0)
      return v->z - rho2*0.5;
    else
      return v->z - rho2/( 1 + sqrt(1 - k*c*rho2) );
  }
}
@ 
The partial derivative of the conic equation are written
\begin{itemize}
\item
  \begin{equation}
    { \partial F(x,y,z) \over \partial x } = -x {c \over \sqrt{ 1 - \kappa c^2 \rho^2 } }
  \end{equation}
<<conic surface x partial>>=
__device__ inline rtd partial_x_conic_surface(vector *v, const rtd k, const rtd c)
{
  if (c==0)
    return 0.0;
  else    
    if (k==0)
      return -v->x*c;
    else {
      rtd rho2;
      rho2 = c*v->rho2();
      return -v->x*c*rsqrt(1 - k*c*rho2);
    }
}
@
\item
  \begin{equation}
    { \partial F(x,y,z) \over \partial y } = -y {c \over \sqrt{ 1 - \kappa c^2 \rho^2 } }
  \end{equation}
<<conic surface y partial>>=
__device__ inline rtd partial_y_conic_surface(vector *v, const rtd k, const rtd c)
{
  if (c==0)
    return 0.0;
  else    
    if (k==0)
      return -v->y*c;
    else {
      rtd rho2;
      rho2 = c*v->rho2();
      return -v->y*c*rsqrt(1 - k*c*rho2);
    }
}
@
\item
  \begin{equation}
    { \partial F(x,y,z) \over \partial z } = 1
  \end{equation}
<<conic surface z partial>>=
__device__ inline rtd partial_z_conic_surface(void)
{
  return 1.0;
}
@
\end{itemize}

\subsection{Setup \& Cleanup}
\label{sec:surf-setup--cleanup}

A conic surface is initialized with the [[setup]] routine:
<<conic setup generic>>=
void conic::setup(rtd _c_, rtd _k_, vector _origin_, vector _euler_angles_)
{
  c = _c_;
  k = _k_;
  ref_frame.setup(_origin_, _euler_angles_);
}
@
A conic surface that sets in the GCS is simply defined with
<<conic setup>>=
void conic::setup(rtd _c_, rtd _k_)
{
  c = _c_;
  k = _k_;
  ref_frame.setup();
}
@
Memory is freed with
<<conic cleanup>>=
void conic::cleanup(void)
{
  ref_frame.cleanup();
}
@

\section{Aperture}
\label{sec:aperture}

An aperture is a bounded surface used to clip a bundle of ray to the aperture shape.
<<aperture structure>>=
struct aperture {
  <<aperture parameters>>
  void setup(float _D_, int _D_px_, 
	     vector _origin_, vector _euler_angles_);
  void setup(float _D_, float _ri_, int _D_px_, 
	     vector _origin_, vector _euler_angles_);
  void setup(float _D_, float _ri_, float _D_seg_, int _D_px_, 
	     vector *_origin_, vector *_euler_angles_, int N_segment);
  void setup_GMT_M1(float _D_, int _D_px_);
  void cleanup(void);
  void vignetting(bundle *rays);

};
@
A circular aperture is defined by its diameter [[D]] in meter of [[D_px]] in pixel.
If the aperture is annular [[ri]] defines the ratio between the inner and outer diameter.
The aperture can be segmented with [[N]] identical segments of diameter [[D_seg]].
The location of the aperture segments is defined within a given coordinate system [[ref_frame]].
A mask [[V]] is used to select the rays that are not vignetted by the aperture.
<<aperture parameters>>= 
int D_px;
float D, ri, D_seg;
int N;
mask V;
coordinate_system ref_frame;

@
\subsection{Setup \& Cleanup}
\label{sec:aper-setup--cleanup}

An aperture is initialized with:
\begin{itemize}
\item for a circular aperture,
<<aperture functions>>=
void aperture::setup(float _D_, int _D_px_, 
		     vector _origin_, vector _euler_angles_) 
{
  D_px = _D_px_;
  D_seg = D = _D_;
  ri   = 0.0;
  N = 1;
  V.setup(D_px*D_px);
  ref_frame.setup(_origin_, _euler_angles_);
}
@  \item for an annular aperture,
<<aperture functions>>=
void aperture::setup(float _D_, float _ri_, int _D_px_, 
		     vector _origin_, vector _euler_angles_) 
{
  D_px = _D_px_;
  D_seg = D = _D_;
  ri   = _ri_;
  N = 1;
  V.setup(D_px*D_px);
  ref_frame.setup(_origin_, _euler_angles_);
}
@
\item for an aperture with [[N_segment]] circular segment of diameter [[D_seg]], each segment with a different coordinate system,
<<aperture functions>>=
void aperture::setup(float _D_, float _ri_, float _D_seg_, int _D_px_, 
		     vector *_origin_, vector *_euler_angles_, int N_segment)
{
  D_px  = _D_px_;
  D     = _D_;
  D_seg = _D_seg_;
  ri    = _ri_;
  N = N_segment;
  V.setup(D_px*D_px*N);
  ref_frame.setup(_origin_, _euler_angles_, N);
}
@
\end{itemize}

Based on the above, one can defined specific segmented apertures like
\begin{description}
\item[GMT M1] 
The GMT M1 segment have all the same clear aperture of 8.365m diameter.
The center segment has a hole of 1.78m diameter.
The center aperture is centered on the vertex of the conic surface that defines M1.
The vertex is set as the origin of the global coordinate system (GCS).
The center of the peripheral segments are evenly located on a circle of radius 8.710m with a phase of 30 degrees.
The peripheral segments also tilted inwards by 13.522 degrees.
<<aperture functions>>=
void aperture::setup_GMT_M1(float _D_, int _D_px_)
{
  D_px  = _D_px_;
  D     = _D_;
  D_seg = 8.365;
  ri    = 1.780/8.365;
  N = 7;
  vector origin[7];
  vector euler_angles[7];
  origin[0].x = origin[0].y = origin[0].z = 0.0;
  euler_angles[0].x = euler_angles[0].y = euler_angles[0].z = 0.0;
  rtd D_c, o, zo, sa;
  sa = sin(13.522*PI/180);
  D_c = 8.710 - (0.691-0.445)*sa;
  zo = 8.417*sa*0.5 + 0.691 - 0.445;
  int k;  
  for (k=1; k<N; k++)
  {
    o = PI*(2*k-1)/6.0;
    origin[k].x = D_c*cosf(o);
    origin[k].y = D_c*sinf(o);
    origin[k].z = zo;
    euler_angles[k].x = 0.0;
    euler_angles[k].y = 13.522*PI/180.0;
    euler_angles[k].z = o;
  }
  V.setup(D_px*D_px*N);
  ref_frame.setup(origin, euler_angles, N);
}
@ 
\end{description}


The memory is freed with
<<aperture functions>>=
void aperture::cleanup(void)
{
  V.cleanup();
  ref_frame.cleanup();
}
@ 
The vignetting of the rays are done with
<<aperture functions>>=
void aperture::vignetting(bundle *rays)
{
  float R2, Rri2;
  R2 = D_seg*D_seg*0.25;
  Rri2 = R2*ri*ri;
  fprintf(stdout,"R2=%5.2f - Rri2=%5.2f\n",R2,Rri2);  
  dim3 blockDim(16,16);
  dim3 gridDim(rays->N_RAY/256+1,N);
  rays->reset();
  vignetting_kernel LLL gridDim , blockDim RRR (V.m, rays->d__ray, rays->N_RAY, 
						Rri2, R2,
						ref_frame.d__R,
						ref_frame.d__origin);
}
@ calling the device kernel:
<<vignetting kernel>>=
__global__ void vignetting_kernel(char *mask, ray *d__ray, int N_RAY, 
				  float inner2, float outer2,
				  rtd *d__R, vector *d__origin)
{
  int i, j, ij, iCoordSys, idx;
  rtd rho2;
  rtd x, y, z, u, v, w, x1, y1, s0, k, l, m;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = threadIdx.y;
  iCoordSys = blockIdx.y;
  ij = j * gridDim.x * blockDim.x + i;
  if ( ij<N_RAY )
  {

    idx = iCoordSys;

    u = d__ray[ij].coordinates.x - d__origin[idx].x;
    v = d__ray[ij].coordinates.y - d__origin[idx].y;
    w = d__ray[ij].coordinates.z - d__origin[idx].z;

    idx = iCoordSys*9;

    x = d__R[0+idx]*u + d__R[3+idx]*v + d__R[6+idx]*w;
    y = d__R[1+idx]*u + d__R[4+idx]*v + d__R[7+idx]*w;
    z = d__R[2+idx]*u + d__R[5+idx]*v + d__R[8+idx]*w;

    u = d__ray[ij].directions.x;
    v = d__ray[ij].directions.y;
    w = d__ray[ij].directions.z;

    k = d__R[0+idx]*u + d__R[3+idx]*v + d__R[6+idx]*w;
    l = d__R[1+idx]*u + d__R[4+idx]*v + d__R[7+idx]*w;
    m = d__R[2+idx]*u + d__R[5+idx]*v + d__R[8+idx]*w;

    if (m==0) { return; }
    s0 = -z/m;
    x1 = x + k*s0;
    y1 = y + l*s0;
    rho2 = x1*x1 + y1*y1;
    if (rho2<=outer2)
      {
	d__ray[ij].v = 1;
	mask[ij] = 1;
      }
    if ( (iCoordSys==0) && (rho2<inner2) )
      {
	d__ray[ij].v = 0;
	mask[ij] = 0;
      }
  }
}
@

\section{Ray tracing routines}
\label{sec:ray-tracing-routines}

\subsection{Coordinates transformation}
\label{sec:coord-transf}

The coordinates and cosine directions of the rays need to be transformed into the surface coordinates system first.
The matrix [[R]] in the conic structure transforms the coordinates in the LCS $(x,y,z)$ into the GCS $(\bar x,\bar y,\bar z)$ i.e.
\begin{equation}
  \left[
  \begin{array}{c}
    \bar x - \bar x_o \\
    \bar y - \bar y_o \\
    \bar z - \bar z_o
  \end{array}
  \right] = R \left[
    \begin{array}{c}
      x \\
      y \\
      z
    \end{array}
\right]
\end{equation}
The reverse transform is simply
\begin{equation}
  \left[
    \begin{array}{c}
      x \\
      y \\
      z
    \end{array}
\right] = R^T \left[
  \begin{array}{c}
    \bar x - \bar x_o \\
    \bar y - \bar y_o \\
    \bar z - \bar z_o
  \end{array}
  \right] = \left( \left[
  \begin{array}{c}
    \bar x - \bar x_o \\
    \bar y - \bar y_o \\
    \bar z - \bar z_o
  \end{array}
  \right]^T R \right)^T 
\end{equation}
<<transformation to surface system>>=
void transform_to_S(bundle *rays, conic *F)
{
  dim3 blockDim(16,16);
  dim3 gridDim(rays->N_RAY/256+1,1);
  transform_to_S_kernel LLL gridDim , blockDim RRR (rays->d__ray, rays->N_RAY,
					     F->ref_frame.d__R, F->ref_frame.d__origin);
}
void transform_to_S(bundle *rays, aperture *A)
{
  dim3 blockDim(16,16);
  dim3 gridDim(rays->N_RAY/256+1,1);
  transform_to_S_kernel LLL gridDim , blockDim RRR (rays->d__ray, rays->N_RAY,
					     A->ref_frame.d__R, A->ref_frame.d__origin);
}
@ 
<<transformation to surface system kernel>>=
__global__ void transform_to_S_kernel(ray *d__ray, int N_RAY, 
				      rtd *d__R, vector *d__origin)
{
  int i, j, ij;
  rtd x, y, z, u, v, w;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  ij = j * gridDim.x * blockDim.x + i;
  if ( (ij<N_RAY) && (d__ray[ij].v) )
  {
    <<rays coordinates to surface>>
  }
}
@ with the projection of the ray coordinates in the surface reference frame LCS:
<<rays coordinates to surface>>=
u = d__ray[ij].coordinates.x - d__origin->x;
v = d__ray[ij].coordinates.y - d__origin->y;
w = d__ray[ij].coordinates.z - d__origin->z;

x = d__R[0]*u + d__R[3]*v + d__R[6]*w;
y = d__R[1]*u + d__R[4]*v + d__R[7]*w;
z = d__R[2]*u + d__R[5]*v + d__R[8]*w;

d__ray[ij].coordinates.x = x;
d__ray[ij].coordinates.y = y;
d__ray[ij].coordinates.z = z;    

u = d__ray[ij].directions.x;
v = d__ray[ij].directions.y;
w = d__ray[ij].directions.z;

x = d__R[0]*u + d__R[3]*v + d__R[6]*w;
y = d__R[1]*u + d__R[4]*v + d__R[7]*w;
z = d__R[2]*u + d__R[5]*v + d__R[8]*w;

d__ray[ij].directions.x = x;
d__ray[ij].directions.y = y;
d__ray[ij].directions.z = z;    
@ 
<<transformation to rays system>>=
void transform_to_R(bundle *rays, conic *F)
{
  dim3 blockDim(16,16);
  dim3 gridDim(rays->N_RAY/256+1,1);
  transform_to_R_kernel LLL gridDim , blockDim RRR (rays->d__ray, rays->N_RAY,
        	 				     F->ref_frame.d__R, F->ref_frame.d__origin);
}
void transform_to_R(bundle *rays, aperture *A)
{
  dim3 blockDim(16,16);
  dim3 gridDim(rays->N_RAY/256+1,1);
  transform_to_R_kernel LLL gridDim , blockDim RRR (rays->d__ray, rays->N_RAY,
        	 				     A->ref_frame.d__R, A->ref_frame.d__origin);
}
@ 
<<transformation to rays system kernel>>=
__global__ void transform_to_R_kernel(ray *d__ray, int N_RAY,
                                      rtd *d__R, vector *d__origin)
{
  int i, j, k;
  rtd x, y, z, u, v, w;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  k = j * gridDim.x * blockDim.x + i;
  if ( (k<N_RAY) && (d__ray[k].v) )
  {

    <<rays coordinates to rays>>

    u = d__ray[k].directions.x;
    v = d__ray[k].directions.y;
    w = d__ray[k].directions.z;

    x = d__R[0]*u + d__R[1]*v + d__R[2]*w;
    y = d__R[3]*u + d__R[4]*v + d__R[5]*w;
    z = d__R[6]*u + d__R[7]*v + d__R[8]*w;

    d__ray[k].directions.x = x;
    d__ray[k].directions.y = y;
    d__ray[k].directions.z = z;    
  }
}
@ with the projection of the ray coordinates in the rays reference frame LCS:
<<rays coordinates to rays>>=
u = d__ray[k].coordinates.x;
v = d__ray[k].coordinates.y;
w = d__ray[k].coordinates.z;

x = d__R[0]*u + d__R[1]*v + d__R[2]*w;
y = d__R[3]*u + d__R[4]*v + d__R[5]*w;
z = d__R[6]*u + d__R[7]*v + d__R[8]*w;

d__ray[k].coordinates.x = x + d__origin->x;
d__ray[k].coordinates.y = y + d__origin->y;
d__ray[k].coordinates.z = z + d__origin->z;    
@ 

\subsection{Surface intersection}
\label{sec:surface-intersection}

<<intersection with surface>>=
void intersect(bundle *rays, conic *F)
{
  dim3 blockDim(16,16);
  dim3 gridDim(rays->N_RAY/256+1,1);
  intersect_kernel LLL gridDim , blockDim RRR (rays->d__ray, rays->N_RAY, F->k, F->c);
}

<<intersection with surface kernel>>=
__global__ void intersect_kernel(ray *d__ray, int N_RAY, const rtd Fk, const rtd Fc)
{
  int i, j, ij;
  rtd s0, s1, x1, y1, k, l, m, S, K, L ,M, dSds;
  vector v;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  ij = j * gridDim.x * blockDim.x + i;
  if ( (ij<N_RAY) && (d__ray[ij].v) )
  {
    <<intersection with z=0 plane>>
    d__ray[ij].optical_path_length += s0;
    s0 = s1 = 0;
    for (j=0; j<N_ITERATION; j++)
    {
      <<Newton-Raphson>>
	s0 = s1;
    }
  }
}
@
The intersection of a ray with the surface is derived using the parametric equations of the ray
\begin{eqnarray}
  \label{eq:3}
  x &=& x_0 + ks \\
  y &=& y_0 + ls \\
  z &=& z_0 + ms   
\end{eqnarray}
where $s$ is the distance along the ray from the point $(x_0,y_0,z_0)$.
Eq.~(\ref{eq:3}) are inserted into the surface definition Eq.~(\ref{eq:4}) that is solved for $s$.

The intersection with the plane $z=0$ in the LCS is derived first leading to 
\begin{eqnarray}
  \label{eq:5}
  s_0 &=& -z_0/m \\
  x_1 &=& x_0 + ks_0 \\
  y_1 &=& y_0 + ls_0 
\end{eqnarray}
<<intersection with z=0 plane>>=
k  = d__ray[ij].directions.x;
l  = d__ray[ij].directions.y;
m  = d__ray[ij].directions.z;
if (m==0) { return; }
s0 = -d__ray[ij].coordinates.z/m;
x1 = d__ray[ij].coordinates.x + k*s0;
y1 = d__ray[ij].coordinates.y + l*s0;
@
and giving a new set of parametric equations
\begin{eqnarray}
  \label{eq:6}
  x &=& x_1 + ks \\
  y &=& y_1 + ls \\
  z &=& ms     
\end{eqnarray}
 
The distance $s$ to the surface is obtained with the Newton--Raphson iterative method
\begin{equation}
  \label{eq:7}
  s_{j+1} = s_j - { F(x_j,y_j,z_j) \over F^\prime(x_j,y_j,z_j) }
\end{equation}
where
\begin{eqnarray}
  \label{eq:8}
  x_j &=& x_1 + ks_j \\
  y_j &=& y_1 + ls_j \\
  z_j &=& ms_j       
\end{eqnarray}
<<Newton-Raphson>>=
v.x = x1 + k*s0;
v.y = y1 + l*s0;
v.z = m*s0;
@ and where
\begin{eqnarray}
  \label{eq:9}
  F^\prime(x_j,y_j,z_j) &=& \left. { {\mathrm d} F \over {\mathrm d} s  } \right|_{s=s_j} \\
                      &=& k\left.{ \partial F(x,y,z) \over \partial x } \right|_j + l\left. { \partial F(x,y,z) \over \partial y }\right|_j + m\left.{ \partial F(x,y,z) \over \partial z }\right|_j
\end{eqnarray}
<<Newton-Raphson>>=
S = conic_surface(&v, Fk, Fc);
K = partial_x_conic_surface(&v, Fk, Fc);
L = partial_y_conic_surface(&v, Fk, Fc);
M = partial_z_conic_surface();
dSds = K*k + L*l + M*m;
if (dSds==0) { return; }
s1 = s0 - S/dSds;
if (abs(s1-s0)<TOL)
{
  d__ray[ij].coordinates.x = x1 + k*s1;
  d__ray[ij].coordinates.y = y1 + l*s1;
  d__ray[ij].coordinates.z = m*s1;
  d__ray[ij].surface_normal.x    = partial_x_conic_surface(&(d__ray[ij].coordinates), Fk, Fc);
  d__ray[ij].surface_normal.y    = partial_y_conic_surface(&(d__ray[ij].coordinates), Fk, Fc);
  d__ray[ij].surface_normal.z    = partial_z_conic_surface();
  d__ray[ij].optical_path_length += s1;
  return;
}
@
The iterative process is started with
\begin{equation}
  \label{eq:11}
  s_1 = 0,
\end{equation}
and is terminated when
\begin{equation}
  \label{eq:12}
  \left|s_{j+1} - s_j \right| < \epsilon,
\end{equation}
where $\epsilon$ is a tolerance set by the required accuracy.

The final distance along a ray from the point $(x_0,y_0,z_0)$ is
\begin{equation}
  \label{eq:13}
  s = s_0 + s_{j+1}.
\end{equation}

The surface normal at the intersection point will be needed to compute the refracted ray:
\begin{eqnarray}
  \label{eq:1}
  K &=& \left.{ \partial F(x,y,z) \over \partial x } \right|_{j+1} \\
  L &=& \left.{ \partial F(x,y,z) \over \partial y } \right|_{j+1} \\
  M &=& \left.{ \partial F(x,y,z) \over \partial z } \right|_{j+1}.
\end{eqnarray}
@

\subsection{Snell's law}
\label{sec:snells-law}

\subsubsection{Refraction}
\label{sec:refraction}

\def\np{n^\prime}
\def\kp{k^\prime}
\def\lp{l^\prime}
\def\mp{m^\prime}
\def\Sp{S^\prime}

The Snell's law can be written as
\begin{equation}
  \label{eq:10}
  \np \vec \Sp \times \vec r = n \vec S \times \vec r.
\end{equation}
$\vec S:(k,l,m)$ and $\vec \Sp:(\kp,\lp,\mp)$ are both unit vectors along the incident and refracted rays, respectively.
$\vec r:(K,L,M)$ is a unit vector normal to the refraction surface at the ray intersection point.
$n$ and $\np$ are the refractive indices for the incident and refracted rays, respectively.

Eq.~(\ref{eq:10}) implies that the three vectors $\vec S$, $\vec \Sp$ and $\vec r$ are co--planar, from which it follows that
\begin{equation}
  \label{eq:14}
  \vec \Sp = \mu \vec S + \Gamma \vec r,
\end{equation}
where $\mu=n/\np$ and $\Gamma$ has to be determined.
$\Gamma$ is derived by solving
\begin{equation}
  \label{eq:15}
  \left| \vec \Sp \right|^2 - \left| \mu \vec S + \Gamma \vec r \right|^2 = 0
\end{equation}
Developing Eq.~(\ref{eq:15}) leads to $\Gamma$ being the solution of a quadratic equation
\begin{equation}
  \label{eq:16}
  \Gamma^2 + 2a\Gamma + b = 0
\end{equation}
where
\begin{equation}
  \label{eq:17}
  a = \mu { kK +lL + mM \over K^2 + L^2 + M^2 },
\end{equation}
<<a equation>>=
K = d__ray[ij].surface_normal.x;
L = d__ray[ij].surface_normal.y;
M = d__ray[ij].surface_normal.z;
G2 = K*K + L*L + M*M;
k = d__ray[ij].directions.x;
l = d__ray[ij].directions.y;
m = d__ray[ij].directions.z;
a = mu*(k*K + l*L + m*M)/G2;
@  and
\begin{equation}
  \label{eq:18}
  b = { \mu^2 -1 \over K^2 + L^2 + M^2 }.
\end{equation}
<<b equation>>=
b = (mu*mu-1)/G2;
@ 
Eq.~(\ref{eq:16}) is solved with the Newton--Raphson iterative method by introducing the new function
\begin{equation}
  \label{eq:19}
  V(\Gamma) = \Gamma^2 + 2a\Gamma + b,
\end{equation}
and writing $\Gamma$ as
\begin{equation}
  \label{eq:20}
  \Gamma_{j+1} = \Gamma_j - { V(\Gamma_j) \over V^\prime(\Gamma_j) }.
\end{equation}
Noting that
\begin{equation}
  \label{eq:21}
  V^\prime(\Gamma_j) = \left. { \mathrm d V \over \mathrm d \Gamma } \right|_j = 2\left( \Gamma_j + a \right),
\end{equation}
Eq.~(\ref{eq:20}) becomes
\begin{equation}
  \label{eq:22}
  \Gamma_{j+1} = { \Gamma_j^2 - b \over 2(\Gamma_j + a) }.
\end{equation}
with
\begin{equation}
  \label{eq:23}
  \Gamma_1 = {-b \over 2a }.
\end{equation}

<<refraction>>=
void refract(bundle *rays, const rtd mu)
{
  dim3 blockDim(16,16);
  dim3 gridDim(rays->N_RAY/256+1,1);
  refract_kernel LLL gridDim , blockDim RRR (rays->d__ray, rays->N_RAY, mu);
}
@ 
<<refraction kernel>>=
__global__ void refract_kernel(ray *d__ray, int N_RAY, const rtd mu)
{
  int i, j, ij;
  rtd k, l, m, K, L ,M, G2, a, b, gamma0, gamma1, gamma_relative_error;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  ij = j * gridDim.x * blockDim.x + i;
  if ( (ij<N_RAY) && (d__ray[ij].v) )
  {
    <<a equation>>
    <<b equation>>
    gamma0 = -0.5*b/a;
    for (j=0; j<N_ITERATION; j++)
    {
      gamma1 = 0.5*(gamma0*gamma0-b)/(gamma0+a);
      gamma_relative_error = abs( gamma1/gamma0 - 1.0 );
      if (gamma_relative_error<0.01)
      {
        d__ray[ij].directions.x = mu*k + gamma1*K;
        d__ray[ij].directions.y = mu*l + gamma1*L;
        d__ray[ij].directions.z = mu*m + gamma1*M;
        return;
      }
      gamma0 = gamma1;
    }
  }
}
@
\subsubsection{Reflection}
\label{sec:reflection}

In the case of reflection, one have $\mu=1$, $b=0$ and
\begin{equation}
  \label{eq:24}
  \Gamma = -2a.
\end{equation}
Eq.~(\ref{eq:14}) thus becomes
\begin{equation}
  \label{eq:25}
    \vec \Sp = \vec S -2a \vec r.
\end{equation}
<<reflection>>=
void reflect(bundle *rays)
{
  dim3 blockDim(16,16);
  dim3 gridDim(rays->N_RAY/256+1,1);
  reflect_kernel LLL gridDim , blockDim RRR (rays->d__ray, rays->N_RAY, 1.0);
}
@ 
Setting $\mu=-1$ makes the mirror behaving like a thin lens:
<<thin lens>>=
void thin_lens(bundle *rays)
{
  dim3 blockDim(16,16);
  dim3 gridDim(rays->N_RAY/256+1,1);
  reflect_kernel LLL gridDim , blockDim RRR (rays->d__ray, rays->N_RAY, -1.0);
}
@ 
<<reflection kernel>>=
    __global__ void reflect_kernel(ray *d__ray, int N_RAY, float mu)
{
  int i, j, ij;
  rtd k, l, m, K, L ,M, G2, a;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  ij = j * gridDim.x * blockDim.x + i;
  if ( (ij<N_RAY) && (d__ray[ij].v) )
  {
    <<a equation>>
    a *= -2.0;
    d__ray[ij].directions.x = mu*k + a*K;
    d__ray[ij].directions.y = mu*l + a*L;
    d__ray[ij].directions.z = mu*m + a*M;
  }
}
@
\subsection{Input/Output}
\label{sec:inputoutput}

\section{Tests}
\label{sec:tests}

