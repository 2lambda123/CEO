% -*- mode: Noweb; noweb-code-mode: c-mode -*-

The ray tracing method involves 4 steps \cite{}:
\begin{enumerate}
\item the ray coordinates are transformed into the coordinate system of the surface their interact with,
\item the intersection of the ray with the surface is found,
\item the directions of the ray after the surface is computed according to Snell''s law,
\item the coordinates and directions of the ray is transformed back into its original coordinate systems
\end{enumerate}

\section{The files}
\label{sec:files}

\subsection{Header}
\label{sec:header}

<<rayTracing.h>>=
#ifndef __RAYTRACING_H__
#define __RAYTRACING_H__

#ifndef __SOURCE_H__
#include "source.h"
#endif

#define N_ITERATION 100
#define TOL 50E-8

<<ray tracing data type>>

<<vector data type>>

<<ray data type>>

<<coordinate system data type>>

<<ray bundle structure>>

<<conic structure>>

<<conic equations>>

<<aperture structure>>

<<GMT M1 structure>>
<<GMT M2 structure>>

__host__ __device__  void forward_transform(vector *v_out, vector *v_in,
				   rtd *d__R, vector *d__origin);
__host__ __device__  void forward_transform_centered(vector *v_out, vector *v_in,
					    rtd *d__R);
__host__ __device__  void backward_transform(vector *v_out, vector *v_in,
                                    rtd *d__R, vector *d__origin);
__host__ __device__  void backward_transform_centered(vector *v_out, vector *v_in,
					     rtd *d__R);


void transform_to_S(bundle *rays, conic *F);
void transform_to_S(bundle *rays, aperture *A);
void transform_to_R(bundle *rays, conic *F);
void transform_to_R(bundle *rays, aperture *A);
void intersect(bundle *rays, conic *F);
void refract(bundle *rays, const rtd mu);
void reflect(bundle *rays);
void thin_lens(bundle *rays);

#endif // __RAYTRACING_H__
@ 
\subsection{Source}
\label{sec:source}

<<rayTracing.cu>>=
#include "rayTracing.h"

<<vector functions>>
<<coordinates forward transform>>
<<coordinates backward transform>>

<<bundle coordinates kernel>>
<<bundle coordinates kernel (box)>>
<<gathering ray coordinates kernel>>
<<gathering ray directions kernel>>
<<gathering ray optical path length kernel>>
<<gathering ray vignetting map kernel>>
<<bundle reset kernel>>
<<GMT ray tracing kernel>>
<<GMT blocking kernel>>
<<GMT aperture intersection>>

<<ray bundle setup>>
<<ray bundle setup (box)>>
<<ray bundle cleanup>>
<<gathering ray coordinates>>
<<gathering ray directions>>
<<gathering ray optical path length>>
<<gathering ray vignetting map>>
<<bundle reset>>

<<coordinate system functions>>

<<conic functions>>

<<vignetting kernel>>
<<aperture functions>>

<<GMT M1 functions>>
<<GMT M2 functions>>

<<transformation to surface system kernel>>
<<transformation to rays system kernel>>

<<transformation to surface system>>
<<transformation to rays system>>

<<intersection with surface kernel>>
<<intersection with surface>>

<<refraction kernel>>
<<refraction>>

<<reflection kernel>>
<<reflection>>
<<thin lens>>

@ 
\subsection{Python}
\label{sec:python}

<<ceo.pxd>>=
cdef extern from "rayTracing.h":
    ctypedef double rtd
    ctypedef struct vector:
        rtd x
        rtd y
        rtd z
    ctypedef struct ray:
        vector coordinates
        vector directions
        vector surface_normal
        rtd optical_path_length
    ctypedef struct coordinate_system:
        float *float_R        
    cdef cppclass bundle:
        int N_RAY
        ray *d__ray
        void setup(source *, rtd , int , int , vector )
        void setup(source *, rtd , int , vector )
        void cleanup()
        void get_coordinates(double *)
        void get_directions(double *)
        void get_optical_path_length(double *)
        void get_vignetting(double *)
	void reset()
    cdef cppclass conic:
        coordinate_system ref_frame
        void setup(rtd , rtd , vector , vector , vector)
        void cleanup()
    cdef cppclass aperture:
        coordinate_system ref_frame
        void setup(float, float, int, vector , vector) 
        void setup_GMT_M1(float, int)
        void cleanup()
        void vignetting(bundle *)
    cdef cppclass gmt_m1:
        coordinate_system aperture_CS
        coordinate_system conic_CS
        coordinate_system rigid_body_CS
        coordinate_system motion_CS
        void setup(float , int )
        void cleanup()
        void update(vector , vector ,int )
        void trace(bundle *)
        void blocking(bundle *)
        void test_ray_tracing()
    cdef cppclass gmt_m2:
        coordinate_system aperture_CS
        coordinate_system conic_CS
        coordinate_system rigid_body_CS
        coordinate_system motion_CS
        void setup(float , int )
        void cleanup()
        void update(vector , vector ,int )
        void trace(bundle *)
        void blocking(bundle *)
    void transform_to_S(bundle *, conic *)
    void transform_to_S(bundle *, aperture *)
    void transform_to_R(bundle *, conic *)
    void transform_to_R(bundle *, aperture *)
    void intersect(bundle *, conic *)
    void reflect(bundle *)
    void thin_lens(bundle *)
@ 
<<ceo.pyx>>=
# polar bundle
cdef class Bundle:
    """
    """
    cdef ceo.bundle *_c_bundle

    def __cinit__(self, Source src, rtd RADIUS, int N_RADIUS, int N_THETA=0,
                  _origin_=[0.0,0.0,0.0], type="polar"):
        self._c_bundle = new ceo.bundle()
        cdef vector origin
        origin.x = <float>_origin_[0]
        origin.y = <float>_origin_[1]
        origin.z = <float>_origin_[2]
        if type=="box":
            self._c_bundle.setup(src._c_source, RADIUS, N_RADIUS, origin)
        else:
            self._c_bundle.setup(src._c_source, RADIUS, N_RADIUS, N_THETA, origin)

    <<bundle common>>
@ 
<<bundle common>>=
def __dealloc__(self):
    self._c_bundle.cleanup()

def reset(self):
    self._c_bundle.reset()

property coordinates:
    def __get__(self):
        x = cuDoubleArray(shape=(self._c_bundle.N_RAY,3),dev_malloc=True)
        self._c_bundle.get_coordinates(x._c_gpu.dev_data)
        return x

property directions:
    def __get__(self):
        x = cuDoubleArray(shape=(self._c_bundle.N_RAY,3),dev_malloc=True)
        self._c_bundle.get_directions(x._c_gpu.dev_data)
        return x

property optical_path_length:
        def __get__(self):
            x = cuDoubleArray(shape=(self._c_bundle.N_RAY,1),dev_malloc=True)
            self._c_bundle.get_optical_path_length(x._c_gpu.dev_data)
            return x

property vignetting:
        def __get__(self):
            x = cuDoubleArray(shape=(self._c_bundle.N_RAY,1),dev_malloc=True)
            self._c_bundle.get_vignetting(x._c_gpu.dev_data)
            return x
<<ceo.pyx>>=
# conic
cdef class Conic:
    """
    """
    cdef ceo.conic *_c_conic
    cdef public np.ndarray R

    def __cinit__(self,rtd c, rtd k, 
                  origin=[0.0,0.0,0.0], euler_angles=[0.0,0.0,0.0],
                  conic_origin=[0.0,0.0,0.0]):
        self._c_conic = new ceo.conic()
        self.R = np.zeros((3,3),order='c',dtype=np.float32)
        cdef vector __origin
        __origin.x = <float>origin[0]
        __origin.y = <float>origin[1]
        __origin.z = <float>origin[2]
        cdef vector __euler_angles
        __euler_angles.x = <float>euler_angles[0]
        __euler_angles.y = <float>euler_angles[1]
        __euler_angles.z = <float>euler_angles[2]
        cdef vector __conic_origin
        __conic_origin.x = <float>conic_origin[0]
        __conic_origin.y = <float>conic_origin[1]
        __conic_origin.z = <float>conic_origin[2]
        self._c_conic.ref_frame.float_R = <float *> self.R.data;
        self._c_conic.setup(c, k, __origin, __euler_angles, __conic_origin)

    def __dealloc__(self):
        self._c_conic.cleanup()
# aperture
cdef class Aperture:
    """
    """
    cdef ceo.aperture *_c_aperture
    cdef public np.ndarray R
    
    def __cinit__(self, float D, float ri, int D_px, origin=[0.0,0.0,0.0], euler_angles=[0.0,0.0,0.0]):
        self._c_aperture = new ceo.aperture()
        self.R = np.zeros((3,3),order='c',dtype=np.float32)
        cdef vector __origin
        __origin.x = <float>origin[0]
        __origin.y = <float>origin[1]
        __origin.z = <float>origin[2]
        cdef vector __euler_angles
        __euler_angles.x = <float>euler_angles[0]
        __euler_angles.y = <float>euler_angles[1]
        __euler_angles.z = <float>euler_angles[2]
        self._c_aperture.ref_frame.float_R = <float *> self.R.data;
        self._c_aperture.setup(D, ri, D_px, __origin, __euler_angles)

    def __dealloc__(self):
        self._c_aperture.cleanup()

    def vignetting(self, Bundle rays):
        self._c_aperture.vignetting(rays._c_bundle)
# GMT M1
cdef class GMT_M1:
    """
    """
    cdef ceo.gmt_m1 *_c_gmt_m1
    cdef public np.ndarray aperture_R, conic_R, rigid_body_R, motion_R
    
    def __cinit__(self, float D, int D_px):
        self._c_gmt_m1 = new ceo.gmt_m1()
        
        # aperture
        self.aperture_R = np.zeros((3*7,3),order='c',dtype=np.float32)
        self._c_gmt_m1.aperture_CS.float_R = <float *> self.aperture_R.data;
        # conic
        self.conic_R = np.zeros((3*7,3),order='c',dtype=np.float32)
        self._c_gmt_m1.conic_CS.float_R = <float *> self.conic_R.data;
        # rigid body
        self.rigid_body_R = np.zeros((3*7,3),order='c',dtype=np.float32)
        self._c_gmt_m1.rigid_body_CS.float_R = <float *> self.rigid_body_R.data;
        # motion
        self.motion_R = np.zeros((3*7,3),order='c',dtype=np.float32)
        self._c_gmt_m1.motion_CS.float_R = <float *> self.motion_R.data;

        self._c_gmt_m1.setup(D, D_px)

    def __dealloc__(self):
        self._c_gmt_m1.cleanup()

    def trace(self, Bundle rays):
        self._c_gmt_m1.trace(rays._c_bundle)

    def test(self):
        self._c_gmt_m1.test_ray_tracing();

    def blocking(self, Bundle rays):
        self._c_gmt_m1.blocking(rays._c_bundle)

    def update(self, origin=[0.0,0.0,0.0], euler_angles=[0.0,0.0,0.0], int idx=0):
        cdef vector __origin
        __origin.x = <float>origin[0]
        __origin.y = <float>origin[1]
        __origin.z = <float>origin[2]
        cdef vector __euler_angles
        __euler_angles.x = <float>euler_angles[0]
        __euler_angles.y = <float>euler_angles[1]
        __euler_angles.z = <float>euler_angles[2]
        self._c_gmt_m1.update(__origin, __euler_angles, idx)
# GMT M2
cdef class GMT_M2:
    """
    """
    cdef ceo.gmt_m2 *_c_gmt_m2
    cdef public np.ndarray aperture_R, conic_R, rigid_body_R, motion_R
    
    def __cinit__(self, float D, int D_px):
        self._c_gmt_m2 = new ceo.gmt_m2()
        
        # aperture
        self.aperture_R = np.zeros((3*7,3),order='c',dtype=np.float32)
        self._c_gmt_m2.aperture_CS.float_R = <float *> self.aperture_R.data;
        # conic
        self.conic_R = np.zeros((3*7,3),order='c',dtype=np.float32)
        self._c_gmt_m2.conic_CS.float_R = <float *> self.conic_R.data;
        # rigid body
        self.rigid_body_R = np.zeros((3*7,3),order='c',dtype=np.float32)
        self._c_gmt_m2.rigid_body_CS.float_R = <float *> self.rigid_body_R.data;
        # motion
        self.motion_R = np.zeros((3*7,3),order='c',dtype=np.float32)
        self._c_gmt_m2.motion_CS.float_R = <float *> self.motion_R.data;

        self._c_gmt_m2.setup(D, D_px)

    def __dealloc__(self):
        self._c_gmt_m2.cleanup()

    def trace(self, Bundle rays):
        self._c_gmt_m2.trace(rays._c_bundle)

    def blocking(self, Bundle rays):
        self._c_gmt_m2.blocking(rays._c_bundle)

    def update(self, origin=[0.0,0.0,0.0], euler_angles=[0.0,0.0,0.0], int idx=0):
        cdef vector __origin
        __origin.x = <float>origin[0]
        __origin.y = <float>origin[1]
        __origin.z = <float>origin[2]
        cdef vector __euler_angles
        __euler_angles.x = <float>euler_angles[0]
        __euler_angles.y = <float>euler_angles[1]
        __euler_angles.z = <float>euler_angles[2]
        self._c_gmt_m2.update(__origin, __euler_angles, idx)
# ray tracing
def Transform_to_S(Bundle rays, Conic F):
    transform_to_S(rays._c_bundle, F._c_conic)
def Transform_to_S_from_A(Bundle rays, Aperture A):
    transform_to_S(rays._c_bundle, A._c_aperture)
def Transform_to_R(Bundle rays, Conic F):
    transform_to_R(rays._c_bundle, F._c_conic)
def Transform_to_R_from_A(Bundle rays, Aperture A):
    transform_to_R(rays._c_bundle, A._c_aperture)
def Intersect(Bundle rays, Conic F):
    intersect(rays._c_bundle, F._c_conic)
def Reflect(Bundle rays):
    reflect(rays._c_bundle)
def ThinLens(Bundle rays):
    thin_lens(rays._c_bundle)

@ 
\section{Custom types}
\label{sec:custom-types}

The accuracy of the ray tracing is partly depending upon the data type used to hold data values of rays and surfaces.
GPU are faster in single precision than in double precision but double precision may still be required for accuracy.
So lets defined a ray tracing type:
<<ray tracing data type>>=
typedef double rtd;
@ 
A new vector data type is defined 
<<vector data type>>=
typedef struct {
  rtd x;
  rtd y;
  rtd z;
  __host__ __device__ rtd rho2(void);
  __host__ __device__ rtd rho2(rtd x0, rtd y0);
} vector;
@ that represents the 3 coordinates in space of the tip of vector.
The square of the magnitude of a vector projected in the x,y--plane i.e. $[[x]]^2+[[y]]^2$ is computed with 
<<vector functions>>=
__host__ __device__ rtd vector::rho2(void) {
  return x*x + y*y;
}
@ Vector radius square:
<<vector functions>>=
__host__ __device__ rtd vector::rho2(rtd x0, rtd y0) {
  rtd xp, yp;
  xp = x - x0;
  yp = y - y0;
  return xp*xp + yp*yp;
}
@

\section{Ray}
\label{sec:ray}

A type for the rays is also defined:
<<ray data type>>=
typedef struct {
  <<ray data>>
} ray;
@ 
It contains the ray coordinates:
<<ray data>>=
vector coordinates;
@ 
the direction cosines of the ray:
<<ray data>>=
vector directions;
@ 
the [[surface_normal]] at the surface it intersected with the last time:
<<ray data>>=
vector surface_normal;
@ 
the optical path length:
<<ray data>>=
rtd optical_path_length;
@ the vignetting flag [[v]], $[[v]]=0$ means the ray is vignetted:
<<ray data>>=
char v;
@ and the number of iterative steps for the Raphson--Newton method:
<<ray data>>=
int n_iteration;

@
\section{Ray bundle}
\label{sec:ray-bundle}

Collections of rays are gathered into bundles:
<<ray bundle structure>>=
struct bundle {
  <<ray bundle parameters>>
  void setup(source *src, rtd RADIUS, int N_RADIUS, int N_THETA, vector origin);
  void setup(source *src, rtd L, int N_L, vector origin);
  void cleanup(void);
  void get_coordinates(double *d__coord);
  void get_directions(double *d__dir);
  void get_optical_path_length(double *d__opl);
  void get_vignetting(double *d__v);
  void reset(void);
};
@ 
A bundle allocates an array of [[N_RAY]] rays on the device
<<ray bundle parameters>>=
int N_RAY;
ray *d__ray;
vector *d__origin;
@
\subsection{Setup \& Cleanup}
\label{sec:bundle-setup--cleanup}

A ray bundle is specified with either the polar or cartesian coordinates of the rays at a given origin.
The direction cosine are derived from the coordinates of a source object.

The polar coordinates are defined with the sampling of the radius [[N_RADIUS]] from 0 to [[RADIUS]] and with the sampling of the azimuth [[N_THETA]].
<<ray bundle setup>>=
void bundle::setup(source *src, rtd RADIUS, int N_RADIUS, 
		   int N_THETA, vector origin)
{
  N_RAY = (N_RADIUS-1)*N_THETA + 1;
  HANDLE_ERROR( cudaMalloc((void**)&d__ray, sizeof(ray)*N_RAY ) );
  HANDLE_ERROR( cudaMalloc((void**)&d__origin, sizeof(vector) ) );
  HANDLE_ERROR( cudaMemcpy( d__origin, &origin, 
			    sizeof(vector), cudaMemcpyHostToDevice ) );
  <<bundle coordinates>>
}
@ 
The direction cosines $(k,l,m)$ of the rays are defined from the source zenith $\zeta$ and azimuth $\xi$ angles as
\begin{eqnarray}
  \label{eq:2}
  k &=& \sin(\zeta)\cos(\xi) \\
  l &=& \sin(\zeta)\sin(\xi) \\
  k &=& \cos(\zeta)
\end{eqnarray}
The polar coordinates $\rho$ and $\theta$ of the rays are given by
\begin{equation}
  \rho = [[RADIUS]] {k \over [[N_RADIUS]] - 1 } \forall k \in [0,[[N_RADIUS]] - 1]
\end{equation}
and
\begin{equation}
  \theta = 2\pi {k \over [[N_THETA]] } \forall k \in [0,[[N_THETA-1]]]
\end{equation}
<<bundle coordinates>>=
dim3 blockDim(16,16);
dim3 gridDim(N_RADIUS/16+1,N_THETA/16+1);
ray_coordinates LLL gridDim , blockDim, src->N_SRC RRR (d__ray, N_RAY, src->dev_ptr,
                                            RADIUS, N_RADIUS, N_THETA, d__origin);
@ 
<<bundle coordinates kernel>>=
__global__ void ray_coordinates(ray *d__ray, int N_RAY, source *src,
                            rtd RADIUS, int N_RADIUS, int N_THETA, vector *origin)
{
  int i, j, k, iSource;
  rtd rho, theta;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  iSource = blockIdx.z;
  //k = j * gridDim.x * blockDim.x + i;
  if ( (i<N_RADIUS) && (j<N_THETA) )
  {
    rho   = RADIUS*i/(N_RADIUS-1);
    if (i==0) {
      j = 0;
      k = 0;
    } else
      k = j + (i - 1)*N_THETA + 1;
    theta = 2*PI*j/N_THETA; 
    d__ray[k].coordinates.x = rho*cos(theta) + origin->x; 
    d__ray[k].coordinates.y = rho*sin(theta) + origin->y; 
    d__ray[k].coordinates.z = origin->z;
    d__ray[k].directions.x  = sin(src[iSource].zenith)*cos(src[iSource].azimuth);
    d__ray[k].directions.y  = sin(src[iSource].zenith)*sin(src[iSource].azimuth);
    d__ray[k].directions.z  = cos(src[iSource].zenith);
    d__ray[k].optical_path_length = 0.0;
    d__ray[k].coordinates.x -= d__ray[k].coordinates.z*d__ray[k].directions.x;
    d__ray[k].coordinates.y -= d__ray[k].coordinates.z*d__ray[k].directions.y;
    d__ray[k].v = 1;
  }
}
@ 

The cartesian coordinates are defined with the sampling of the square box length [[N_L]] from $-[[L]]$ to [[L]].
<<ray bundle setup (box)>>=
void bundle::setup(source *src, rtd L, int N_L, vector origin)
{
  N_RAY = N_L*N_L;
  HANDLE_ERROR( cudaMalloc((void**)&d__ray, sizeof(ray)*N_RAY ) );
  HANDLE_ERROR( cudaMalloc((void**)&d__origin, sizeof(vector) ) );
  HANDLE_ERROR( cudaMemcpy( d__origin, &origin, 
			    sizeof(vector), cudaMemcpyHostToDevice ) );
  <<bundle coordinates (box)>>
}
@ 
The direction cosines $(k,l,m)$ of the rays are defined from the source zenith $\zeta$ and azimuth $\xi$ angles as
\begin{eqnarray}
  \label{eq:2}
  k &=& \sin(\zeta)\cos(\xi) \\
  l &=& \sin(\zeta)\sin(\xi) \\
  k &=& \cos(\zeta)
\end{eqnarray}
The cartesian coordinates $x$ and $y$ of the rays are given by
\begin{eqnarray}
  x &=& L*(i-([[N_L]]-1)/2)/([[N_L]]-1) \\
  y &=& L*(j-([[N_L]]-1)/2)/([[N_L]]-1)
\end{eqnarray}
<<bundle coordinates (box)>>=
dim3 blockDim(16,16);
dim3 gridDim(N_L/16+1,N_L/16+1);
ray_coordinates_box LLL gridDim , blockDim, src->N_SRC RRR (d__ray, N_RAY, src->dev_ptr,
                                                            L, N_L, d__origin);
@ 
<<bundle coordinates kernel (box)>>=
__global__ void ray_coordinates_box(ray *d__ray, int N_RAY, source *src,
                                    rtd L, int N_L, vector *origin)
{
  int i, j, k, iSource;
  rtd x, y;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  iSource = blockIdx.z;
  if ( (i<N_L) && (j<N_L) )
  {
    x   = L*(i - (N_L-1)*0.5)/(N_L-1);
    y   = L*(j - (N_L-1)*0.5)/(N_L-1);
    k = i + j*N_L;
    d__ray[k].coordinates.x = x + origin->x; 
    d__ray[k].coordinates.y = y + origin->y; 
    d__ray[k].coordinates.z = origin->z;
    d__ray[k].directions.x  = sin(src[iSource].zenith)*cos(src[iSource].azimuth);
    d__ray[k].directions.y  = sin(src[iSource].zenith)*sin(src[iSource].azimuth);
    d__ray[k].directions.z  = cos(src[iSource].zenith);
    d__ray[k].optical_path_length = 0.0;
    d__ray[k].coordinates.x -= d__ray[k].coordinates.z*d__ray[k].directions.x;
    d__ray[k].coordinates.y -= d__ray[k].coordinates.z*d__ray[k].directions.y;
    d__ray[k].v = 1;
  }
}
@
Memory is freed with
<<ray bundle cleanup>>=
void bundle::cleanup(void) 
{
  fprintf(stdout,"@(CEO)>bundle: freeing memory!\n");
  HANDLE_ERROR( cudaFree( d__ray ) );
  HANDLE_ERROR( cudaFree( d__origin ) );
}
@ 
<<gathering ray coordinates>>=
void bundle::get_coordinates(double *d__coord)
{
  dim3 blockDim(16,16);
  dim3 gridDim(N_RAY/256+1,1);
  get_coordinates_kernel LLL gridDim , blockDim RRR (d__coord, d__ray, N_RAY);
}
@ 
<<gathering ray coordinates kernel>>=
__global__ void get_coordinates_kernel(double *d__coord, ray *d__ray, int N_RAY)
{
  int i, j, k;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  k = j * gridDim.x * blockDim.x + i;
  if ( k<N_RAY )
  {
    d__coord[3*k]   = d__ray[k].coordinates.x;
    d__coord[3*k+1] = d__ray[k].coordinates.y;
    d__coord[3*k+2] = d__ray[k].coordinates.z;
  }
}
@ 
<<gathering ray directions>>=
void bundle::get_directions(double *d__dir)
{
  dim3 blockDim(16,16);
  dim3 gridDim(N_RAY/256+1,1);
  get_directions_kernel LLL gridDim , blockDim RRR (d__dir, d__ray, N_RAY);
}
@ 
<<gathering ray directions kernel>>=
__global__ void get_directions_kernel(double *d__dir, ray *d__ray, int N_RAY)
{
  int i, j, k;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  k = j * gridDim.x * blockDim.x + i;
  if ( k<N_RAY )
  {
    d__dir[3*k]   = d__ray[k].directions.x;
    d__dir[3*k+1] = d__ray[k].directions.y;
    d__dir[3*k+2] = d__ray[k].directions.z;
  }
}
@ 
<<gathering ray optical path length>>=
void bundle::get_optical_path_length(double *d__opl)
{
  dim3 blockDim(16,16);
  dim3 gridDim(N_RAY/256+1,1);
  get_optical_path_length_kernel LLL gridDim , blockDim RRR (d__opl, d__ray, N_RAY);
}
@ 
<<gathering ray optical path length kernel>>=
__global__ void get_optical_path_length_kernel(double *d__opl, ray *d__ray, int N_RAY)
{
  int i, j, k;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  k = j * gridDim.x * blockDim.x + i;
  if ( k<N_RAY )
    d__opl[k]   = d__ray[k].optical_path_length;
}
@ 
<<gathering ray vignetting map>>=
void bundle::get_vignetting(double *d__v)
{
  dim3 blockDim(16,16);
  dim3 gridDim(N_RAY/256+1,1);
  get_vignetting_kernel LLL gridDim , blockDim RRR (d__v, d__ray, N_RAY);
}
@ 
<<gathering ray vignetting map kernel>>=
__global__ void get_vignetting_kernel(double *d__v, ray *d__ray, int N_RAY)
{
  int i, j, k;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  k = j * gridDim.x * blockDim.x + i;
  if ( k<N_RAY )
    d__v[k]   = (d__ray[k].v) ? 1.0 : 0.0;
}
@ 
The ray vignetting is reset with
<<bundle reset>>=
void bundle::reset(void) 
{
  dim3 blockDim(16,16);
  dim3 gridDim(N_RAY/256+1,1);  
  reset_kernel LLL gridDim , blockDim RRR (d__ray, N_RAY);
}
@ with 
<<bundle reset kernel>>=
__global__ void reset_kernel(ray *d__ray, int N_RAY)
{
  int i, j, k;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  k = j * gridDim.x * blockDim.x + i;
  if ( k<N_RAY )
    d__ray[k].v = 0;
}
@

\section{Coordinate system}
\label{sec:coordinate-system}

The surface location and orientation with respect to the GCS is specified with a coordinate vector:
<<coordinate system data>>=
vector *origin;
@ and with 3 Euler angles with respected to the x, y and z axis.
<<coordinate system data>>=
vector *euler_angles;
@ The surface can be made of [[N]] identical segments
<<coordinate system data>>=
int N; 
@
The rotation matrix [[R]] used to transform the ray coordinates into the surface coordinates (and back!) is defined with
<<coordinate system data>>=
rtd *R, *d__R;
float *float_R;
vector *d__origin;
@ 
Coordinate systems can be tagged:
<<coordinate system data>>=
char tag[16];
@ 
They are gathered in a new coordinate system data type
<<coordinate system data type>>=
typedef struct {
  <<coordinate system data>>
  void setup(void);
  void setup(vector _origin_, vector _euler_angles_);
  void setup(vector *_origin_, vector *_euler_angles_, int _N_);
  void setup(vector *_origin_, vector *_euler_angles_, int _N_, char *_tag_);
  void cleanup(void);
  void info(void);
  void update(vector _origin_, vector _euler_angles_,int idx);
} coordinate_system;
@ 

\subsection{Setup \& Cleanup}
\label{sec:setup--cleanup}

A coordinate system structure is initialized with
\begin{itemize}
\item a single origin and orientation,
<<coordinate system functions>>=
void coordinate_system::setup(vector _origin_, vector _euler_angles_)
{
  N = 1;
  HANDLE_ERROR( cudaMalloc((void**)&d__R, sizeof(rtd)*9*N ) );
  HANDLE_ERROR( cudaMalloc((void**)&d__origin, sizeof(vector)*N ) );
  int n_byte = sizeof(vector)*N;
  origin = (vector *)malloc( n_byte );
  euler_angles = (vector *)malloc( n_byte );
  memcpy( origin , &_origin_ , n_byte);
  memcpy(euler_angles,  &_euler_angles_, n_byte);
  <<rotation matrix eval>>
  strcpy(tag,"coordinate_system");
  info();
}
@ 
\item origin and orientation align to the main coordinate system,
<<coordinate system functions>>=
void coordinate_system::setup(void)
{
  N = 1;
  HANDLE_ERROR( cudaMalloc((void**)&d__R, sizeof(rtd)*9*N ) );
  HANDLE_ERROR( cudaMalloc((void**)&d__origin, sizeof(vector)*N ) );
  int n_byte = sizeof(vector)*N;
  origin = (vector *)malloc( n_byte );
  euler_angles = (vector *)malloc( n_byte );
  origin[0].x = 0;
  origin[0].y = 0;
  origin[0].z = 0;
  euler_angles[0].x = 0;
  euler_angles[0].y = 0;
  euler_angles[0].z = 0;
  <<rotation matrix eval>>
  strcpy(tag,"coordinate_system");
  info();
}
@ 
\item an array of [[N]] origins and orientations:
  \begin{itemize}
  \item without a tag:
<<coordinate system functions>>=
void coordinate_system::setup(vector *_origin_, vector *_euler_angles_, int _N_)
{
  strcpy(tag,"coordinate_system");
  <<coordinate system setup common>>
}
@
\item or with a tag:
<<coordinate system functions>>=
void coordinate_system::setup(vector *_origin_, vector *_euler_angles_, 
                              int _N_, char *_tag_)
{
  strcpy(tag,_tag_);
  <<coordinate system setup common>>
}
@  
\end{itemize}
where 
<<coordinate system setup common>>=
N = _N_;
HANDLE_ERROR( cudaMalloc((void**)&d__R, sizeof(rtd)*9*N ) );
HANDLE_ERROR( cudaMalloc((void**)&d__origin, sizeof(vector)*N ) );
int n_byte = sizeof(vector)*N;
origin = (vector *)malloc( n_byte );
euler_angles = (vector *)malloc( n_byte );
memcpy( origin , _origin_ , n_byte);
memcpy(euler_angles,  _euler_angles_, n_byte);
<<rotation matrix eval>>
info();
@ 
\end{itemize}

The rotation matrix to transform the ray coordinates in the LCS is given by
\begin{eqnarray}
R &=& \left[ 
  \begin{array}{ccc}
    c\gamma & -s\gamma & 0 \\
    s\gamma &  c\gamma & 0 \\
    0       &  0       & 1
  \end{array}
  \right] \left[
  \begin{array}{ccc}
    c\beta & 0 & -s\beta \\
    0      & 1 &  0 \\
    s\beta & 0 &  c\beta
  \end{array}
  \right] \left[
    \begin{array}{ccc}
      1       &  0       & 0 \\
      0       &  c\alpha & -s\alpha \\
      0       &  s\alpha &  c\alpha 
    \end{array}
\right] \\
&=& \left[
  \begin{array}{ccc}
    c\beta c\gamma &  s\alpha s\beta s\gamma + s\alpha s\gamma & -c\alpha s\beta c\gamma + s\alpha s\gamma \\
    c\beta s\gamma & -s\alpha s\beta s\gamma + c\alpha c\gamma & -c\alpha s\beta s\gamma - s\alpha c\gamma \\
    s\beta         &  s\alpha c\beta                           &  c\alpha c\beta
  \end{array}
\right]
\end{eqnarray}
@ where $cx$ and $sx$ stands for $\sin(x)$ and $\cos(x)$, respectively.
$\alpha$, $\beta$ and $\gamma$ are the Euler angles along the x, y and z axis respectively.
The matrix is computed with
<<rotation matrix eval>>=
R = (rtd *)malloc( sizeof(rtd)*9*N );
rtd ca, sa, cb, sb, cg, sg;
int k, idx;
for (k=0; k<N; k++)
  {
    idx = k;
    ca = cos(euler_angles[idx].x);
    sa = sin(euler_angles[idx].x);
    cb = cos(euler_angles[idx].y);
    sb = sin(euler_angles[idx].y);
    cg = cos(euler_angles[idx].z);
    sg = sin(euler_angles[idx].z);
    idx *= 9;
    R[idx++] = cb*cg;
    R[idx++] = -sa*sb*cg - ca*sg;
    R[idx++] = -ca*sb*cg + sa*sg;
    R[idx++] = cb*sg;
    R[idx++] = -sa*sb*sg + ca*cg;
    R[idx++] = -ca*sb*sg - sa*cg;
    R[idx++] = sb;
    R[idx++] = sa*cb;
    R[idx++] = ca*cb;
  }
HANDLE_ERROR( cudaMemcpy( d__R, R, 
			    sizeof(rtd)*9*N, cudaMemcpyHostToDevice ) );
HANDLE_ERROR( cudaMemcpy( d__origin, origin, 
			    sizeof(vector)*N, cudaMemcpyHostToDevice ) );
for (k=0;k<9*N;k++)
   *(float_R+k) = (float) R[k];
@ where the elements of $R$ are stored in the row major format.
<<coordinate system functions>>=
void coordinate_system::cleanup(void)
{
  fprintf(stdout,"@(CEO)>coordinate_system: freeing memory!\n");
  free( origin );
  free( euler_angles );
  free(R);
  HANDLE_ERROR( cudaFree( d__R ) );
  HANDLE_ERROR( cudaFree( d__origin ) );
}
@ 
The coordinate system is updated with
<<coordinate system functions>>=
void coordinate_system::update(vector _origin_, vector _euler_angles_,int idx)
{
  int n_byte = sizeof(vector);
  memcpy( origin + idx , &_origin_ , n_byte);
  memcpy(euler_angles + idx,  &_euler_angles_, n_byte);
  rtd ca, sa, cb, sb, cg, sg;
  ca = cos(euler_angles[idx].x);
  sa = sin(euler_angles[idx].x);
  cb = cos(euler_angles[idx].y);
  sb = sin(euler_angles[idx].y);
  cg = cos(euler_angles[idx].z);
  sg = sin(euler_angles[idx].z);
  idx *= 9;
  R[idx++] = cb*cg;
  R[idx++] = -sa*sb*cg - ca*sg;
  R[idx++] = -ca*sb*cg + sa*sg;
  R[idx++] = cb*sg;
  R[idx++] = -sa*sb*sg + ca*cg;
  R[idx++] = -ca*sb*sg - sa*cg;
  R[idx++] = sb;
  R[idx++] = sa*cb;
  R[idx++] = ca*cb;
  HANDLE_ERROR( cudaMemcpy( d__R, R, 
			    sizeof(rtd)*9*N, cudaMemcpyHostToDevice ) );
  HANDLE_ERROR( cudaMemcpy( d__origin, origin, 
			    sizeof(vector)*N, cudaMemcpyHostToDevice ) );
  for (int k=0;k<9*N;k++)
    *(float_R+k) = (float) R[k];
}
@ 
\subsection{Input/Output}
\label{sec:inputoutput}

The main parameters of the coordinate systems are displayed with the [[info]] routine:
<<coordinate system functions>>=
void coordinate_system::info(void)
{
  fprintf(stdout,"\n\x1B[1;42m@(CEO)>%s:\x1B[;42m\n",tag);
  fprintf(stdout," ID (Tx          Ty        Tz)[m]  (Ox         Oy         Oz)[deg]\n");
  float c = 180.0/PI;
  int k;
  for (k=0; k<N; k++)
     fprintf(stdout," %2d %+6.2e %+6.2e %+6.2e   %+6.2e %+6.2e %+6.2e\n", k,
	  origin[k].x, origin[k].y, origin[k].z,
	  euler_angles[k].x*c, euler_angles[k].y*c, euler_angles[k].z*c);
  fprintf(stdout,"----------------------------------------------------\x1B[0m\n");
}
@ 

\section{Surface}
\label{sec:surface}

A conic surface is represented with the [[conic]] structure:
<<conic structure>>=
struct conic {

  <<conic parameters>>
  
  void setup(rtd _c_, rtd _k_);
  void setup(rtd _c_, rtd _k_, vector _origin_, vector _euler_angles_);
  void setup(rtd _c_, rtd _k_, vector _origin_, vector _euler_angles_, vector conic_origin);
  void cleanup(void);
};
@
A conic surface is defined at a given location within a given coordinate system:
<<conic parameters>>=
coordinate_system ref_frame; 
vector origin, *d__origin;
@
The conic shape is specified with two parameters:
<<conic parameters>>=
rtd c, k;
@ 
where [[c]] is the vertex curvature and [[k]] is the conic parameter.

The conic surface is defined with
\begin{equation}
 \label{eq:4}
  F(x,y,z) = z - {c\rho^2 \over 1 + \sqrt{1 - \kappa c^2 \rho^2} } = 0.
\end{equation}

<<conic equations>>=
__host__ __device__ inline rtd conic_equation(vector *v, vector *v0, const rtd k, const rtd c)
{
  if (c==0)
    return 0.0;
  else {    
    rtd rho2;
    rho2 = c*v->rho2(v0->x,v0->y);
    if (k==0)
      return rho2*0.5;
    else
      return rho2/( 1 + sqrt(1 - k*c*rho2) );
  }
}
@ 
<<conic equations>>=
__device__ inline rtd conic_surface(vector *v, vector *v0, const rtd k, const rtd c)
{
  if (c==0)
    return v->z - v0->z;
  else {    
    rtd rho2;
    rho2 = c*v->rho2(v0->x,v0->y);
    if (k==0)
      return v->z - rho2*0.5 - v0->z;
    else
      return v->z - rho2/( 1 + sqrt(1 - k*c*rho2) ) - v0->z;
  }
}
@ 
The partial derivative of the conic equation are written
\begin{itemize}
\item
  \begin{equation}
    { \partial F(x,y,z) \over \partial x } = -x {c \over \sqrt{ 1 - \kappa c^2 \rho^2 } }
  \end{equation}
<<conic equations>>=
__device__ inline rtd partial_x_conic_surface(vector *v, vector *v0, const rtd k, const rtd c)
{
  if (c==0)
    return 0.0;
  else    
    if (k==0)
      return -(v->x - v0->x)*c;
    else {
      rtd rho2;
      rho2 = c*v->rho2(v0->x,v0->y);
      return -(v->x - v0->x)*c*rsqrt(1 - k*c*rho2);
    }
}
@
\item
  \begin{equation}
    { \partial F(x,y,z) \over \partial y } = -y {c \over \sqrt{ 1 - \kappa c^2 \rho^2 } }
  \end{equation}
<<conic equations>>=
__device__ inline rtd partial_y_conic_surface(vector *v, vector *v0, const rtd k, const rtd c)
{
  if (c==0)
    return 0.0;
  else    
    if (k==0)
      return -(v->y - v0->y)*c;
    else {
      rtd rho2;
      rho2 = c*v->rho2(v0->x,v0->y);
      return -(v->y - v0->y)*c*rsqrt(1 - k*c*rho2);
    }
}
@
\item
  \begin{equation}
    { \partial F(x,y,z) \over \partial z } = 1
  \end{equation}
<<conic equations>>=
__device__ inline rtd partial_z_conic_surface(void)
{
  return 1.0;
}
@
\end{itemize}

\subsection{Setup \& Cleanup}
\label{sec:surf-setup--cleanup}

A conic surface is initialized with the [[setup]] routine:
<<conic functions>>=
void conic::setup(rtd _c_, rtd _k_, vector _origin_, vector _euler_angles_)
{
  c = _c_;
  k = _k_;
  origin.x = 0;
  origin.y = 0;
  origin.z = 0;
  ref_frame.setup(_origin_, _euler_angles_);
  <<conic allocation>>
}
@ or with a surface centered on [[origin]]
<<conic functions>>=
void conic::setup(rtd _c_, rtd _k_, vector _origin_, vector _euler_angles_, vector conic_origin)
{
  c = _c_;
  k = _k_;
  origin.x = conic_origin.x;
  origin.y = conic_origin.y;
  origin.z = conic_origin.z;
  ref_frame.setup(_origin_, _euler_angles_);
  <<conic allocation>>
}
@
A conic surface that sets in the GCS is simply defined with
<<conic functions>>=
void conic::setup(rtd _c_, rtd _k_)
{
  c = _c_;
  k = _k_;
  origin.x = 0;
  origin.y = 0;
  origin.z = 0;
  ref_frame.setup();
  <<conic allocation>>
}
<<conic allocation>>=
HANDLE_ERROR( cudaMalloc((void**)&d__origin, sizeof(vector) ) );
HANDLE_ERROR( cudaMemcpy( d__origin, &origin, 
			    sizeof(vector), cudaMemcpyHostToDevice ) );
@ 
The GMT M1 segmented conic is defined with
<<conic functions (opt-out)>>=
void conic::setup_GMT_M1(void)
{
  c = 1./36.0;
  k = 1 - 0.9982857;
  D_seg = 8.365;
  ri    = 2.4412/8.365;
  N = 7;
  vector origin[7];
  vector euler_angles[7];
  origin[0].x = origin[0].y = origin[0].z = 0.0;
  euler_angles[0].x = euler_angles[0].y = euler_angles[0].z = 0.0;
  rtd D_c, o, zo, sa;
  sa = sin(13.522*PI/180);
  D_c = 8.710 - (0.691-0.445)*sa;
  zo = 8.417*sa*0.5 + 0.691 - 0.445;
  int k;  
  for (k=1; k<N; k++)
  {
    o = PI*(2*k-1)/6.0;
    origin[k].x = D_c*cosf(o);
    origin[k].y = D_c*sinf(o);
    origin[k].z = zo;
    euler_angles[k].x = 0.0;
    euler_angles[k].y = 0.0
    euler_angles[k].z = 0.0;
  }
  ref_frame.setup(origin, euler_angles, N);
}
@
Memory is freed with
<<conic functions>>=
void conic::cleanup(void)
{
  fprintf(stdout,"@(CEO)>conic: freeing memory!\n");
  ref_frame.cleanup();
  HANDLE_ERROR( cudaFree( d__origin ) );
}
@

\section{Aperture}
\label{sec:aperture}

An aperture is a bounded surface used to clip a bundle of ray to the aperture shape.
<<aperture structure>>=
struct aperture {
  <<aperture parameters>>
  void setup(float _D_, int _D_px_, 
	     vector _origin_, vector _euler_angles_);
  void setup(float _D_, float _ri_, int _D_px_, 
	     vector _origin_, vector _euler_angles_);
  void setup(float _D_, float _ri_, float _D_seg_, int _D_px_, 
	     vector *_origin_, vector *_euler_angles_, int N_segment);
  void setup_GMT_M1(float _D_, int _D_px_);
  void cleanup(void);
  void vignetting(bundle *rays);

};
@
A circular aperture is defined by its diameter [[D]] in meter of [[D_px]] in pixel.
If the aperture is annular [[ri]] defines the ratio between the inner and outer diameter.
The aperture can be segmented with [[N]] identical segments of diameter [[D_seg]].
The location of the aperture segments is defined within a given coordinate system [[ref_frame]].
A mask [[V]] is used to select the rays that are not vignetted by the aperture.
<<aperture parameters>>= 
int D_px;
float D, ri, D_seg;
int N;
mask V;
coordinate_system ref_frame;

@
\subsection{Setup \& Cleanup}
\label{sec:aper-setup--cleanup}

An aperture is initialized with:
\begin{itemize}
\item for a circular aperture,
<<aperture functions>>=
void aperture::setup(float _D_, int _D_px_, 
		     vector _origin_, vector _euler_angles_) 
{
  D_px = _D_px_;
  D_seg = D = _D_;
  ri   = 0.0;
  N = 1;
  V.setup(D_px*D_px);
  ref_frame.setup(_origin_, _euler_angles_);
}
@  \item for an annular aperture,
<<aperture functions>>=
void aperture::setup(float _D_, float _ri_, int _D_px_, 
		     vector _origin_, vector _euler_angles_) 
{
  D_px = _D_px_;
  D_seg = D = _D_;
  ri   = _ri_;
  N = 1;
  V.setup(D_px*D_px);
  ref_frame.setup(_origin_, _euler_angles_);
}
@
\item for an aperture with [[N_segment]] circular segment of diameter [[D_seg]], each segment with a different coordinate system,
<<aperture functions>>=
void aperture::setup(float _D_, float _ri_, float _D_seg_, int _D_px_, 
		     vector *_origin_, vector *_euler_angles_, int N_segment)
{
  D_px  = _D_px_;
  D     = _D_;
  D_seg = _D_seg_;
  ri    = _ri_;
  N = N_segment;
  V.setup(D_px*D_px*N);
  ref_frame.setup(_origin_, _euler_angles_, N);
}
@
\end{itemize}

Based on the above, one can defined specific segmented apertures like
\begin{description}
\item[GMT M1] 
The GMT M1 segment have all the same clear aperture of 8.365m diameter.
The center segment has a hole of 2.4412m diameter.
The center aperture is centered on the vertex of the conic surface that defines M1.
The vertex is set as the origin of the global coordinate system (GCS).
The center of the peripheral segments are evenly located on a circle of radius 8.710m with a phase of 30 degrees.
The peripheral segments also tilted inwards by 13.522 degrees.
<<aperture functions>>=
void aperture::setup_GMT_M1(float _D_, int _D_px_)
{
  D_px  = _D_px_;
  D     = _D_;
  D_seg = 8.365;
  ri    = 2.4412/8.365;
  N = 7;
  vector origin[7];
  vector euler_angles[7];
  origin[0].x = origin[0].y = origin[0].z = 0.0;
  euler_angles[0].x = euler_angles[0].y = euler_angles[0].z = 0.0;
  rtd D_c, o, zo, sa;
  sa = sin(13.522*PI/180);
  D_c = 8.710 - (0.691-0.445)*sa;
  zo = 8.417*sa*0.5 + 0.691 - 0.445;
  int k;  
  for (k=1; k<N; k++)
  {
    o = PI*(2*k-1)/6.0;
    origin[k].x = D_c*cosf(o);
    origin[k].y = D_c*sinf(o);
    origin[k].z = zo;
    euler_angles[k].x = 0.0;
    euler_angles[k].y = 13.522*PI/180.0;
    euler_angles[k].z = o;
  }
  V.setup(D_px*D_px*N);
  ref_frame.setup(origin, euler_angles, N);
}
@ 
\end{description}


The memory is freed with
<<aperture functions>>=
void aperture::cleanup(void)
{
  fprintf(stdout,"@(CEO)>aperture: freeing memory!\n");
  V.cleanup();
  ref_frame.cleanup();
}
@ 
The vignetting of the rays are done with
<<aperture functions>>=
void aperture::vignetting(bundle *rays)
{
  float R2, Rri2;
  R2 = D_seg*D_seg*0.25;
  Rri2 = R2*ri*ri;
  fprintf(stdout,"R2=%5.2f - Rri2=%5.2f\n",R2,Rri2);  
  dim3 blockDim(16,16);
  dim3 gridDim(rays->N_RAY/256+1,N);
  rays->reset();
  vignetting_kernel LLL gridDim , blockDim RRR (V.m, rays->d__ray, rays->N_RAY, 
						Rri2, R2,
						ref_frame.d__R,
						ref_frame.d__origin);
}
@ calling the device kernel:
<<vignetting kernel>>=
__global__ void vignetting_kernel(char *mask, ray *d__ray, int N_RAY, 
				  float inner2, float outer2,
				  rtd *d__R, vector *d__origin)
{
  int i, j, ij, iCoordSys, idx;
  rtd rho2;
  rtd x, y, z, u, v, w, x1, y1, s0, k, l, m;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = threadIdx.y;
  iCoordSys = blockIdx.y;
  ij = j * gridDim.x * blockDim.x + i;
  if ( ij<N_RAY )
  {

    idx = iCoordSys;

    u = d__ray[ij].coordinates.x - d__origin[idx].x;
    v = d__ray[ij].coordinates.y - d__origin[idx].y;
    w = d__ray[ij].coordinates.z - d__origin[idx].z;

    idx = iCoordSys*9;

    x = d__R[0+idx]*u + d__R[3+idx]*v + d__R[6+idx]*w;
    y = d__R[1+idx]*u + d__R[4+idx]*v + d__R[7+idx]*w;
    z = d__R[2+idx]*u + d__R[5+idx]*v + d__R[8+idx]*w;

    u = d__ray[ij].directions.x;
    v = d__ray[ij].directions.y;
    w = d__ray[ij].directions.z;

    k = d__R[0+idx]*u + d__R[3+idx]*v + d__R[6+idx]*w;
    l = d__R[1+idx]*u + d__R[4+idx]*v + d__R[7+idx]*w;
    m = d__R[2+idx]*u + d__R[5+idx]*v + d__R[8+idx]*w;

    if (m==0) { return; }
    s0 = -z/m;
    x1 = x + k*s0;
    y1 = y + l*s0;
    rho2 = x1*x1 + y1*y1;
    if (rho2<=outer2)
      {
	d__ray[ij].v = 1;
	mask[ij] = 1;
      }
    if ( (iCoordSys==0) && (rho2<inner2) )
      {
	d__ray[ij].v = 0;
	mask[ij] = 0;
      }
  }
}
@

\section{Ray tracing routines}
\label{sec:ray-tracing-routines}

\subsection{Coordinates transformation}
\label{sec:coord-transf}

The coordinates and cosine directions of the rays need to be transformed into the surface coordinates system first.
The matrix [[R]] in the conic structure transforms the coordinates in the LCS $(x,y,z)$ into the GCS $(\bar x,\bar y,\bar z)$ i.e.
\begin{equation}
  \left[
  \begin{array}{c}
    \bar x - \bar x_o \\
    \bar y - \bar y_o \\
    \bar z - \bar z_o
  \end{array}
  \right] = R \left[
    \begin{array}{c}
      x \\
      y \\
      z
    \end{array}
\right]
\end{equation}
The reverse transform is simply
\begin{equation}
  \left[
    \begin{array}{c}
      x \\
      y \\
      z
    \end{array}
\right] = R^T \left[
  \begin{array}{c}
    \bar x - \bar x_o \\
    \bar y - \bar y_o \\
    \bar z - \bar z_o
  \end{array}
  \right] = \left( \left[
  \begin{array}{c}
    \bar x - \bar x_o \\
    \bar y - \bar y_o \\
    \bar z - \bar z_o
  \end{array}
  \right]^T R \right)^T 
\end{equation}
<<transformation to surface system>>=
void transform_to_S(bundle *rays, conic *F)
{
  dim3 blockDim(16,16);
  dim3 gridDim(rays->N_RAY/256+1,1);
  transform_to_S_kernel LLL gridDim , blockDim RRR (rays->d__ray, rays->N_RAY,
					     F->ref_frame.d__R, F->ref_frame.d__origin);
}
void transform_to_S(bundle *rays, aperture *A)
{
  dim3 blockDim(16,16);
  dim3 gridDim(rays->N_RAY/256+1,1);
  transform_to_S_kernel LLL gridDim , blockDim RRR (rays->d__ray, rays->N_RAY,
					     A->ref_frame.d__R, A->ref_frame.d__origin);
}
@ 
<<transformation to surface system kernel>>=
__global__ void transform_to_S_kernel(ray *d__ray, int N_RAY, 
				      rtd *d__R, vector *d__origin)
{
  int i, j, ij;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  ij = j * gridDim.x * blockDim.x + i;
  if ( (ij<N_RAY) && (d__ray[ij].v) )
  {
    forward_transform(&(d__ray[ij].coordinates), &(d__ray[ij].coordinates),
		      d__R, d__origin);
    forward_transform_centered(&(d__ray[ij].directions), &(d__ray[ij].directions),
			       d__R);
  }
}
@ with the projection of the ray coordinates in the surface reference frame LCS:
<<coordinates forward transform>>=
__host__ __device__  void forward_transform(vector *v_out, vector *v_in,
					 rtd *d__R, vector *d__origin)
{
  rtd u, v, w;
  u = v_in->x - d__origin->x;
  v = v_in->y - d__origin->y;
  w = v_in->z - d__origin->z;

  v_out->x = d__R[0]*u + d__R[3]*v + d__R[6]*w;
  v_out->y = d__R[1]*u + d__R[4]*v + d__R[7]*w;
  v_out->z = d__R[2]*u + d__R[5]*v + d__R[8]*w;
}  
__host__ __device__  void forward_transform_centered(vector *v_out, vector *v_in,
						  rtd *d__R)
{
  rtd u, v, w;
  u = v_in->x;
  v = v_in->y;
  w = v_in->z;

  v_out->x = d__R[0]*u + d__R[3]*v + d__R[6]*w;
  v_out->y = d__R[1]*u + d__R[4]*v + d__R[7]*w;
  v_out->z = d__R[2]*u + d__R[5]*v + d__R[8]*w;
}  
<<rays coordinates to surface>>=
u = d__ray[ij].coordinates.x - d__origin->x;
v = d__ray[ij].coordinates.y - d__origin->y;
w = d__ray[ij].coordinates.z - d__origin->z;

x = d__R[0]*u + d__R[3]*v + d__R[6]*w;
y = d__R[1]*u + d__R[4]*v + d__R[7]*w;
z = d__R[2]*u + d__R[5]*v + d__R[8]*w;

d__ray[ij].coordinates.x = x;
d__ray[ij].coordinates.y = y;
d__ray[ij].coordinates.z = z;    

u = d__ray[ij].directions.x;
v = d__ray[ij].directions.y;
w = d__ray[ij].directions.z;

x = d__R[0]*u + d__R[3]*v + d__R[6]*w;
y = d__R[1]*u + d__R[4]*v + d__R[7]*w;
z = d__R[2]*u + d__R[5]*v + d__R[8]*w;

d__ray[ij].directions.x = x;
d__ray[ij].directions.y = y;
d__ray[ij].directions.z = z;    
@ 
<<transformation to rays system>>=
void transform_to_R(bundle *rays, conic *F)
{
  dim3 blockDim(16,16);
  dim3 gridDim(rays->N_RAY/256+1,1);
  transform_to_R_kernel LLL gridDim , blockDim RRR (rays->d__ray, rays->N_RAY,
        	 				     F->ref_frame.d__R, F->ref_frame.d__origin);
}
void transform_to_R(bundle *rays, aperture *A)
{
  dim3 blockDim(16,16);
  dim3 gridDim(rays->N_RAY/256+1,1);
  transform_to_R_kernel LLL gridDim , blockDim RRR (rays->d__ray, rays->N_RAY,
        	 				     A->ref_frame.d__R, A->ref_frame.d__origin);
}
@ 
<<transformation to rays system kernel>>=
__global__ void transform_to_R_kernel(ray *d__ray, int N_RAY,
                                      rtd *d__R, vector *d__origin)
{
  int i, j, ij;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  ij = j * gridDim.x * blockDim.x + i;
  if ( (ij<N_RAY) && (d__ray[ij].v) )
  {
    backward_transform(&(d__ray[ij].coordinates), &(d__ray[ij].coordinates),
		       d__R, d__origin);
    backward_transform_centered(&(d__ray[ij].directions), &(d__ray[ij].directions),
				d__R);
  }
}
@ with the projection of the ray coordinates in the rays reference frame LCS:
@ 
<<coordinates backward transform>>=
__host__ __device__  void backward_transform(vector *v_out, vector *v_in,
                                    rtd *d__R, vector *d__origin)
{
  rtd u, v, w;

  u = v_in->x;
  v = v_in->y;
  w = v_in->z;

  v_out->x = d__R[0]*u + d__R[1]*v + d__R[2]*w;
  v_out->y = d__R[3]*u + d__R[4]*v + d__R[5]*w;
  v_out->z = d__R[6]*u + d__R[7]*v + d__R[8]*w;

  v_out->x += d__origin->x;
  v_out->y += d__origin->y;
  v_out->z += d__origin->z;    
}  
__host__ __device__  void backward_transform_centered(vector *v_out, vector *v_in,
						  rtd *d__R)
{
  rtd u, v, w;

  u = v_in->x;
  v = v_in->y;
  w = v_in->z;

  v_out->x = d__R[0]*u + d__R[1]*v + d__R[2]*w;
  v_out->y = d__R[3]*u + d__R[4]*v + d__R[5]*w;
  v_out->z = d__R[6]*u + d__R[7]*v + d__R[8]*w;
}  
@ 
<<rays coordinates to rays>>=
u = d__ray[ij].coordinates.x;
v = d__ray[ij].coordinates.y;
w = d__ray[ij].coordinates.z;

x = d__R[0]*u + d__R[1]*v + d__R[2]*w;
y = d__R[3]*u + d__R[4]*v + d__R[5]*w;
z = d__R[6]*u + d__R[7]*v + d__R[8]*w;

d__ray[ij].coordinates.x = x + d__origin->x;
d__ray[ij].coordinates.y = y + d__origin->y;
d__ray[ij].coordinates.z = z + d__origin->z;    
@ 

\subsection{Surface intersection}
\label{sec:surface-intersection}

<<intersection with surface>>=
void intersect(bundle *rays, conic *F)
{
  dim3 blockDim(16,16);
  dim3 gridDim(rays->N_RAY/256+1,1);
  intersect_kernel LLL gridDim , blockDim RRR (rays->d__ray, rays->N_RAY, 
					       F->k, F->c, F->d__origin);
}

<<intersection with surface kernel>>=
__global__ void intersect_kernel(ray *d__ray, int N_RAY, 
				 const rtd Fk, const rtd Fc,
				 vector *d__origin)
{
  int i, j, ij;
  rtd s0, s1, x1, y1, k, l, m, S, K, L ,M, dSds;
  vector vv;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  ij = j * gridDim.x * blockDim.x + i;
  if ( (ij<N_RAY) && (d__ray[ij].v) )
  {
    <<intersection with z=0 plane>>
    d__ray[ij].optical_path_length += s0;
    s0 = s1 = 0;
    for (j=0; j<N_ITERATION; j++)
    {
      <<Newton-Raphson>>
	s0 = s1;
    }
  }
}
@
The intersection of a ray with the surface is derived using the parametric equations of the ray
\begin{eqnarray}
  \label{eq:3}
  x &=& x_0 + ks \\
  y &=& y_0 + ls \\
  z &=& z_0 + ms   
\end{eqnarray}
where $s$ is the distance along the ray from the point $(x_0,y_0,z_0)$.
Eq.~(\ref{eq:3}) are inserted into the surface definition Eq.~(\ref{eq:4}) that is solved for $s$.

The intersection with the plane $z=0$ in the LCS is derived first leading to 
\begin{eqnarray}
  \label{eq:5}
  s_0 &=& -z_0/m \\
  x_1 &=& x_0 + ks_0 \\
  y_1 &=& y_0 + ls_0 
\end{eqnarray}
<<intersection with z=0 plane>>=
k  = d__ray[ij].directions.x;
l  = d__ray[ij].directions.y;
m  = d__ray[ij].directions.z;
if (m==0) { return; }
s0 = -d__ray[ij].coordinates.z/m;
x1 = d__ray[ij].coordinates.x + k*s0;
y1 = d__ray[ij].coordinates.y + l*s0;
@
and giving a new set of parametric equations
\begin{eqnarray}
  \label{eq:6}
  x &=& x_1 + ks \\
  y &=& y_1 + ls \\
  z &=& ms     
\end{eqnarray}
 
The distance $s$ to the surface is obtained with the Newton--Raphson iterative method
\begin{equation}
  \label{eq:7}
  s_{j+1} = s_j - { F(x_j,y_j,z_j) \over F^\prime(x_j,y_j,z_j) }
\end{equation}
where
\begin{eqnarray}
  \label{eq:8}
  x_j &=& x_1 + ks_j \\
  y_j &=& y_1 + ls_j \\
  z_j &=& ms_j       
\end{eqnarray}
<<Newton-Raphson>>=
vv.x = x1 + k*s0;
vv.y = y1 + l*s0;
vv.z = m*s0;
@ and where
\begin{eqnarray}
  \label{eq:9}
  F^\prime(x_j,y_j,z_j) &=& \left. { {\mathrm d} F \over {\mathrm d} s  } \right|_{s=s_j} \\
                      &=& k\left.{ \partial F(x,y,z) \over \partial x } \right|_j + l\left. { \partial F(x,y,z) \over \partial y }\right|_j + m\left.{ \partial F(x,y,z) \over \partial z }\right|_j
\end{eqnarray}
<<Newton-Raphson>>=
S = conic_surface(&vv, d__origin, Fk, Fc);
K = partial_x_conic_surface(&vv, d__origin, Fk, Fc);
L = partial_y_conic_surface(&vv, d__origin, Fk, Fc);
M = partial_z_conic_surface();
dSds = K*k + L*l + M*m;
if (dSds==0) { return; }
s1 = s0 - S/dSds;
if (abs(s1-s0)<TOL)
{
  d__ray[ij].coordinates.x = x1 + k*s1;
  d__ray[ij].coordinates.y = y1 + l*s1;
  d__ray[ij].coordinates.z = m*s1;
  d__ray[ij].surface_normal.x    = 
    partial_x_conic_surface(&(d__ray[ij].coordinates), d__origin, Fk, Fc);
  d__ray[ij].surface_normal.y    =
    partial_y_conic_surface(&(d__ray[ij].coordinates), d__origin, Fk, Fc);
  d__ray[ij].surface_normal.z    = partial_z_conic_surface();
  d__ray[ij].optical_path_length += s1;
  return;
}
@
The iterative process is started with
\begin{equation}
  \label{eq:11}
  s_1 = 0,
\end{equation}
and is terminated when
\begin{equation}
  \label{eq:12}
  \left|s_{j+1} - s_j \right| < \epsilon,
\end{equation}
where $\epsilon$ is a tolerance set by the required accuracy.

The final distance along a ray from the point $(x_0,y_0,z_0)$ is
\begin{equation}
  \label{eq:13}
  s = s_0 + s_{j+1}.
\end{equation}

The surface normal at the intersection point will be needed to compute the refracted ray:
\begin{eqnarray}
  \label{eq:1}
  K &=& \left.{ \partial F(x,y,z) \over \partial x } \right|_{j+1} \\
  L &=& \left.{ \partial F(x,y,z) \over \partial y } \right|_{j+1} \\
  M &=& \left.{ \partial F(x,y,z) \over \partial z } \right|_{j+1}.
\end{eqnarray}
@

\subsection{Snell's law}
\label{sec:snells-law}

\subsubsection{Refraction}
\label{sec:refraction}

\def\np{n^\prime}
\def\kp{k^\prime}
\def\lp{l^\prime}
\def\mp{m^\prime}
\def\Sp{S^\prime}

The Snell's law can be written as
\begin{equation}
  \label{eq:10}
  \np \vec \Sp \times \vec r = n \vec S \times \vec r.
\end{equation}
$\vec S:(k,l,m)$ and $\vec \Sp:(\kp,\lp,\mp)$ are both unit vectors along the incident and refracted rays, respectively.
$\vec r:(K,L,M)$ is a unit vector normal to the refraction surface at the ray intersection point.
$n$ and $\np$ are the refractive indices for the incident and refracted rays, respectively.

Eq.~(\ref{eq:10}) implies that the three vectors $\vec S$, $\vec \Sp$ and $\vec r$ are co--planar, from which it follows that
\begin{equation}
  \label{eq:14}
  \vec \Sp = \mu \vec S + \Gamma \vec r,
\end{equation}
where $\mu=n/\np$ and $\Gamma$ has to be determined.
$\Gamma$ is derived by solving
\begin{equation}
  \label{eq:15}
  \left| \vec \Sp \right|^2 - \left| \mu \vec S + \Gamma \vec r \right|^2 = 0
\end{equation}
Developing Eq.~(\ref{eq:15}) leads to $\Gamma$ being the solution of a quadratic equation
\begin{equation}
  \label{eq:16}
  \Gamma^2 + 2a\Gamma + b = 0
\end{equation}
where
\begin{equation}
  \label{eq:17}
  a = \mu { kK +lL + mM \over K^2 + L^2 + M^2 },
\end{equation}
<<a equation>>=
K = d__ray[ij].surface_normal.x;
L = d__ray[ij].surface_normal.y;
M = d__ray[ij].surface_normal.z;
G2 = K*K + L*L + M*M;
k = d__ray[ij].directions.x;
l = d__ray[ij].directions.y;
m = d__ray[ij].directions.z;
a = mu*(k*K + l*L + m*M)/G2;
@  and
\begin{equation}
  \label{eq:18}
  b = { \mu^2 -1 \over K^2 + L^2 + M^2 }.
\end{equation}
<<b equation>>=
b = (mu*mu-1)/G2;
@ 
Eq.~(\ref{eq:16}) is solved with the Newton--Raphson iterative method by introducing the new function
\begin{equation}
  \label{eq:19}
  V(\Gamma) = \Gamma^2 + 2a\Gamma + b,
\end{equation}
and writing $\Gamma$ as
\begin{equation}
  \label{eq:20}
  \Gamma_{j+1} = \Gamma_j - { V(\Gamma_j) \over V^\prime(\Gamma_j) }.
\end{equation}
Noting that
\begin{equation}
  \label{eq:21}
  V^\prime(\Gamma_j) = \left. { \mathrm d V \over \mathrm d \Gamma } \right|_j = 2\left( \Gamma_j + a \right),
\end{equation}
Eq.~(\ref{eq:20}) becomes
\begin{equation}
  \label{eq:22}
  \Gamma_{j+1} = { \Gamma_j^2 - b \over 2(\Gamma_j + a) }.
\end{equation}
with
\begin{equation}
  \label{eq:23}
  \Gamma_1 = {-b \over 2a }.
\end{equation}

<<refraction>>=
void refract(bundle *rays, const rtd mu)
{
  dim3 blockDim(16,16);
  dim3 gridDim(rays->N_RAY/256+1,1);
  refract_kernel LLL gridDim , blockDim RRR (rays->d__ray, rays->N_RAY, mu);
}
@ 
<<refraction kernel>>=
__global__ void refract_kernel(ray *d__ray, int N_RAY, const rtd mu)
{
  int i, j, ij;
  rtd k, l, m, K, L ,M, G2, a, b, gamma0, gamma1, gamma_relative_error;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  ij = j * gridDim.x * blockDim.x + i;
  if ( (ij<N_RAY) && (d__ray[ij].v) )
  {
    <<a equation>>
    <<b equation>>
    gamma0 = -0.5*b/a;
    for (j=0; j<N_ITERATION; j++)
    {
      gamma1 = 0.5*(gamma0*gamma0-b)/(gamma0+a);
      gamma_relative_error = abs( gamma1/gamma0 - 1.0 );
      if (gamma_relative_error<0.01)
      {
        d__ray[ij].directions.x = mu*k + gamma1*K;
        d__ray[ij].directions.y = mu*l + gamma1*L;
        d__ray[ij].directions.z = mu*m + gamma1*M;
        return;
      }
      gamma0 = gamma1;
    }
  }
}
@
\subsubsection{Reflection}
\label{sec:reflection}

In the case of reflection, one have $\mu=1$, $b=0$ and
\begin{equation}
  \label{eq:24}
  \Gamma = -2a.
\end{equation}
Eq.~(\ref{eq:14}) thus becomes
\begin{equation}
  \label{eq:25}
    \vec \Sp = \vec S -2a \vec r.
\end{equation}
<<reflection>>=
void reflect(bundle *rays)
{
  dim3 blockDim(16,16);
  dim3 gridDim(rays->N_RAY/256+1,1);
  reflect_kernel LLL gridDim , blockDim RRR (rays->d__ray, rays->N_RAY, 1.0);
}
@ 
Setting $\mu=-1$ makes the mirror behaving like a thin lens:
<<thin lens>>=
void thin_lens(bundle *rays)
{
  dim3 blockDim(16,16);
  dim3 gridDim(rays->N_RAY/256+1,1);
  reflect_kernel LLL gridDim , blockDim RRR (rays->d__ray, rays->N_RAY, -1.0);
}
@ 
<<reflection kernel>>=
    __global__ void reflect_kernel(ray *d__ray, int N_RAY, float mu)
{
  int i, j, ij;
  rtd k, l, m, K, L ,M, G2, a;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  ij = j * gridDim.x * blockDim.x + i;
  if ( (ij<N_RAY) && (d__ray[ij].v) )
  {
    <<a equation>>
    a *= -2.0;
    d__ray[ij].directions.x = mu*k + a*K;
    d__ray[ij].directions.y = mu*l + a*L;
    d__ray[ij].directions.z = mu*m + a*M;
  }
}
@

\section{GMT M1}
\label{sec:gmt-m1}

A new structure to hold GMT M1 and M2 parameters and functions is defined.
<<GMT M1 structure>>=
struct gmt_m1 {
  <<GMT M12 parameters>>
  void setup(float _D_, int _D_px_);
  void cleanup(void);
  void update(vector _origin_, vector _euler_angles_,int idx);
  void trace(bundle *rays);
  void blocking(bundle *rays);
  void test_ray_tracing(void);
};
@ 
The GMT M12 parameters are:
\begin{itemize}
\item the mirror ID:
<<GMT M12 parameters>>=
int M_ID;
@
\item the segment clear aperture diameter $[[D_clear]]=8.365$m:
<<GMT M12 parameters>>=
rtd D_clear;
@
\item the segment full aperture diameter $[[D_full]]=8.417$m:
<<GMT M12 parameters>>=
rtd D_full;
@
\item the obscuration ratio of the center segment $[[ri]]=2.4412/8.365$
<<GMT M12 parameters>>=
rtd ri;
@
\item the tilt angle of the peripheral segment $[[beta]]=13.522$degree
<<GMT M12 parameters>>=
rtd beta;
@
\item the distance from the optical axis to the center of the tilted peripheral segments $[[L]]=8.710$m:
<<GMT M12 parameters>>=
rtd L;
@
\item the size of the square array containing M1 in meter and pixel [[D]] and [[D_px]]:
<<GMT M12 parameters>>=
rtd D;
int D_px;
@
\item the number of segment $[[N]]=7$
<<GMT M12 parameters>>=
int N;
@
\item the edge to center depth of the segment conic $[[depth]]=(0.691-0.445)$m:
<<GMT M12 parameters>>=
rtd depth;
@
\item the reference frames of the apertures:
<<GMT M12 parameters>>=
coordinate_system aperture_CS;
@
\item the reference frames and origins of the conics:
<<GMT M12 parameters>>=
coordinate_system conic_CS;
vector conic_origin[7], *d__conic_origin;
@
\item the conic parameters:
<<GMT M12 parameters>>=
rtd conic_c, conic_k;
@
\item the reference frames of the rigid bodies:
<<GMT M12 parameters>>=
coordinate_system rigid_body_CS;
@
\item the reference frames of the motions:
<<GMT M12 parameters>>=
coordinate_system motion_CS;
@
\item the mirror height
<<GMT M12 parameters>>=
rtd height;
@
\item the M1 pupil mask [[V]]:
<<GMT M12 parameters>>=
mask V;
@
\end{itemize}
@

\subsection{Setup \& Cleanup}
\label{sec:setup--cleanup-1}

The GMT M1 segment have all the same clear aperture of 8.365m diameter.
The center segment has a hole of 2.4412m diameter.
The center aperture is centered on the vertex of the conic surface that defines M1.
The vertex is set as the origin of the global coordinate system (GCS).
The center of the peripheral segments are evenly located on a circle of radius 8.710m with a phase of 30 degrees.
The peripheral segments also tilted inwards by 13.522 degrees.
The [[GMT_M1]] structure is initialized with the size of the square array containing M1 in meter and pixel.
The size must be 25.5m or more to contain M1 fully.
<<GMT M1 functions>>=
void gmt_m1::setup(float _D_, int _D_px_)
{
  M_ID    = 1;
  D_px    = _D_px_;
  D       = _D_;
  D_full  = 8.417;
  D_clear = 8.365;
  ri      = 2.4412/8.365;
  beta    = -13.522*PI/180.0;
  L       = 8.710;
  N       = 7;
  conic_c = -1.0/36.0;
  conic_k = 1-0.9982857;
  height  = 0.0;

  <<GMT setup common>>
}
@  with
<<GMT setup common>>=
vector __v0 = {0.0,0.0,0.0};
vector __v = {D_full*0.5,0.0,0.0};
// printf(" depth = %6.5f\n",conic_equation(&v,&v0,conic_k,fabs(conic_c)));
depth = conic_equation(&__v,&__v0,conic_k,(conic_c));

vector origin[7];
vector euler_angles[7];
rtd D_c, o, zo, sbeta, cbeta;
int k;    

<<M12 aperture definition>>

<<M12 conic definition>>

<<M12 rigid body definition>>

<<M12 motion definition>>

V.setup(D_px*D_px);
@ The origin and coordinates system of the rigid bodies are defined with
<<M12 rigid body definition>>=
origin[0].x = origin[0].y = 0.0;
origin[0].z = height;
euler_angles[0].x = euler_angles[0].y = euler_angles[0].z = 0.0;
D_c = L;
zo = D_full*sbeta*0.5 + depth*(1-cbeta);
for (k=1; k<N; k++)
{
  o = PI*(2*k-1)/6.0;
  origin[k].x = D_c*cosf(o);
  origin[k].y = D_c*sinf(o);
  origin[k].z = height + zo;
  euler_angles[k].x = 0.0;
  euler_angles[k].y = beta;
  euler_angles[k].z = o;
}
sprintf(tag,"M%d RIGID BODY",M_ID);
rigid_body_CS.setup(origin, euler_angles, N, tag);
@ The origin and coordinates system of the apertures are defined with
<<M12 aperture definition>>=
origin[0].x = origin[0].y = 0.0;
origin[0].z = depth;
euler_angles[0].x = euler_angles[0].y = euler_angles[0].z = 0.0;
sbeta = sin(beta);
D_c = L - depth*sbeta;
zo = D_full*sbeta*0.5 + depth;
for (k=1; k<N; k++)
{
  o = PI*(2*k-1)/6.0;
  origin[k].x = 0.0;
  origin[k].y = 0.0;
  origin[k].z = depth;
  euler_angles[k].x = 0.0;
  euler_angles[k].y = 0.0;
  euler_angles[k].z = 0.0;
}
char tag[16];
sprintf(tag,"M%d APERTURE",M_ID);
aperture_CS.setup(origin, euler_angles, N, tag);
@ The origin and coordinates system of the conics are defined with
<<M12 conic definition>>=
origin[0].x = origin[0].y = 0.0; 
origin[0].z = 0.0;
euler_angles[0].x = euler_angles[0].y = euler_angles[0].z = 0.0;
conic_origin[0].x = conic_origin[0].y = 0.0;
conic_origin[0].z = 0.0; 
cbeta = cos(beta);
D_c = L;
zo = D_full*sbeta*0.5 + depth*(1-cbeta);
for (k=1; k<N; k++)
{
  o = PI*(2*k-1)/6.0;
  origin[k].x = 0.0;
  origin[k].y = 0.0;
  origin[k].z = 0.0;
  euler_angles[k].x = 0.0;
  euler_angles[k].y = beta;
  euler_angles[k].z = o;
  conic_origin[k].x = -D_c*cosf(o);
  conic_origin[k].y = -D_c*sinf(o);
  conic_origin[k].z = -zo;
}
//euler_angles[0].x = 30.0*PI/180.0/3600.0;
sprintf(tag,"M%d CONIC",M_ID);
conic_CS.setup(origin, euler_angles, N, tag);
HANDLE_ERROR( cudaMalloc((void**)&d__conic_origin, sizeof(vector)*N ) );
HANDLE_ERROR( cudaMemcpy( d__conic_origin, conic_origin, 
			    sizeof(vector)*N, cudaMemcpyHostToDevice ) );
@ The origin and coordinates system of the motions are defined with
<<M12 motion definition>>=
for (k=0; k<N; k++)
{
  origin[k].x = 0.0;
  origin[k].y = 0.0;
  origin[k].z = 0.0;
  euler_angles[k].x = 0.0;
  euler_angles[k].y = 0.0;
  euler_angles[k].z = 0.0;
}
sprintf(tag,"M%d MOTION",M_ID);
motion_CS.setup(origin, euler_angles, N, tag);
@ 
Memory is freed with
<<GMT M1 functions>>=
void gmt_m1::cleanup(void)
{
  <<GMT cleanup common>>
}
@ with
<<GMT cleanup common>>=
fprintf(stdout,"@(CEO)>gmt_m1: freeing memory!\n");
V.cleanup();
aperture_CS.cleanup();
conic_CS.cleanup();
rigid_body_CS.cleanup();
motion_CS.cleanup();
HANDLE_ERROR( cudaFree( d__conic_origin ) );
@
The rigid body motion parameters are updated with:
<<GMT M1 functions>>=
void gmt_m1::update(vector _origin_, vector _euler_angles_,int idx)
{
    fprintf(stdout,"\n\x1B[31m");

    motion_CS.update( _origin_, _euler_angles_, idx);
    motion_CS.info();
}
@ 
\subsection{Blocking}
\label{sec:blocking}

The rays blocking with M1 is computed with
<<GMT M1 functions>>=
void gmt_m1::blocking(bundle *rays)
{
  <<GMT blocking common>>
}
@ where
<<GMT blocking common>>=
 float R2, Rri2;
 R2 = D_clear*D_clear*0.25;
 Rri2 = R2*ri*ri;
 // fprintf(stdout,"R2=%5.2f - Rri2=%5.2f\n",R2,Rri2);  
 dim3 blockDim(16,16);
 dim3 gridDim(rays->N_RAY/256+1,1);
 m1_blocking_kernel LLL gridDim , blockDim RRR (V.m, rays->d__ray, rays->N_RAY, 
					     Rri2, R2,
					     rigid_body_CS.d__R,
					     rigid_body_CS.d__origin,
					     aperture_CS.d__R,
					     aperture_CS.d__origin);
 GMT_intersection LLL gridDim , blockDim RRR (V.m, rays->d__ray, rays->N_RAY);
@ and with the kernel
<<GMT blocking kernel>>=
__global__ void m1_blocking_kernel(char *mask, ray *d__ray, int N_RAY, 
				float inner2, float outer2,
				rtd *d__rigid_body_R, vector *d__rigid_body_origin,
				rtd *d__aperture_R, vector *d__aperture_origin)
{
  int i, j, ij, iCoordSys;
  rtd rho2;
  rtd x, y, z, x1, y1, s0, k, l, m;
  vector xyz, klm, xyz_GS, klm_GS;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = threadIdx.y;
  //  iCoordSys = blockIdx.y;
  ij = j * gridDim.x * blockDim.x + i;
  if  ( ( ij<N_RAY ) && (d__ray[ij].v) )// & (iCoordSys<1) )
  {

    for (iCoordSys=0; iCoordSys<7; iCoordSys++)
      {
	// RIGID BODY >>>  
	forward_transform(&xyz_GS, &(d__ray[ij].coordinates),
			  d__rigid_body_R+iCoordSys*9, d__rigid_body_origin+iCoordSys);
	forward_transform_centered(&klm_GS, &(d__ray[ij].directions),
				   d__rigid_body_R+iCoordSys*9);

	// APERTURE >>>
	forward_transform(&xyz, &xyz_GS,
			  d__aperture_R+iCoordSys*9,
			  d__aperture_origin+iCoordSys);
	forward_transform_centered(&klm, &klm_GS,
				   d__aperture_R+iCoordSys*9);

	x = xyz.x;
	y = xyz.y;
	z = xyz.z;
	k = klm.x;
	l = klm.y;
	m = klm.z;

        <<GMT intersection with aperture plane>>

        rho2 = x1*x1 + y1*y1;
	if ( (iCoordSys==0) && (rho2<inner2) )
	  {
	    return;
	  }
	if (rho2<=outer2)
	  {
	    mask[ij] = 0;
          }
       }
   }
}
@
\subsection{Ray tracing}
\label{sec:ray-tracing}

The rays propagation through M1 is computed with
<<GMT M1 functions>>=
void gmt_m1::trace(bundle *rays)
{
  <<GMT trace common>>
}
@ where
<<GMT trace common>>=
 float R2, Rri2;
 R2 = D_clear*D_clear*0.25;
 Rri2 = R2*ri*ri;
 // fprintf(stdout,"R2=%5.2f - Rri2=%5.2f\n",R2,Rri2);  
 dim3 blockDim(16,16);
 dim3 gridDim(rays->N_RAY/256+1,1);
 HANDLE_ERROR( cudaMemset(V.m, 0, sizeof(char)*rays->N_RAY ) );
 m1_trace_kernel LLL gridDim , blockDim RRR (V.m, rays->d__ray, rays->N_RAY, 
					     Rri2, R2,
					     aperture_CS.d__R,
					     aperture_CS.d__origin,
					     conic_CS.d__R,
					     conic_CS.d__origin,
					     conic_k, conic_c,
					     d__conic_origin,
					     rigid_body_CS.d__R,
					     rigid_body_CS.d__origin,
					     motion_CS.d__R,
					     motion_CS.d__origin);
 GMT_intersection LLL gridDim , blockDim RRR (V.m, rays->d__ray, rays->N_RAY);
@ and with the kernel
<<GMT ray tracing kernel>>=
__global__ void m1_trace_kernel(char *mask, ray *d__ray, int N_RAY, 
				float inner2, float outer2,
				rtd *d__aperture_R, vector *d__aperture_origin,
				rtd *d__conic_R, vector *d__conic_origin,
                                const rtd Fk, const rtd Fc,
                                vector *d__conic_self_origin,
				rtd *d__rigid_body_R, vector *d__rigid_body_origin,
				rtd *d__motion_R, vector *d__motion_origin)
{
  int i, j, ij, iCoordSys;
  rtd rho2;
  rtd x, y, z, x1, y1, s0, k, l, m;
  rtd s1, S, K, L ,M, dSds;
  rtd G2, a;
  vector d__origin, xyz, klm, xyz_GS, klm_GS;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = threadIdx.y;
  //  iCoordSys = blockIdx.y;
  ij = j * gridDim.x * blockDim.x + i;
  if  ( ( ij<N_RAY ) && (d__ray[ij].v) )// & (iCoordSys<1) )
  {

    for (iCoordSys=0; iCoordSys<7; iCoordSys++)
      {

	d__origin = d__conic_self_origin[iCoordSys];
	// RIGID BODY >>>  
	forward_transform(&xyz_GS, &(d__ray[ij].coordinates),
			  d__rigid_body_R+iCoordSys*9, d__rigid_body_origin+iCoordSys);
	forward_transform_centered(&klm_GS, &(d__ray[ij].directions),
				   d__rigid_body_R+iCoordSys*9);

	// MOTION >>>  
	forward_transform(&xyz_GS, &xyz_GS,
			  d__motion_R+iCoordSys*9, d__motion_origin+iCoordSys);
	forward_transform_centered(&klm_GS, &klm_GS,
				   d__motion_R+iCoordSys*9);

	// APERTURE >>>
	forward_transform(&xyz, &xyz_GS,
			  d__aperture_R+iCoordSys*9,
			  d__aperture_origin+iCoordSys);
	forward_transform_centered(&klm, &klm_GS,
				   d__aperture_R+iCoordSys*9);

	x = xyz.x;
	y = xyz.y;
	z = xyz.z;
	k = klm.x;
	l = klm.y;
	m = klm.z;

        <<GMT intersection with aperture plane>>

        rho2 = x1*x1 + y1*y1;
	if ( (iCoordSys==0) && (rho2<inner2) )
	  {
	    return;
	  }

	if (rho2<=outer2)
	  {
	    mask[ij] = 1;

	    // CONIC >>>
	    backward_transform_centered(&xyz, &xyz_GS,
				       d__conic_R+iCoordSys*9);
	    backward_transform_centered(&klm, &klm_GS,
				       d__conic_R+iCoordSys*9);

	    <<GMT intersection with conic>>

	    G2 = K*K + L*L + M*M;
	    a  = k*K + l*L + m*M;

	    a *= -2.0/G2;
	    klm.x += a*K;
	    klm.y += a*L;
	    klm.z += a*M;

	    // CONIC <<<
	    forward_transform_centered(&xyz_GS, &xyz,
					d__conic_R+iCoordSys*9);
	    forward_transform_centered(&klm_GS, &klm,
					d__conic_R+iCoordSys*9);
	    // MOTION <<<
	    backward_transform(&xyz_GS, &xyz_GS,
			      d__motion_R+iCoordSys*9, d__motion_origin+iCoordSys);
	    backward_transform_centered(&klm_GS, &klm_GS,
				       d__motion_R+iCoordSys*9);

	    // RIGID_BODY <<<
	    backward_transform(&(d__ray[ij].coordinates), &xyz_GS,
			       d__rigid_body_R+iCoordSys*9,
			       d__rigid_body_origin+iCoordSys);
	    backward_transform_centered(&(d__ray[ij].directions), &klm_GS,
					d__rigid_body_R+iCoordSys*9);
	   }
      }
  }
}
@ The following is a test routine to validate the sequence of transformation in the ray tracing kernel:
<<GMT M1 functions>>=
void gmt_m1::test_ray_tracing(void)
{
  int iCoordSys;
  vector in, out;

  in.x = 8.71*cos(PI/6);
  in.y = 8.71*sin(PI/6);
  in.z = 0.0;

  printf("Output vector:\n");
  for (iCoordSys = 0; iCoordSys<N; iCoordSys++)
    {
      printf(" #%d\n",iCoordSys);
        forward_transform(&out, &in,
                          rigid_body_CS.R+iCoordSys*9,
                          rigid_body_CS.origin+iCoordSys);
        printf(". x = %.2e ; y = %.2e ; z = %.2e\n",out.x,out.y,out.z);

        forward_transform(&out, &out,
                          motion_CS.R+iCoordSys*9,
                          motion_CS.origin+iCoordSys);
        printf(". x = %.2e ; y = %.2e ; z = %.2e\n",out.x,out.y,out.z);

	backward_transform_centered(&out, &out,
				    conic_CS.R+iCoordSys*9);
        printf(". x = %.2e ; y = %.2e ; z = %.2e\n",out.x,out.y,out.z);

	forward_transform_centered(&out, &out,
				    conic_CS.R+iCoordSys*9);
        printf(". x = %.2e ; y = %.2e ; z = %.2e\n",out.x,out.y,out.z);

        backward_transform(&out, &out,
                          motion_CS.R+iCoordSys*9,
                          motion_CS.origin+iCoordSys);
        printf(". x = %.2e ; y = %.2e ; z = %.2e\n",out.x,out.y,out.z);

        backward_transform(&out, &out,
                          rigid_body_CS.R+iCoordSys*9,
                          rigid_body_CS.origin+iCoordSys);
        printf(". x = %.2e ; y = %.2e ; z = %.2e\n",out.x-in.x,out.y-in.y,out.z-in.z);
    }
    
}
@ and
<<GMT aperture intersection>>=
__global__ void GMT_intersection(char *mask, ray *d__ray, int N_RAY)
{
  int i, j, ij;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = threadIdx.y;
  ij = j * gridDim.x * blockDim.x + i;
  if  ( ij<N_RAY )
  {
    d__ray[ij].v &= mask[ij];
  }
}
@
The rays coordinates and cosine directions are transformed into the aperture coordinates system:
<<GMT transformation to aperture coordinate system>>=
 idx = iCoordSys;

 u = d__ray[ij].coordinates.x - d__aperture_origin[idx].x;
 v = d__ray[ij].coordinates.y - d__aperture_origin[idx].y;
 w = d__ray[ij].coordinates.z - d__aperture_origin[idx].z;

 idx = iCoordSys*9;

 x = d__aperture_R[0+idx]*u + d__aperture_R[3+idx]*v + d__aperture_R[6+idx]*w;
 y = d__aperture_R[1+idx]*u + d__aperture_R[4+idx]*v + d__aperture_R[7+idx]*w;
 z = d__aperture_R[2+idx]*u + d__aperture_R[5+idx]*v + d__aperture_R[8+idx]*w;

 u = d__ray[ij].directions.x;
 v = d__ray[ij].directions.y;
 w = d__ray[ij].directions.z;

 k = d__aperture_R[0+idx]*u + d__aperture_R[3+idx]*v + d__aperture_R[6+idx]*w;
 l = d__aperture_R[1+idx]*u + d__aperture_R[4+idx]*v + d__aperture_R[7+idx]*w;
 m = d__aperture_R[2+idx]*u + d__aperture_R[5+idx]*v + d__aperture_R[8+idx]*w;
@
The intersection with the aperture plane is computed with
<<GMT intersection with aperture plane>>=
if (m==0) { return; }
s0 = -z/m;
x1 = x + k*s0;
y1 = y + l*s0;
@ The rays coordinates and cosine directions are transformed into the aperture coordinates system:
<<GMT transformation to conic coordinate system>>=
idx = iCoordSys;

u = d__ray[ij].coordinates.x - d__conic_origin[idx].x;
v = d__ray[ij].coordinates.y - d__conic_origin[idx].y;
w = d__ray[ij].coordinates.z - d__conic_origin[idx].z;

idx = iCoordSys*9;

x = d__conic_R[0+idx]*u + d__conic_R[3+idx]*v + d__conic_R[6+idx]*w;
y = d__conic_R[1+idx]*u + d__conic_R[4+idx]*v + d__conic_R[7+idx]*w;
z = d__conic_R[2+idx]*u + d__conic_R[5+idx]*v + d__conic_R[8+idx]*w;

d__ray[ij].coordinates.x = x;
d__ray[ij].coordinates.y = y;
d__ray[ij].coordinates.z = z;    

u = d__ray[ij].directions.x;
v = d__ray[ij].directions.y;
w = d__ray[ij].directions.z;

k = d__conic_R[0+idx]*u + d__conic_R[3+idx]*v + d__conic_R[6+idx]*w;
l = d__conic_R[1+idx]*u + d__conic_R[4+idx]*v + d__conic_R[7+idx]*w;
m = d__conic_R[2+idx]*u + d__conic_R[5+idx]*v + d__conic_R[8+idx]*w;

d__ray[ij].directions.x = k;
d__ray[ij].directions.y = l;
d__ray[ij].directions.z = m;  
@ The intersection with the plane $z=0$ in the conic coordinate transformed is computed with  
<<GMT intersection with conic>>=
k  = klm.x;
l  = klm.y;
m  = klm.z;
if (m==0) { return; }
s0 = -xyz.z/m;
x1 = xyz.x + k*s0;
y1 = xyz.y + l*s0;
d__ray[ij].optical_path_length += s0;
s0 = s1 = 0;
for (j=0; j<N_ITERATION; j++)
{
  xyz.x = x1 + k*s0;
  xyz.y = y1 + l*s0;
  xyz.z = m*s0;
  S = conic_surface(&xyz, &d__origin, Fk, Fc);
  K = partial_x_conic_surface(&xyz, &d__origin, Fk, Fc);
  L = partial_y_conic_surface(&xyz, &d__origin, Fk, Fc);
  M = partial_z_conic_surface();
  dSds = K*k + L*l + M*m;
  if (dSds==0) { break; }
  s1 = s0 - S/dSds;
  if (abs(s1-s0)<TOL)
    {
      xyz.x = x1 + k*s1;
      xyz.y = y1 + l*s1;
      xyz.z = m*s1;
      K    = 
	partial_x_conic_surface(&xyz, &d__origin, Fk, Fc);
      L    =
	partial_y_conic_surface(&xyz, &d__origin, Fk, Fc);
      M    = partial_z_conic_surface();
      d__ray[ij].optical_path_length += s1;
      d__ray[ij].n_iteration = j;
      break;
    }
  s0 = s1;
}
@ The rays coordinates and cosine directions are transformed back into the global coordinate system:
<<GMT transformation to global coordinate system>>=
idx = iCoordSys;

u = d__ray[ij].coordinates.x;
v = d__ray[ij].coordinates.y;
w = d__ray[ij].coordinates.z;

idx = iCoordSys*9;

x = d__conic_R[0+idx]*u + d__conic_R[1+idx]*v + d__conic_R[2+idx]*w;
y = d__conic_R[3+idx]*u + d__conic_R[4+idx]*v + d__conic_R[5+idx]*w;
z = d__conic_R[6+idx]*u + d__conic_R[7+idx]*v + d__conic_R[8+idx]*w;

idx = iCoordSys;
d__ray[ij].coordinates.x = x + d__conic_origin[idx].x;
d__ray[ij].coordinates.y = y + d__conic_origin[idx].y;
d__ray[ij].coordinates.z = z + d__conic_origin[idx].z;    

u = d__ray[ij].directions.x;
v = d__ray[ij].directions.y;
w = d__ray[ij].directions.z;

idx = iCoordSys*9;

x = d__conic_R[0+idx]*u + d__conic_R[1+idx]*v + d__conic_R[2+idx]*w;
y = d__conic_R[3+idx]*u + d__conic_R[4+idx]*v + d__conic_R[5+idx]*w;
z = d__conic_R[6+idx]*u + d__conic_R[7+idx]*v + d__conic_R[8+idx]*w;

d__ray[ij].directions.x = x;
d__ray[ij].directions.y = y;
d__ray[ij].directions.z = z;    
@
\section{GMT M2}
\label{sec:gmt-m2}

A new structure to hold GMT M1 parameters and functions is defined.
<<GMT M2 structure>>=
struct gmt_m2 {
  <<GMT M12 parameters>>
  void setup(float _D_, int _D_px_);
  void cleanup(void);
  void trace(bundle *rays);
  void blocking(bundle *rays);
  void update(vector _origin_, vector _euler_angles_,int idx);
};
@
\subsection{Setup \& Cleanup}
\label{sec:setup--cleanup-2}

<<GMT M2 functions>>=
void gmt_m2::setup(float _D_, int _D_px_)
{
  M_ID    = 2;
  D_px    = _D_px_;
  D       = _D_;
  D_full  = 1.0425;
  D_clear = 1.0415;
  ri      = 0.0;//2.4412/8.365;
  beta    = 14.706*PI/180.0;
  L       = 1.08774;
  N       = 7;
  conic_c = 1.0/4.163901;
  conic_k = 1-0.7169273;
  height  = (float) -20.262476;
  <<GMT setup common>>
}
@ 
Memory is freed with
<<GMT M2 functions>>=
void gmt_m2::cleanup(void)
{
  <<GMT cleanup common>>
}
@
\subsection{Blocking}
\label{sec:blocking-2}

The rays blocking with M2 is computed with
<<GMT M2 functions>>=
void gmt_m2::blocking(bundle *rays)
{
  <<GMT blocking common>>
}
@
\subsection{Ray tracing}
\label{sec:ray-tracing-2}

The rays propagation through M1 is computed with
<<GMT M2 functions>>=
void gmt_m2::trace(bundle *rays)
{ 
 <<GMT trace common>>
}
@
The rigid body motion parameters are updated with:
<<GMT M2 functions>>=
void gmt_m2::update(vector _origin_, vector _euler_angles_,int idx)
{
    fprintf(stdout,"\n\x1B[31m");

    motion_CS.update( _origin_, _euler_angles_, idx);
    motion_CS.info();
}
@
\section{Input/Output}
\label{sec:inputoutput}

\section{Tests}
\label{sec:tests}

