% -*- mode: Noweb; noweb-code-mode: c-mode -*-
[[aaStats]] contains a structure and the routines to compute the covariance matrix of the angle--of--arrival.
The aaStats structure is written in the header:
<<aaStats.h>>=
#ifndef __AASTATS_H__
#define __AASTATS_H__

#ifndef __CEO_H__
#include "ceo.h"
#endif

#ifndef __ATMOSPHERE_H__
#include "atmosphere.h"
#endif

struct aaStats {

  <<aaStats parameters>>

  void setup(int N, atmosphere *atm, float lenslet_pitch);

  void cleanup(void);

  void info(void);

  void MVM(float *y, float *x);

};
#endif // __AASTATS_H__
@ The routines are expanded in the source file:
<<aaStats.cu>>=
#include "aaStats.h"

<<sinc>>

<<subaperture PSF>>

<<phase power spectrum>>

<<power spectrum kernel>>

<<covariance extraction>>

<<ordering indices>>

<<MVM input ordering kernel>>

<<MVM complex multiplication>>

<<MVM output ordering kernel>>

<<setup>>

<<cleanup>>

<<info>>

<<matrix--to--vector multiplication>>
@
Shack--Hartmann WFS centroids are a measure of the spatial derivatives of the wavefront averaged on each subaperture.
These derivatives are often referred as angle of arrivals:
\begin{eqnarray}
  \label{eq:1}
  \alpha_x &=& {\lambda\over 2\pi d^2} {\partial\varphi\over\partial x} \ast \Pi\left(x\over d\right)\Pi\left(y\over d\right),\\
  \alpha_y &=& {\lambda\over 2\pi d^2} {\partial\varphi\over\partial y} \ast \Pi\left(x\over d\right)\Pi\left(y\over d\right),
\end{eqnarray}
where $\lambda$ is the sensing wavelength and $d$ in the size of one subaperture.

The covariance is derived from the power spectrum density of the angle of arrivals $W_{\vec \alpha \cdot\ \vec \beta}(\vec f)$:
  \begin{equation}
    \label{eq:2}
    W_{\vec \alpha\vec \beta}(\vec f) = \lambda^2\left( \vec f \cdot \vec\alpha \right)\left( \vec f \cdot \vec\beta \right) W_\varphi(\vec f) G^2(\vec f)
  \end{equation}
$W_\varphi(f)$ is the wavefront power spectrum density given by
\begin{equation}
  \label{eq:3}
  W_\varphi(f) = 0.0229 r_0^{-5/3} \left( f^2 + {1\over\mathcal L_0^2} \right)^{-11/6}.
\end{equation}
$G(\vec f)$ is the point spread function of a subaperture of the WFS,
\begin{equation}
  \label{eq:4}
  G(\vec f) = {\sin(\pi d f_x) \over \pi d f_x }{ \sin(\pi d f_y) \over \pi d f_y } .
\end{equation}

The covariance $C_{\vec \alpha \cdot\ \vec \beta}(\vec\rho)$ is derived from the Wiener--Khinchine theorem:
\begin{equation}
  \label{eq:5}
  C_{\vec \alpha \cdot\ \vec \beta}(\vec\rho) = \mathcal F^{-1} \left[ W_{\vec \alpha\vec \beta}(\vec f) \right] (\vec\rho)
\end{equation}
where $\mathcal F^{-1}$ stands for the inverse Fourier transform.

The covariance is computed when the setup function is called with the size of a block, an [[atmosphere]] structure and the lenslet pitch:
<<setup>>=
void aaStats::setup(int N_, atmosphere *atm, float lenslet_pitch)
{
  float alpha[2] = {1,0}, beta[2] = {0,1}, kappa; 
  int DEBUG = 0;
  N = N_;
  N2 = N*N;
  NU = 2*N-1;
  NU2 = NU*NU;
  NF = 1024;
  NF2 = NF*NF;
  kappa = 4;

  psd_size = sizeof(float2)*NF2*4;
  cov_size = sizeof(float2)*NU2*4;
  ind_size = sizeof(int)*N2;
  HANDLE_ERROR( cudaMalloc((void**)&d__psd, psd_size ) );
  HANDLE_ERROR( cudaMalloc((void**)&d__alpha, 2*sizeof(float) ) );
  HANDLE_ERROR( cudaMalloc((void**)&d__beta,  2*sizeof(float) ) );
  HANDLE_ERROR( cudaMemcpy( d__alpha, alpha, 2*sizeof(float), cudaMemcpyHostToDevice) );
  HANDLE_ERROR( cudaMemcpy( d__beta, beta, 2*sizeof(float), cudaMemcpyHostToDevice) );
  HANDLE_ERROR( cudaMalloc((void**)&d__cov, cov_size ) );
  HANDLE_ERROR( cudaMalloc((void**)&d__mu, ind_size ) );
  HANDLE_ERROR( cudaMalloc((void**)&d__xi, ind_size ) );
  HANDLE_ERROR( cudaMalloc((void**)&d__b, 2*sizeof(float2)*NU2 ) );
  HANDLE_ERROR( cudaMalloc((void**)&d__c, 2*sizeof(float2)*NU2 ) );

  printf("\n@(CEO)>imaging: Creating 2D covariance FFT plan\n");
  int n_DFT[2] = {NF, NF};
  int iodist = NF2;
  int BATCH = 4;
  /* Create a 2D FFT plan. */
  if (cufftPlanMany(&plan, 2, n_DFT,
		    NULL, 1, iodist,
		    NULL, 1, iodist,
		    CUFFT_C2C,BATCH) != CUFFT_SUCCESS) {
    fprintf(stderr,
	    "CUFFT Error: Unable to create plan\n");
    return;
  }
  if (cufftSetCompatibilityMode(plan, CUFFT_COMPATIBILITY_NATIVE)!= CUFFT_SUCCESS) {
    fprintf(stderr,
	    "CUFFT Error: Unable to set compatibility mode to native\n");
    return;
  }

  printf("\n@(CEO)>imaging: Creating a 1D covariance FFT plan\n");
  /* Create a 2D FFT plan. */
  if (cufftPlanMany(&raster_plan, 1, &NU2,
		    NULL, 1, NU2,
		    NULL, 1, NU2,
		    CUFFT_C2C,BATCH) != CUFFT_SUCCESS) {
    fprintf(stderr,
	    "CUFFT Error: Unable to create plan\n");
    return;
  }
  if (cufftSetCompatibilityMode(raster_plan, CUFFT_COMPATIBILITY_NATIVE)!= CUFFT_SUCCESS) {
    fprintf(stderr,
	    "CUFFT Error: Unable to set compatibility mode to native\n");
    return;
  }

  printf("\n@(CEO)>imaging: Creating a 1D MVM FFT plan\n");
  /* Create a 2D FFT plan. */
  BATCH = 2;
  if (cufftPlanMany(&MVM_plan, 1, &NU2,
		    NULL, 1, NU2,
		    NULL, 1, NU2,
		    CUFFT_C2C,BATCH) != CUFFT_SUCCESS) {
    fprintf(stderr,
	    "CUFFT Error: Unable to create plan\n");
    return;
  }
  if (cufftSetCompatibilityMode(MVM_plan, CUFFT_COMPATIBILITY_NATIVE)!= CUFFT_SUCCESS) {
    fprintf(stderr,
	    "CUFFT Error: Unable to set compatibility mode to native\n");
    return;
  }

 info();  

  <<power spectrum>>
  HANDLE_ERROR( cudaDeviceSynchronize() );
  psd = (float2 *)malloc( psd_size );
  HANDLE_ERROR( cudaMemcpy( psd, d__psd, psd_size, cudaMemcpyDeviceToHost) );
  if (DEBUG>0) {
    int k;
    printf("\n@(CEO)>aaStats: power spectrum\n");
    for (int i=0;i<NF;i++) {
      printf("|");
      for (int j=0;j<NF;j++) {
	k = i*NF + j;
	printf("|(%d,%d)%+4.2E;%+4.2E|",i,j,psd[k].x,psd[k].y);
      }
      printf("|\n");
    }
  }

  <<covariance>>
  cov = (float2 *)malloc( cov_size );
  HANDLE_ERROR( cudaMemcpy( cov, d__cov, cov_size, cudaMemcpyDeviceToHost) );
  if (DEBUG>0) {
    int k;
    printf("\n@(CEO)>aaStats: covariance\n");
    for (int i=0;i<NU;i++) {
      printf("|");
      for (int j=0;j<NU;j++) {
	k = i*(NU) + j;
	printf("|(%d,%d)%+4.2E|",i,j,cov[k].x);
      }
      printf("|\n");
    }
  }

  <<raster covariance FT>>
  HANDLE_ERROR( cudaMemcpy( cov, d__cov, cov_size, cudaMemcpyDeviceToHost) );
  if (DEBUG>0) {
    printf("\n@(CEO)>aaStats: raster covariance\n");
    for (int k=0;k<NU2;k++)
      printf("%2d: %+4.2E %+4.2E.I||%+4.2E %+4.2E.I||%+4.2E %+4.2E.I||%+4.2E%+4.2E.I\n",k,
	     cov[k].x,cov[k].y,
	     cov[k+NU2].x,cov[k+NU2].y,
	     cov[k+2*NU2].x,cov[k+2*NU2].y,
	     cov[k+3*NU2].x,cov[k+3*NU2].y);
  }

  blockDim = dim3(16,16);
  gridDim = dim3( 1+N/16 , 1+N/16 );
  ordering LLL gridDim,blockDim RRR(d__mu, d__xi, N);
  mu = (unsigned int *)malloc( ind_size );
  HANDLE_ERROR( cudaMemcpy( mu, d__mu, ind_size, cudaMemcpyDeviceToHost) );
  xi = (unsigned int *)malloc( ind_size );
  HANDLE_ERROR( cudaMemcpy( xi, d__xi, ind_size, cudaMemcpyDeviceToHost) );
  if (DEBUG>0) {
    printf("\n|( i) mu xi|\n");
    for (int i=0;i<N*N;i++) 
      printf("|(%2d) %2d %2d|\n",i,mu[i],xi[i]);
  }
}
@ The main parameters of [[aaStats]] are displayed with the [[info]] routine:
<<info>>=
void aaStats::info(void)
{
  printf("\n@(CEO)>aaStats:\n");
  printf(" . number of blocks: %dX%d\n",N,N);
  printf(" . size of blocks: %dX%d\n",N,N);
  float n_total = powf(N,4);
  printf(" . full matrix elements #      : %10d\n",4*n_total);
  printf(" . compressed matrix elements #: %10d\n",4*NU2);
  printf(" . compression factor: %4.0f \n",n_total/NU2);
  float mb = powf(2,20);
  float mb_total = 4*n_total*sizeof(float);
  if (mb_total>mb)
    printf(" . full matrix storage [MB]      : %6.0f\n",mb_total/mb);
  else
    printf(" . full matrix storage [KB]      : %6.0f\n",mb_total/1024.0);
  float mb_comp = cov_size;
  if (mb_comp>mb)
    printf(" . compressed matrix storage [MB]: %6.1f\n",mb_comp/mb);
  else
    printf(" . compressed matrix storage [KB]: %6.1f\n",mb_comp/1024.0);
  printf(" . compression factor: %4.0f \n",mb_total/mb_comp);
  printf("----------------------------------------------------\n");
}
@ 
<<cleanup>>=
void aaStats::cleanup(void)
{
  printf("\n@(CEO)>aaStats: freeing memory!\n");
  cufftDestroy(plan);
  cufftDestroy(raster_plan);
  cufftDestroy(MVM_plan);
  HANDLE_ERROR( cudaFree( d__psd ) );
  HANDLE_ERROR( cudaFree( d__alpha ) );
  HANDLE_ERROR( cudaFree( d__beta ) );
  HANDLE_ERROR( cudaFree( d__cov ) );
  HANDLE_ERROR( cudaFree( d__mu ) );
  HANDLE_ERROR( cudaFree( d__xi ) );
  HANDLE_ERROR( cudaFree( d__b ) );
  HANDLE_ERROR( cudaFree( d__c ) );
  free(psd);		
  free(cov);		
  free(mu);		
  free(xi);		
}
@
The parameters of the [[aaStats]] structure are:
<<aaStats parameters>>=
int N, N2, NU, NU2, NF, NF2, psd_size, cov_size, ind_size;
float2 *d__cov, *d__psd, *psd, *cov, *d__b, *d__c;
float *d__alpha, *d__beta;
unsigned int *d__mu, *d__xi, *mu, *xi;
cufftHandle plan, raster_plan, MVM_plan;
@ 
The power spectrum  must be sampled such as its Fourier transform gives unbiased values of the covariance.
The largest spatial frequency is $f_{max}=\kappa/2d$ with $\kappa\ge 1$.
The number of sample is given by $[[N_F]]\ge [[N_SIDE_LENSLET]]$.
The spatial frequencies are given by
\begin{eqnarray}
  \label{eq:6}
  f_{x,y} &=& (i,j){2\over [[NF]] }{\kappa\over 2d}, (i,j) \in \left[ 0,\dots,[[NF]]/2-1\right] \\
  f_{x,y} &=& (i,j){2\over [[NF]] }{\kappa\over 2d}, (i,j) \in \left[ [[NF]]/2,\dots,[[NF]]-1\right] 
\end{eqnarray}
Note that [[NF]] must be even.
<<power spectrum>>=
dim3 blockDim(16,16);
dim3 gridDim( 1+NF/16 , 1+NF/16 );
powerSpectrum LLL gridDim,blockDim RRR (d__psd, NF, lenslet_pitch, 
					atm->wavelength, atm->r0, atm->turbulence.L0,
					d__alpha, d__alpha, kappa);
powerSpectrum LLL gridDim,blockDim RRR (d__psd + NF2, NF, lenslet_pitch,
					atm->wavelength, atm->r0, atm->turbulence.L0,
					d__alpha, d__beta, kappa);
powerSpectrum LLL gridDim,blockDim RRR (d__psd + NF2*2, NF, lenslet_pitch,
					atm->wavelength, atm->r0, atm->turbulence.L0,
					d__beta, d__alpha, kappa);
powerSpectrum LLL gridDim,blockDim RRR (d__psd + NF2*3, NF, lenslet_pitch,
					atm->wavelength, atm->r0, atm->turbulence.L0,
					d__beta, d__beta, kappa);
@ The power spectrum is computed with the following kernel:
<<power spectrum kernel>>=
  __global__ void powerSpectrum(float2 *d__psd, int NF, float d,
				float wavelength, float r0, float L0,
				float *alpha, float *beta, float kappa)
{
  int i, j, k;
  float fx, fy, f_square, fs;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  k = i*NF + j;
  if ( (i<NF) && (j<(NF)) ) {
    fx = (float) i;
    fy = (float) j;
    if (i>=(NF/2))
      fx = fx - NF;
    if (j>=(NF/2))
      fy = fy - NF;
    fs = (2.0/NF)*(kappa/2*d);
    fx *= fs;
    fy *= fs;
    k = i*NF + j;
    f_square = fx*fx + fy*fy;
    wavelength *= wavelength;
    fs *= fs;
    d__psd[k].x = fs*wavelength*(fx*alpha[0] + fy*alpha[1])*(fx*beta[0] + fy*beta[1])*
      powf(r0,-5.0/3.0)*
      phasePowerSpectrum(f_square, 1.0/L0)*
      gatePSF(fx*d,fy*d);
    d__psd[k].y = 0;
  }
}
@ 
The phase power spectrum is given by:
<<phase power spectrum>>=
 __device__ float phasePowerSpectrum(float f_square, float f0) {
  return 0.0229*powf(f_square + f0*f0,-11.0/6.0);
}
@ 
The subaperture Fourier transform is written in
<<subaperture PSF>>=
__device__ float gatePSF(float fx, float fy) {
  float out;
  out = sinc(fx)*sinc(fy);
  return out*out;
}
@ that depends on the $sinc$ function:
<<sinc>>=
__device__ float sinc(float x) {
  return (x==0) ? 1.0 : sinf( PI*x) / (PI*x) ; 
}
@ 
The covariance derived from the power spectrum is sampled every $\rho_s=d/\kappa$.
The covariance derived from the slopes of the lenslet array is sampled every $d$.
Consequently the lenslet--array--slope--covariance is extracted from the power--spectrum--covariance at $(i\kappa,j\kappa)$.
Due to the symmetry of the Fourier transform output, the subscripts in the power--spectrum--covariance are in fact given by
\begin{eqnarray}
  \label{eq:8}
  (i,j)\kappa, (i,j) \in \left[ 0,\dots,[[N]]-1 \right] \\
  \left[(i,j)-[[NU]]\right]\kappa + [[NF]], (i,j) \in \left[ [[N]],\dots,[[NU]]-1 \right]
\end{eqnarray}

The lenslet--array--slope--covariance is shifted such as the baseline coordinate $(0,0$) is a the center of the array i.e.
\begin{equation}
  \label{eq:7}
  (i,j) \leftarrow \left[ (i,j) + (2[[N]]-2)/2 \right] \mod ( 2[[N]]-1 )
\end{equation}
<<covariance>>=
if (cufftExecC2C(plan, d__psd, d__psd, CUFFT_FORWARD) 
    != CUFFT_SUCCESS){
  fprintf(stderr,"CUFFT Error: Unable to execute plan\n");
 }
if (cudaThreadSynchronize() != cudaSuccess){
  fprintf(stderr, "Cuda error: Failed to synchronize\n");
 }
blockDim = dim3(16,16);
gridDim = dim3( 1+NU/16 , 1+NU/16 );
covariance_extraction LLL gridDim,blockDim RRR( d__cov, NU, d__psd, NF, kappa);
covariance_extraction LLL gridDim,blockDim RRR( d__cov + NU2, NU, d__psd + NF2, NF, kappa);
covariance_extraction LLL gridDim,blockDim RRR( d__cov + 2*NU2, NU, d__psd + 2*NF2, NF, kappa);
covariance_extraction LLL gridDim,blockDim RRR( d__cov + 3*NU2, NU, d__psd + 3*NF2, NF, kappa);
@ The extraction of the covariance is done with the kernel:
<<covariance extraction>>=
__global__ void covariance_extraction(float2 *cov_out, int NC_out, 
				      float2 *cov_in, int NC_in, float kappa)
{
  int i, j, k_out, k_in, h;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  if ( (i<NC_out) && (j<(NC_out)) ) {
    h = (NC_out-1)/2;
    k_out = ((i+h)%NC_out)*NC_out + (j+h)%NC_out;
    if (i>=((NC_out+1)/2))
      i = kappa*(i - NC_out) + NC_in;
    else
      i *= kappa;
    if (j>=(NC_out+1)/2)
      j = kappa*(j - NC_out) + NC_in;
    else
      j *= kappa;
    k_in = i*NC_in + j;      
    cov_out[k_out].x = cov_in[k_in].x;
    cov_out[k_out].y = 0.0;
  }
}
@ 
The 1D Fourier transform is now applied to the raster covariance
<<raster covariance FT>>=
if (cufftExecC2C(raster_plan, d__cov, d__cov, CUFFT_FORWARD) 
    != CUFFT_SUCCESS){
  fprintf(stderr,"CUFFT Error: Unable to execute plan\n");
 }
if (cudaThreadSynchronize() != cudaSuccess){
  fprintf(stderr, "Cuda error: Failed to synchronize\n");
 }
@ 
The multiplication $Cs$ are efficiently performed as follows
\begin{enumerate}
\item Construct polynomials $C(t)$ and $s(t)$ from the matrix $C$ and the vector $s$:
  \begin{equation}
    \label{eq:33}
    C(t) = \sum_{i_1=-(N_l-1)}^{N_l-1}\sum_{i_2=-(N_l-1)}^{N_l-1} c_{{i_1}{i_2}}t^{\lambda_{{i_1}{i_2}}},
  \end{equation}
where $c_{{i_1}{i_2}}$ is an entry of $C$ and $\lambda_{{i_1}{i_2}}=(N_l+i_1-1)(2N_l-1)+(N_l+i_2-1)$ and
\begin{equation}
  \label{eq:34}
    S(t) = \sum_{j_1=1}^{N_l}\sum_{j_2=1}^{N_l} s_{{j_1}{j_2}}t^{\mu_{{j_1}{j_2}}},  
\end{equation}
where $\mu_{{j_1}{j_2}}=2N_l(N_l-1)-j_1(2N_l-1)-j_2$.
\item Compute $P(t)=C(t)\times S(t)$ using the Discrete Fourier Transform.
\item The entry $b_{{j_1}{j_2}}$ of the vector $b$ is $b_{{j_1}{j_2}}=p_{\xi_{{j_1}{j_2}}}$, where $\xi_{{j_1}{j_2}}=2N_l(2N_l-1)-(j_1+1)(2N_l-1)-(j_2+1).$
\end{enumerate}
with $(j_1,j_2)\in [0,\dots,[[N]]-1]$.
<<ordering indices>>=
__global__ void ordering(unsigned int *mu, unsigned int *xi, int n)
{
  int j1, j2, k;
  j1 = blockIdx.x * blockDim.x + threadIdx.x;
  j2 = blockIdx.y * blockDim.y + threadIdx.y;
  if ( (j1<n) && (j2<n) ) {
    k = j1*n + j2;
    mu[k] = 2*n*(n-1)-j1*(2*n-1)-j2;
    xi[k] = 2*n*(2*n-1) - (j1+1)*(2*n-1) - (j2+1);
  }
}
@ 
The MVM routine computes the matrix--to--vector multiplication $y=C_{\vec\alpha\cdot\vec\beta}s$.
<<matrix--to--vector multiplication>>=
void aaStats::MVM(float *y, float *x)
{
  <<MVM STEP 1: input ordering>>
  <<MVM STEP 2: input FT>>
  <<MVM STEP 3: Fourier domain multiplication>>
  <<MVM STEP 4: output FT>>
  <<MVM STEP 5: output ordering>>
}
@
The vector $s$ is made of 2 components of length [[N2]]: $$s= \left[
\begin{array}{c}
  s_x \\
  s_y
\end{array}
\right]
$$
and lets define another complex vector $b$ also made of two components but of length [[NU2]]: $$b=\left[
\begin{array}{c}
  b_x \\
  b_y
\end{array}
\right]
$$
The matrix--to--vector multiplication $y=C_{\vec\alpha\dot\vec\beta}s$ is derived through the following steps:
\begin{enumerate}
\item input allocation and ordering:
  \begin{itemize}
  \item the $s_x$ components of $s$ is allocated into the real
    part of the complex vector $b_x$ according to the ordering in
    vector $\mu$ i.e. $b_x[\mu].x=s_x$,
  \item the $s_y$ components of $s$ is allocated into the real part of
    the complex vector $b_y$ according to the ordering in vector $\mu$
    i.e. $b_y[\mu].x=s_y$,
  \end{itemize}
<<MVM STEP 1: input ordering>>=
dim3 blockDim(256,1);
dim3 gridDim( 1+NU2/256,1);
mvm_input_order LLL gridDim,blockDim RRR (d__b      , NU2, x     , N2, d__mu);
mvm_input_order LLL gridDim,blockDim RRR (d__b + NU2, NU2, x + N2, N2, d__mu);
@  using the kernel:
<<MVM input ordering kernel>>=
__global__ void mvm_input_order(float2 *x_out, int n_x_out, 
                                float *x_in, int n_x_in, 
                                unsigned int *ind) 
{
  int k;
  k = blockIdx.x * blockDim.x + threadIdx.x;
  if (k<n_x_out) {
    x_out[k].x = 0.0;
    x_out[k].y = 0.0;
  }
  __syncthreads();
  if (k<n_x_in) {
    x_out[ind[k]].x = x_in[k];
  }
}
@ 
\item the Fourier transform of $b_{(x,y)}$ is computed i.e. $\tilde b_{(x,y)}=\mathcal F [b_{(x,y)}]$,
<<MVM STEP 2: input FT>>=
if (cufftExecC2C(MVM_plan, d__b, d__b, CUFFT_FORWARD) 
    != CUFFT_SUCCESS){
  fprintf(stderr,"CUFFT Error: Unable to execute plan forward FT with MVM plan\n");
 }
 HANDLE_ERROR( cudaThreadSynchronize() );
@
\item $\tilde b$ and $\tilde T$ are multiplied element wise i.e. 
$$\tilde c = \tilde b\tilde T =
\left[
\begin{array}{c}
  \tilde b_x.x\tilde T_{xx}.x - \tilde b_x.y\tilde T_{xx}.y + \tilde b_y.x\tilde T_{xy}.x - \tilde b_y.y\tilde T_{xy}.y \\
  \tilde b_x.x\tilde T_{xx}.y + \tilde b_x.y\tilde T_{xx}.x + \tilde b_y.x\tilde T_{xy}.y + \tilde b_y.y\tilde T_{xy}.x 
\end{array}
\right]
$$
<<MVM STEP 3: Fourier domain multiplication>>=
cpx_mult LLL gridDim,blockDim RRR (d__c      , d__cov        , d__b, NU2);
cpx_mult LLL gridDim,blockDim RRR (d__c + NU2, d__cov + 2*NU2, d__b, NU2);
@ 
using the kernel:
<<MVM complex multiplication>>=
 __global__ void cpx_mult(float2* c, float2 *x1, float2*x2, int n_x) {
  int k, l;
  k = blockIdx.x * blockDim.x + threadIdx.x;
  if (k<n_x) {
    c[k].x  = x1[k].x*x2[k].x - x1[k].y*x2[k].y;
    c[k].y  = x1[k].x*x2[k].y + x1[k].y*x2[k].x;
    l = k + n_x;
    c[k].x += x1[l].x*x2[l].x - x1[l].y*x2[l].y;
    c[k].y += x1[l].x*x2[l].y + x1[l].y*x2[l].x;
  }
}
@ 
\item the inverse Fourier transform of $\tilde c$ is computed i.e. $c=\mathcal F^{-1} [\tilde c]$,
<<MVM STEP 4: output FT>>=
if (cufftExecC2C(MVM_plan, d__c, d__c, CUFFT_INVERSE) 
    != CUFFT_SUCCESS){
  fprintf(stderr,"CUFFT Error: Unable to execute inverse FT with MVM plan\n");
 }
 HANDLE_ERROR( cudaThreadSynchronize() );
@
\item the real part of $c$ is affected into vector $y$ according to the ordering in vector $\xi$ i.e. $y=c[\xi].x$.
<<MVM STEP 5: output ordering>>=
blockDim = dim3(256,1);
gridDim  = dim3( 1+N2/256,1);
mvm_output_order LLL gridDim,blockDim RRR (y     , N2, d__c      , NU2, d__xi);
mvm_output_order LLL gridDim,blockDim RRR (y + N2, N2, d__c + NU2, NU2, d__xi);
@  using the kernel:
<<MVM output ordering kernel>>=
__global__ void mvm_output_order(float *x_out, int n_x_out, 
                                float2 *x_in, int n_x_in, 
                                unsigned int *ind) 
{
  int k;
  k = blockIdx.x * blockDim.x + threadIdx.x;
  if (k<n_x_out) {
    x_out[k] = x_in[ind[k]].x/n_x_in;
  }
}
@ \end{enumerate}
The test routine is written:
<<aaStats.bin>>=

#include "ceo.h"
#include "aaStats.h"

#define N 40
#define NX (N*N*2)

int main( void) {
  atmosphere atm;
  aaStats C;
  int k, data_size;
  float altitude[] = {0},
        xi0[] = {1},
        wind_speed[] = {10},
  	wind_direction[] = {0};
  float x[NX], y[NX], *d__x, *d__y;
  data_size = sizeof(float)*NX;
  HANDLE_ERROR( cudaMalloc((void**)&d__x, data_size ) );
  HANDLE_ERROR( cudaMalloc((void**)&d__y, data_size ) );
  atm.setup(0.15,30,altitude,xi0,wind_speed,wind_direction);
  C.setup(N,&atm,1);

  for (k=0;k<NX;k++) {
    x[k] = (float)k;
  }
  HANDLE_ERROR( cudaMemcpy( d__x, x, data_size, cudaMemcpyHostToDevice) );
  stopwatch tid;
  tid.tic();
  C.MVM(d__y,d__x);
  tid.toc();
  /* HANDLE_ERROR( cudaMemcpy( y, d__y, data_size, cudaMemcpyDeviceToHost) ); */
  /* printf("\nMVM:\n"); */
  /* for (k=0;k<NX;k++) { */
  /*   printf("(%2d) %4.2E\n",k,y[k]); */
  /* } */

  atm.cleanup();
  C.cleanup();
  HANDLE_ERROR( cudaFree( d__x ) );
  HANDLE_ERROR( cudaFree( d__y ) );

}
