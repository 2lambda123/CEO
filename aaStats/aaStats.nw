% -*- mode: Noweb; noweb-code-mode: c-mode -*-
@
[[aaStats]] contains a structure and the routines to compute the covariance matrix of the angle--of--arrival.

\subsection{The files}

\subsubsection{Header}

<<aaStats.h>>=
#ifndef __AASTATS_H__
#define __AASTATS_H__

#ifndef __CEO_H__
#include "ceo.h"
#endif

#ifndef __ATMOSPHERE_H__
#include "atmosphere.h"
#endif

//#define AASTATS_DEBUG
//#define PASTATS_DEBUG

<<aaStats structure>>

<<paStats stucture>>
@ 
The structures are :
<<aaStats structure>>=
struct aaStats {

  <<aaStats parameters>>

  void setup(int N, atmosphere *atm, float lenslet_pitch, source *src, int N_SRC);

  void cleanup(void);

  void info(int kappa, float d);

  float variance(void);

  void toFile(char *filename);
};
@  and
<<paStats stucture>>=
struct paStats {

  <<paStats parameters>>

  void setup(int N, int osf, atmosphere *atm, float lenslet_pitch, 
	     source *phase_src, int N_P_SRC, source *slopes_src, int N_S_SRC);

  void setup(int M_, int N_, int osf_, atmosphere *atm, float lenslet_pitch, 
	     source *phase_src, int N_P_SRC, source *slopes_src, int N_S_SRC);

  void cleanup(void);

  void info(int kappa, float d);

  /*
  void MVM(float *in_vector, float *out_vector, 
	   float d1, float g1, int N1, 
	   float d2, float g2, int N2);
  */
  void MVM(float *out_vector, float *in_vector, 
	   float d1, float g1, int N1, 
	   float d2, int N2,
	   atmosphere *atm,
	   source *phase_src, int N_P_SRC,
	   source *slopes_src, int N_S_SRC) ;

  void toFile(char *filename);

  void variance(void);

};
#endif // __AASTATS_H__
@ 
\subsubsection{Source}

<<aaStats.cu>>=
#include "aaStats.h"

<<sinc>>

<<subaperture FT>>
<<subaperture PSF>>

<<phase power spectrum>>

<<aaStats power spectrum kernel>>

<<paStats power spectrum kernel with sources (same heights)>>
<<paStats power spectrum kernel with sources (same heights,rect.)>>
<<paStats power spectrum kernel with sources>>

<<covariance extraction>>
<<PA covariance extraction>>

<<aaStats setup>>

<<paStats setup I>>
<<paStats setup II>>

<<save aa covariance to file>>
<<save pa covariance to file>>

<<aaStats cleanup>>
<<paStats cleanup>>

<<aaStats info>>
<<paStats info>>

<<2D interpolation>>
<<2D interpolation kernel>>
<<matrix-to-vector product kernel>>
<<matrix-to-vector product>>

<<aaStats variance>>
@
\subsection{The theory}

Shack--Hartmann WFS centroids are a measure of the spatial derivatives of the wavefront averaged on each subaperture.
These derivatives are often referred as angle of arrivals $\vec \alpha=(\alpha_x\alpha_y,)$:
\begin{eqnarray}
  \label{eq:1}
  \alpha_x &=& {\lambda\over 2\pi d^2} {\partial\varphi\over\partial x} \ast \Pi\left(x\over d\right)\Pi\left(y\over d\right),\\
  \alpha_y &=& {\lambda\over 2\pi d^2} {\partial\varphi\over\partial y} \ast \Pi\left(x\over d\right)\Pi\left(y\over d\right),
\end{eqnarray}
where $\lambda$ is the sensing wavelength and $d$ in the size of one subaperture.

The covariance is derived from the power spectrum density of the angle of arrivals $W_{\vec \alpha \cdot\ \vec \beta}(\vec f)$:
  \begin{equation}
    \label{eq:2}
    W_{\vec \alpha\cdot\vec \beta}(\vec f) = \lambda^2\left( \vec f \cdot \vec\alpha \right)\left( \vec f \cdot \vec\beta \right) W_\varphi(\vec f) G^2(\vec f)
  \end{equation}
$W_\varphi(f)$ is the wavefront power spectrum density given by
\begin{equation}
  \label{eq:3}
  W_\varphi(f) = 0.0229 r_0^{-5/3} \left( f^2 + {1\over\mathcal L_0^2} \right)^{-11/6}.
\end{equation}
$G(\vec f)$ is the point spread function of a subaperture of the WFS,
\begin{equation}
  \label{eq:4}
  G(\vec f) = {\sin(\pi d f_x) \over \pi d f_x }{ \sin(\pi d f_y) \over \pi d f_y } .
\end{equation}

The covariance $C_{\vec \alpha \cdot\ \vec \beta}(\vec\rho)$ is derived from the Wiener--Khinchine theorem:
\begin{equation}
  \label{eq:5}
  C_{\vec \alpha \cdot\ \vec \beta}(\vec\rho) = \mathcal F^{-1} \left[ W_{\vec \alpha\cdot\vec \beta}(\vec f) \right] (\vec\rho)
\end{equation}
where $\mathcal F^{-1}$ stands for the inverse Fourier transform.

The covariance between $\varphi$ and $\vec \alpha$ is derived from the cross--power spectrum density given by:
  \begin{equation}
    \label{eq:6}
    W_{\varphi\vec \alpha}(\vec f) = -\iota\lambda\left( \vec f \cdot \vec\alpha \right) W_\varphi(\vec f) G(\vec f)
  \end{equation}
$W_\varphi(f)$ is the wavefront power spectrum density given by
\begin{equation}
  \label{eq:7}
  W_\varphi(f) = 0.0229 r_0^{-5/3} \left( f^2 + {1\over\mathcal L_0^2} \right)^{-11/6}.
\end{equation}
$G(\vec f)$ is the point spread function of a subaperture of the WFS,
\begin{equation}
  \label{eq:8}
  G(\vec f) = {\sin(\pi d f_x) \over \pi d f_x }{ \sin(\pi d f_y) \over \pi d f_y } .
\end{equation}

The covariance $C_{\varphi \vec \alpha}(\vec\rho)$ is derived from the Wiener--Khinchine theorem:
\begin{equation}
  \label{eq:9}
  C_{\varphi \vec \alpha}(\vec\rho) = \mathcal F^{-1} \left[ W_{\varphi\vec \alpha}(\vec f) \right] (\vec\rho)
\end{equation}
where $\mathcal F^{-1}$ stands for the inverse Fourier transform.

\subsection{Functions}
\label{sec:functions}

\subsubsection{Angle--of--arrival covariance matrix}
\label{sec:angle-arriv-covar}

The covariance matrix is computed for a square lenslet array of size $[[N]]\times[[N]]$ and of pitch [[sampling]].
The covariance matrix depends on the atmosphere parameters and altitude profile.
The covariance matrix is computed for a vector of [[N_SRC]] sources.
The covariance matrix is written:
\begin{eqnarray}
  \label{eq:11}
  \Theta = \left[
    \begin{array}{ccc}
      \Theta_{11}&\cdots&\Theta_{1[[N_SRC]]} \\
      \vdots    &\ddots & \vdots \\
      \Theta_{[[N_SRC]]1} & \vdots & \Theta_{[[N_SRC]][[N_SRC]]}
    \end{array}
\right]
\end{eqnarray}
with
\begin{eqnarray}
  \label{eq:12}
  \Theta_{ij} = \left[
    \begin{array}{cc}
      \Theta_{{x_i}{x_j}} & \Theta_{{x_i}{y_j}} \\
      \Theta_{{y_i}{x_j}} & \Theta_{{y_i}{y_j}} 
    \end{array}
\right].
\end{eqnarray}
Each matrix $\Theta_{{x_i}{x_j}}$ is a two--level recursive block Toeplitz (2RBT) $[[N]]^2\times[[N]]^2$ matrix.
Toeplitz matrices \cite{GolubVanLoan} are fully defined with their first row and column. 
So the matrix $\Theta_{{x_i}{x_j}}$ is reduced to a $[[NU]]=(2[[N]]-1)^2$ elements vector $t_\Theta^{{x_i}{x_j}}$ and the matrix $\Theta_{ij}$ becomes the matrix
\begin{equation}
  \label{eq:13}
  T_{ij} = \left[ t_\Theta^{{x_i}{x_j}} t_\Theta^{{x_i}{y_j}} t_\Theta^{{y_i}{x_j}} t_\Theta^{{y_i}{y_j}} \right].
\end{equation}
Finally the Toeplitz compressed version of the matrix $\Theta$ is written:
\begin{equation}
  \label{eq:14}
  T = \left[ t_\Theta^{{x_1}{x_1}} t_\Theta^{{x_1}{y_1}} \cdots t_\Theta^{{x_1}{x_[[N_SRC]]}} t_\Theta^{{x_1}{y_[[N_SRC]]}} 
  \cdots t_\Theta^{{y_[[N_SRC]]}{x_1}} t_\Theta^{{y_[[N_SRC]]}{y_1}} \cdots t_\Theta^{{y_[[N_SRC]]}{x_[[N_SRC]]}} t_\Theta^{{y_[[N_SRC]]}{y_[[N_SRC]]}} \right].
\end{equation}

<<aaStats setup>>=
void aaStats::setup(int N_, atmosphere *atm, float lenslet_pitch, 
		    source *src, int N_SRC)
{
  N_SRC2 = N_SRC*N_SRC;
  int BATCH = 1;
  <<aaStats setup declarations>>
  psd_size = sizeof(float2)*NF2;
  <<aaStats setup allocations>>
  stopwatch tid;
  tid.tic();
  <<aaStats evaluate covariance>>
  tid.toc(&cov_eval_et,"AA covariance evaluation");
  info(kappa, sampling);
}
@
The parameters of the [[aaStats]] structure are:
<<aaStats parameters>>=
int N, N2, NU, NU2, NF, NF2, psd_size, cov_size, ind_size;
float2 *d__psd;
float *d__cov, *d__alpha, *d__beta, n_full, n_comp, b_full, b_comp, cov_eval_et, sampling;
cufftHandle plan;
#if defined(AASTATS_DEBUG) || defined(PASTATS_DEBUG)
float2 *psd, *cov;
#endif
int N_SRC2;
@ The parameters are initialized in the setup function:
<<aaStats setup declarations>>=
float alpha[2] = {1,0}, beta[2] = {0,1}, kappa; 
N = N_;
N2 = N*N;
NU = 2*N-1;
NU2 = NU*NU;
NF = 4096;
NF2 = NF*NF;
kappa = 4;
sampling = lenslet_pitch;

psd_size = sizeof(float2)*NF2*4;
cov_size = sizeof(float)*NU2*4*N_SRC2;
ind_size = sizeof(int)*N2;
@ where the memory is also allocated:
<<aaStats setup allocations>>=
HANDLE_ERROR( cudaMalloc((void**)&d__psd, psd_size ) );
HANDLE_ERROR( cudaMalloc((void**)&d__alpha, 2*sizeof(float) ) );
HANDLE_ERROR( cudaMalloc((void**)&d__beta,  2*sizeof(float) ) );
HANDLE_ERROR( cudaMemcpy( d__alpha, alpha, 2*sizeof(float), 
			  cudaMemcpyHostToDevice) );
HANDLE_ERROR( cudaMemcpy( d__beta, beta, 2*sizeof(float), 
			  cudaMemcpyHostToDevice) );
HANDLE_ERROR( cudaMalloc((void**)&d__cov, cov_size ) );

fprintf(stderr,"@(CEO)>aaStats: Creating 2D covariance FFT plan\n");
int n_DFT[2] = {NF, NF};
int iodist = NF2;
/* Create a 2D FFT plan. */
HANDLE_ERROR_CUFFT(cufftPlanMany(&plan, 2, n_DFT,
				 NULL, 1, iodist,
				 NULL, 1, iodist,
				 CUFFT_C2C,BATCH), 
		   "Unable to create plan");
HANDLE_ERROR_CUFFT(cufftSetCompatibilityMode(plan, CUFFT_COMPATIBILITY_NATIVE),
		   "Unable to set compatibility mode to native");
@  
The covariance is derived from Eq.~(\ref{eq:5}) for 2 sources in the directions $\vec\theta_1$ and $\vec\theta_2$ propagated through a [[N_LAYER]] atmospheric profile.
It is given by
\begin{equation}
  \label{eq:15}
  C_{\vec \alpha \cdot\ \vec \beta}^{12}(\vec\rho) = \sum_{l=1}^{[[N]]} C_{\vec \alpha \cdot\ \vec \beta}^l(\vec\rho_l)
\end{equation}
where
\begin{equation}
  \label{eq:16}
  \vec \rho_l = \gamma_l\vec\rho + h_l(\vec\theta_2-\vec\theta_1)
\end{equation}
with $\gamma_l=1-h_l/z_\ast$, $h_l$ is the atmosphere layer altitude and $z_\ast$ is the sources height.
Invoking the Wiener--Khinchine theorem, the translation and scaling properties of the Fourier transform and using Eq.~(\ref{eq:2}), the covariance for a single atmospheric layer at altitude $h_l$ is written:
\begin{equation}
  \label{eq:17}
  C_{\vec \alpha \cdot\ \vec \beta}^{12,l}(\vec\rho_l) = \mathcal F^{-1} \left[ \lambda^2 \left( \vec f \cdot \vec\alpha \right)\left( \vec f \cdot \vec\beta \right) W_\varphi(\vec f) G^2(\gamma_l\vec f) \exp\left( 2\iota\pi h_l\vec f \cdot (\vec\theta_2-\vec\theta_1) \right)  \right] (\gamma_l\vec\rho)
\end{equation}
Setting
\begin{equation}
  \label{eq:18}
  W_{\vec \alpha\cdot\vec \beta}^{l,12}(\vec f) = \lambda^2 \left( \vec f \cdot \vec\alpha \right)\left( \vec f \cdot \vec\beta \right) W_\varphi(\vec f) G^2(\gamma_l\vec f) \exp\left( 2\iota\pi h_l\vec f \cdot (\vec\theta_2-\vec\theta_1) \right),
\end{equation}
Eq.~(\ref{eq:15}) is now given by
\begin{equation}
  \label{eq:19}
  C_{\vec \alpha \cdot\ \vec \beta}^{12}(\vec\rho) = \sum_{l=1}^{[[N]]} \mathcal F^{-1} \left[ W_{\vec \alpha\cdot\vec \beta}^{l,12}(\vec f) \right] (\gamma_l\vec\rho).
\end{equation}
Calling $\delta=d/\kappa$ the sampling step of the vector $\vec\rho$ with the integer $\kappa\geq 1$, $\vec\rho_l$ is given by
\begin{equation}
  \label{eq:20}
  \vec \rho_l = \gamma_l\delta(k\vec x + l\vec y),\quad\forall l,k\in \left[0,\cdots,[[NF]]-1\right],
\end{equation}
$\vec x$ and $\vec y$ are the unit vectors of the X and Y axis, respectively.
Eq.~(\ref{eq:19}) becomes
\begin{equation}
  \label{eq:21}
   C_{\vec \alpha \cdot\ \vec \beta}^{12}(k,l) = \sum_{l=1}^{[[N]]} \iint {\mathrm d^2}\vec f W_{\vec \alpha\cdot\vec \beta}^{l,12}(\vec f) \exp\left( 2\iota\pi \gamma_l \delta (k f_x + l f_y) \right)
\end{equation}
Discretizing Eq.~(\ref{eq:21}) with
\begin{equation}
  \label{eq:22}
  \gamma_l\delta f_x = n/[[NF]],\quad \gamma_l\delta f_y = m/[[NF]],\quad \forall n,m\in \left[0,\cdots,[[NF]]-1\right],
\end{equation}
Eq.~(\ref{eq:21}) is transformed into 
\begin{eqnarray}
  \label{eq:23}
   C_{\vec \alpha \cdot\ \vec \beta}^{12}(k,l) &=& \sum_{l=1}^{[[N]]} \sum_{n=0}^{[[NF]]-1} \sum_{m=0}^{[[NF]]-1} \left( 1\over\gamma_l\delta [[NF]]\right)^2 W_{\vec \alpha\cdot\vec \beta}^{l,12}\left({n\over\gamma_l\delta [[NF]]},{m\over\gamma_l\delta [[NF]]}\right) \exp\left( 2\iota\pi {(k n + l m)\over [[NF]]} \right)  \\
&=& \sum_{n=0}^{[[NF]]-1} \sum_{m=0}^{[[NF]]-1} W_{\vec \alpha\cdot\vec \beta}^{12}(n,m) \exp\left( 2\iota\pi {(k n + l m)\over [[NF]]} \right)
\end{eqnarray}
with
\begin{equation}
  \label{eq:24}
  W_{\vec \alpha\cdot\vec \beta}^{12}(n,m) = \sum_{l=1}^{[[N]]} \left( 1\over\gamma_l\delta [[NF]]\right)^2 W_{\vec \alpha\cdot\vec \beta}^{l,12}\left({n\over\gamma_l\delta [[NF]]},{m\over\gamma_l\delta [[NF]]}\right)
\end{equation}

<<aaStats evaluate covariance>>=
dim3 blockDimPsd(16,16);
dim3 gridDimPsd( 1+NF/16 , 1+NF/16 );
dim3 blockDimCov(16,16);
dim3 gridDimCov( 1+NU/16 , 1+NU/16 );

int i_SRC, j_SRC, offset0, offset;
fprintf(stderr,"Covariance 4x4 block:\n");
for (i_SRC=0;i_SRC<N_SRC;i_SRC++) {

  offset0 = 4*N_SRC*i_SRC;

  for (j_SRC=0;j_SRC<N_SRC;j_SRC++) {

    fprintf(stderr," [%d,%d]",i_SRC,j_SRC);

    offset = offset0 + 2*j_SRC;
    fprintf(stderr,"(%2d",offset);
    aaPowerSpectrum LLL gridDimPsd,blockDimPsd RRR (
                    d__psd, NF, lenslet_pitch, 
                    atm->wavelength, atm->r0, atm->turbulence.L0,
                    atm->d__turbulence,
		    (src->dev_ptr) + i_SRC, (src->dev_ptr) + j_SRC,
                    d__alpha, d__alpha, kappa);
    <<AA covariance with Wiener-Khinchin>>
    <<AA covariance reduction>>

    offset = offset0 + (2*j_SRC+1);
    fprintf(stderr,",%2d",offset);
    aaPowerSpectrum LLL gridDimPsd,blockDimPsd RRR (
                    d__psd, NF, lenslet_pitch, 
                    atm->wavelength, atm->r0, atm->turbulence.L0,
                    atm->d__turbulence,
		    (src->dev_ptr) + i_SRC, (src->dev_ptr) + j_SRC,
                    d__alpha, d__beta, kappa);
    <<AA covariance with Wiener-Khinchin>>
    <<AA covariance reduction>>

    offset = offset0 + 2*(N_SRC+j_SRC);
    fprintf(stderr,",%2d",offset);
    aaPowerSpectrum LLL gridDimPsd,blockDimPsd RRR (
                    d__psd, NF, lenslet_pitch, 
                    atm->wavelength, atm->r0, atm->turbulence.L0,
                    atm->d__turbulence,
		    (src->dev_ptr) + i_SRC, (src->dev_ptr) + j_SRC,
                    d__beta, d__alpha, kappa);
    <<AA covariance with Wiener-Khinchin>>
    <<AA covariance reduction>>

    offset = offset0 + (2*(N_SRC+j_SRC)+1);
    fprintf(stderr,",%2d)",offset);
    aaPowerSpectrum LLL gridDimPsd,blockDimPsd RRR (
                    d__psd, NF, lenslet_pitch, 
                    atm->wavelength, atm->r0, atm->turbulence.L0,
                    atm->d__turbulence,
		    (src->dev_ptr) + i_SRC, (src->dev_ptr) + j_SRC,
                    d__beta, d__beta, kappa);
    <<AA covariance with Wiener-Khinchin>>
    <<AA covariance reduction>>
	}
  fprintf(stderr,"\n");
 }

@ 
The Wiener-Khinchin is applied on the power spectrum with the following:
<<AA covariance with Wiener-Khinchin>>=
HANDLE_ERROR_CUFFT(cufftExecC2C(plan, d__psd, d__psd, CUFFT_FORWARD),
		   "Unable to execute plan");
HANDLE_ERROR(cudaThreadSynchronize());
@ 
The power spectrum, given by Eq.~(\ref{eq:24}) and Eq.~(\ref{eq:18}), must be sampled such as its Fourier transform gives unbiased values of the covariance.
The largest spatial frequency is $f_{max}=\kappa/2\gamma_l\delta$ with $\kappa\ge 1$.
The numyber of sample is given by $[[N_F]]\ge [[N_SIDE_LENSLET]]$.
The spatial frequencies are given by
\begin{eqnarray}
  \label{eq:6}
  f_{x,y} &=& (i,j){2\over [[NF]] }{\kappa\over 2\gamma_l\delta}, (i,j) \in \left[ 0,\dots,[[NF]]/2-1\right] \\
  f_{x,y} &=& (i,j){2\over [[NF]] }{\kappa\over 2\gamma_l\delta}, (i,j) \in \left[ [[NF]]/2,\dots,[[NF]]-1\right] 
\end{eqnarray}
Note that [[NF]] must be even.
<<aaStats power spectrum kernel>>=
__global__ void aaPowerSpectrum(float2 *d__psd, int NF, float d,
				float wavelength, float r0, float L0,
                                profile *turb, source *src1, source *src2,
				float *alpha, float *beta, float kappa)
{
  int i, j, k;
  float fx, fy, f_square, fs, gl, red, c_red, s_red;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  k = i*NF + j;
  if ( (i<NF) && (j<(NF)) ) {
    k = i*NF + j;
    wavelength *= wavelength;
    d__psd[k].x = 0;
    d__psd[k].y = 0;
    for (int k_LAYER=0;k_LAYER<_N_LAYER_;k_LAYER++) {
      gl = (1-turb->altitude[k_LAYER]/src1->height);
      red = 2*PI*turb->altitude[k_LAYER];
      fs = (2.0/NF)*(kappa/(2*d*gl));
      fx = (float) i;
      fy = (float) j;
      if (i>=(NF/2))
	fx = fx - NF;
      if (j>=(NF/2))
      fy = fy - NF;
      fx *= fs;
      fy *= fs;
      f_square = fx*fx + fy*fy;
      fs *= fs;
      red *= fx*(src2->theta_x - src1->theta_x) + fy*(src2->theta_y - src1->theta_y);
      sincosf( red, &s_red, &c_red);
      red = (k==0) ? 0 : turb->xi0[k_LAYER]*
	fs*wavelength*(fx*alpha[0] + fy*alpha[1])*(fx*beta[0] + fy*beta[1])*
	powf(r0,-5.0/3.0)*
	phasePowerSpectrum(f_square, 1.0/L0)*
	gatePSF(gl*fx*d,gl*fy*d);
      d__psd[k].x += red*c_red;
      d__psd[k].y += red*s_red;
    }
  }
}
@ 
The covariance derived from the power spectrum is sampled every $\delta=d/\kappa$.
The covariance derived from the slopes of the lenslet array is sampled every $d$.
Consequently the lenslet--array--slope--covariance is extracted from the power--spectrum--covariance at $(i\kappa,j\kappa)$.
Due to the symmetry of the Fourier transform output, the subscripts in the power--spectrum--covariance are in fact given by
\begin{eqnarray}
  \label{eq:8}
  (i,j)\kappa, (i,j) \in \left[ 0,\dots,[[N]]-1 \right] \\
  \left[(i,j)-[[NU]]\right]\kappa + [[NF]], (i,j) \in \left[ [[N]],\dots,[[NU]]-1 \right]
\end{eqnarray}
The lenslet--array--slope--covariance is shifted such as the baseline coordinate $(0,0$) is a the center of the array i.e.
\begin{equation}
  \label{eq:7}
  (i,j) \leftarrow \left[ (i,j) + (2[[N]]-2)/2 \right] \mod ( 2[[N]]-1 )
\end{equation}
<<AA covariance reduction>>=
covariance_extraction LLL gridDimCov,blockDimCov RRR( d__cov + offset*NU2, NU,
						      d__psd, NF, kappa);
@ The extraction of the covariance is done with the kernel:
<<covariance extraction>>=
__global__ void covariance_extraction(float *cov_out, int NC_out, 
				      float2 *cov_in, int NC_in, float kappa)
{
  int i, j, k_out, k_in, h;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  if ( (i<NC_out) && (j<(NC_out)) ) {
    h = (NC_out-1)/2;
    k_out = (NC_out - 1 - (i+h)%NC_out)*NC_out + (NC_out - 1 - (j+h)%NC_out);
    if (i>=((NC_out+1)/2))
      i = kappa*(i - NC_out) + NC_in;
    else
      i *= kappa;
    if (j>=(NC_out+1)/2)
      j = kappa*(j - NC_out) + NC_in;
    else
      j *= kappa;
    k_in = i*NC_in + j;      
    cov_out[k_out] = cov_in[k_in].x;
  }
}

@ The main parameters of [[aaStats]] are displayed with the [[info]] routine:
<<aaStats info>>=
void aaStats::info(int kappa, float d)
{
  fprintf(stderr,"\n\x1B[1;42m@(CEO)>aaStats:\x1B[;42m\n");
  <<info content>>
  fprintf(stderr,"----------------------------------------------------\x1B[0m\n");
}
<<info content>>=
fprintf(stderr," . sampling [m]                   : %.2f\n",d);
fprintf(stderr," . size of covariance matrix block: %dX%d\n",NU,NU);
fprintf(stderr," . spectrum resolution            : %d\n",NF);
fprintf(stderr," . covariance oversampling factor : %d\n",kappa);
fprintf(stderr," . spectrum highest frequency     : %4.2E\n",(2.0/NF)*(kappa/(2*d)));

@ The memory is freed with the following routine: 
<<aaStats cleanup>>=
void aaStats::cleanup(void)
{
fprintf(stderr,"@(CEO)>aaStats: freeing memory!\n");
<<cleanup contents>>
}
<<cleanup contents>>=
cufftDestroy(plan);
HANDLE_ERROR( cudaFree( d__psd ) );
HANDLE_ERROR( cudaFree( d__alpha ) );
HANDLE_ERROR( cudaFree( d__beta ) );
HANDLE_ERROR( cudaFree( d__cov ) );
#ifdef AASTATS_DEBUG
free(psd);		
free(cov);		
#endif		

@ From the power spectrum, once can derive the variance:
<<aaStats variance>>=
float aaStats::variance(void) {
  float res;
  HANDLE_ERROR( cudaMemcpy( &res, d__cov + (N-1)*(NU+1),
			    sizeof(float), cudaMemcpyDeviceToHost) );
  return res;
}

@ The covariance can be written to a file with:
<<save aa covariance to file>>=
void aaStats::toFile(char *filename)
{
  dev2file(filename, d__cov, cov_size/sizeof(float));
}

@ 
\subsubsection{Phase and Angle--of--arrival covariance matrix}
\label{sec:phase-angle-arrival}

The covariance matrix is defined for a square lenslet array of size $N_L\times N_L$ and of pitch [[sampling]].
The covariance sampling is set with the over--sampling factor [[osf]]. 
The covariance matrix depends on the atmosphere parameters and altitude profile.
The covariance matrix is computed for vectors of [[N_P_SRC]] estimation sources and [[N_S_SRC]] guide star sources.
The covariance matrix is written:
\begin{eqnarray}
  \label{eq:11}
  \Xi = \left[
    \begin{array}{ccc}
      \Xi_{11}&\cdots&\Xi_{1[[N__S_SRC]]} \\
      \vdots    &\ddots & \vdots \\
      \Xi_{[[N_P_SRC]]1} & \vdots & \Xi_{[[N_P_SRC]][[N_S_SRC]]}
    \end{array}
\right]
\end{eqnarray}
with
\begin{eqnarray}
  \label{eq:12}
  \Xi_{ij} = \left[
    \begin{array}{cc}
      \Xi_{{\phi_i}{x_j}} & \Xi_{{\phi_i}{y_j}}
    \end{array}
\right].
\end{eqnarray}
Each matrix $\Xi_{{\phi_i}{x_j}}$ is a two--level recursive block Toeplitz (2RBT) $[[N]]^2\times[[N]]^2$ matrix with $[[N]]=N_L$ if $[[osf]]=1$ or $[[N]]=[[osf]] \times N_L+1$ if $[[osf]]\ge 1$.
Toeplitz matrices \cite{GolubVanLoan} are fully defined with their first row and column. 
So the matrix $\Xi_{{phi_i}{x_j}}$ is reduced to a $[[NU]]=(2[[N]]-1)^2$ elements vector $t_\Xi^{{\phi_i}{x_j}}$ and the matrix $\Xi_{ij}$ becomes the matrix
\begin{equation}
  \label{eq:13}
  T_{ij} = \left[ t_\Xi^{{\phi_i}{x_j}} t_\Xi^{{\phi_i}{y_j}} \right].
\end{equation}
Finally the Toeplitz compressed version of the matrix $\Xi$ is written:
\begin{equation}
  \label{eq:14}
  T = \left[ t_\Xi^{{\phi_1}{x_1}} t_\Xi^{{\phi_1}{y_1}} \cdots t_\Xi^{{\phi_1}{x_[[N_S_SRC]]}} t_\Xi^{{\phi_1}{y_[[N_S_SRC]]}} 
  \cdots t_\Xi^{{\phi_[[N_P_SRC]]}{x_1}} t_\Xi^{{\phi_[[N_P_SRC]]}{y_1}} \cdots t_\Xi^{{\phi_[[N_P_SRC]]}{x_[[N_S_SRC]]}} t_\Xi^{{\phi_[[N_P_SRC]]}{y_[[N_S_SRC]]}} \right].
\end{equation}

<<paStats setup I>>=
void paStats::setup(int N_, int osf_, atmosphere *atm, float lenslet_pitch, 
		      source *phase_src, int N_P_SRC, source *slopes_src, int N_S_SRC)
{
  N_SRC2 = N_P_SRC*N_S_SRC;
  float alpha[2] = {1,0}, beta[2] = {0,1}, kappa; 
  osf = osf_;
  N = (osf==1)? N=N_ : osf*N_+1;
  N2 = N*N;
  NU = 2*N-1;
  NU2 = NU*NU;
  NF = 4096;
  NF2 = NF*NF;
  kappa = 4;
  sampling = lenslet_pitch/osf;

  
  if (phase_src->height==slopes_src->height) {
    psd_size = sizeof(float2)*NF2;
    cov_size = sizeof(float)*NU2*2*N_SRC2;
    ind_size = sizeof(int)*N2;
    int BATCH = 1;

    <<paStats setup allocation>>

    stopwatch tid;
    tid.tic();
    <<paStats power spectrum with sources (same heights)>>
    tid.toc(&cov_eval_et,"PA covariance evaluation");
  }
  else {
    psd_size = sizeof(float2)*NF2;
    cov_size = sizeof(float)*NU2*2*_N_LAYER_*N_SRC2;
    ind_size = sizeof(int)*N2;
    int BATCH = 1;

    <<paStats setup allocation>>

    stopwatch tid;
    tid.tic();
    <<paStats power spectrum with sources (different heights)>>
    tid.toc(&cov_eval_et,"PA covariance evaluation");
  }

  info(kappa,sampling);
  
}
    
<<paStats setup II>>=
void paStats::setup(int M_, int N_, int osf_, atmosphere *atm, float lenslet_pitch, 
		    source *phase_src, int N_P_SRC, source *slopes_src, int N_S_SRC)
{
  N_SRC2 = N_P_SRC*N_S_SRC;
  float alpha[2] = {1,0}, beta[2] = {0,1}, kappa; 
  osf = osf_;
  N = N_;
  M = M_;
  N2 = M*N;
  NU = M+N-1;
  NU2 = NU*NU;
  NF = 4096;
  NF2 = NF*NF;
  kappa = 4;
  sampling = lenslet_pitch/osf;

  
  if (phase_src->height==slopes_src->height) {
    psd_size = sizeof(float2)*NF2;
    cov_size = sizeof(float)*NU2*2*N_SRC2;
    ind_size = sizeof(int)*N2;
    int BATCH = 1;

    <<paStats setup allocation>>

    stopwatch tid;
    tid.tic();
    <<paStats power spectrum with sources (same heights,rect.)>>
    tid.toc(&cov_eval_et,"PA covariance evaluation");
  }
  else {
    psd_size = sizeof(float2)*NF2;
    cov_size = sizeof(float)*NU2*2*_N_LAYER_*N_SRC2;
    ind_size = sizeof(int)*N2;
    int BATCH = 1;

    <<paStats setup allocation>>

    stopwatch tid;
    tid.tic();
    <<paStats power spectrum with sources (different heights)>>
    tid.toc(&cov_eval_et,"PA covariance evaluation");
  }

info(kappa,sampling);

}
@ 
The parameters of the [[paStats]] structure are:
<<paStats parameters>>=
int osf, M;
<<aaStats parameters>>
@ Memory is allocated with:
<<paStats setup allocation>>=
HANDLE_ERROR( cudaMalloc((void**)&d__psd, psd_size ) );
HANDLE_ERROR( cudaMalloc((void**)&d__alpha, 2*sizeof(float) ) );
HANDLE_ERROR( cudaMalloc((void**)&d__beta,  2*sizeof(float) ) );
HANDLE_ERROR( cudaMemcpy( d__alpha, alpha, 2*sizeof(float), cudaMemcpyHostToDevice) );
HANDLE_ERROR( cudaMemcpy( d__beta, beta, 2*sizeof(float), cudaMemcpyHostToDevice) );
HANDLE_ERROR( cudaMalloc((void**)&d__cov, cov_size ) );

fprintf(stderr,"\n@(CEO)>paStats: Creating 2D covariance FFT plan\n");
int n_DFT[2] = {NF, NF};
int iodist = NF2;
/* Create a 2D FFT plan. */
HANDLE_ERROR_CUFFT( cufftPlanMany(&plan, 2, n_DFT,
                                  NULL, 1, iodist,
                                  NULL, 1, iodist,
                                  CUFFT_C2C,BATCH),
                                  "Unable to create plan" );
HANDLE_ERROR_CUFFT( cufftSetCompatibilityMode(plan, CUFFT_COMPATIBILITY_NATIVE),
                    "Unable to set compatibility mode to native" );
@  
The covariance is derived from Eq.~(\ref{eq:5}) for 2 sources in the directions $\vec\theta_1$ and $\vec\theta_2$ propagated through a [[N_LAYER]] atmospheric profile.
It is given by
\begin{equation}
  \label{eq:15}
  C_{\varphi \vec \alpha}^{12}(\vec\rho) = \sum_{l=1}^{[[N]]} C_{\varphi \vec \alpha}^l(\vec\rho_l)
\end{equation}
where
\begin{equation}
  \label{eq:16}
  \vec \rho_l = \gamma_l\vec\rho + h_l(\vec\theta_2-\vec\theta_1)
\end{equation}
with $\gamma_l=1-h_l/z_\ast$, $h_l$ is the atmosphere layer altitude and $z_\ast$ is the sources height.
Invoking the Wiener--Khinchine theorem, the translation and scaling properties of the Fourier transform and using Eq.~(\ref{eq:2}), the covariance for a single atmospheric layer at altitude $h_l$ is written:
\begin{equation}
  \label{eq:17}
  C_{\varphi \vec \alpha}^{12,l}(\vec\rho_l) = \mathcal F^{-1} \left[ -\iota\lambda\left( \vec f \cdot \vec\alpha \right) W_\varphi(\vec f) G(\gamma_l \vec f) \exp\left( 2\iota\pi h_l\vec f \cdot (\vec\theta_2-\vec\theta_1) \right)  \right] (\gamma_l\vec\rho)
\end{equation}
Setting
\begin{equation}
  \label{eq:18}
  W_{\varphi \vec \alpha}^{l,12}(\vec f) = -\iota\lambda\left( \vec f \cdot \vec\alpha \right) W_\varphi(\vec f) G(\gamma_l \vec f) \exp\left( 2\iota\pi h_l\vec f \cdot (\vec\theta_2-\vec\theta_1) \right),
\end{equation}
Eq.~(\ref{eq:15}) is now given by
\begin{equation}
  \label{eq:19}
  C_{\varphi \vec \alpha}^{12}(\vec\rho) = \sum_{l=1}^{[[N]]} \mathcal F^{-1} \left[ W_{\varphi \vec \alpha}^{l,12}(\vec f) \right] (\gamma_l\vec\rho).
\end{equation}
Calling $\delta=d/\kappa$ the sampling step of the vector $\vec\rho$ with the integer $\kappa\geq 1$, $\vec\rho_l$ is given by
\begin{equation}
  \label{eq:20}
  \vec \rho_l = \gamma_l\delta(k\vec x + l\vec y),\quad\forall l,k\in \left[0,\cdots,[[NF]]-1\right],
\end{equation}
$\vec x$ and $\vec y$ are the unit vectors of the X and Y axis, respectively.
Eq.~(\ref{eq:19}) becomes
\begin{equation}
  \label{eq:21}
   C_{\varphi \vec \alpha}^{12}(k,l) = \sum_{l=1}^{[[N]]} \iint {\mathrm d^2}\vec f W_{\varphi \vec \alpha}^{l,12}(\vec f) \exp\left( 2\iota\pi \gamma_l \delta (k f_x + l f_y) \right)
\end{equation}
Discretizing Eq.~(\ref{eq:21}) with
\begin{equation}
  \label{eq:22}
  \gamma_l\delta f_x = n/[[NF]],\quad \gamma_l\delta f_y = m/[[NF]],\quad \forall n,m\in \left[0,\cdots,[[NF]]-1\right],
\end{equation}
Eq.~(\ref{eq:21}) is transformed into 
\begin{eqnarray}
  \label{eq:23}
   C_{\varphi \vec \alpha}^{12}(k,l) &=& \sum_{l=1}^{[[N]]} \sum_{n=0}^{[[NF]]-1} \sum_{m=0}^{[[NF]]-1} \left( 1\over\gamma_l\delta [[NF]]\right)^2 W_{\varphi \vec \alpha}^{l,12}\left({n\over\gamma_l\delta [[NF]]},{m\over\gamma_l\delta [[NF]]}\right) \exp\left( 2\iota\pi {(k n + l m)\over [[NF]]} \right)  \\
&=& \sum_{n=0}^{[[NF]]-1} \sum_{m=0}^{[[NF]]-1} W_{\varphi \vec \alpha}^{12}(n,m) \exp\left( 2\iota\pi {(k n + l m)\over [[NF]]} \right)
\end{eqnarray}
with
\begin{equation}
  \label{eq:24}
  W_{\varphi \vec \alpha}^{12}(n,m) = \sum_{l=1}^{[[N]]} \left( 1\over\gamma_l\delta [[NF]]\right)^2 W_{\varphi \vec \alpha}^{l,12}\left({n\over\gamma_l\delta [[NF]]},{m\over\gamma_l\delta [[NF]]}\right)
\end{equation}

<<paStats power spectrum with sources (different heights)>>=
dim3 blockDimPsd(16,16);
dim3 gridDimPsd( 1+NF/16 , 1+NF/16 );
dim3 blockDimCov(16,16);
dim3 gridDimCov( 1+NU/16 , 1+NU/16 );

int i_P_SRC, j_S_SRC, offset_i, offset_j, offset, k_LAYER;
fprintf(stderr,"PA covariance 1x2 block:\n");
for (i_P_SRC=0;i_P_SRC<N_P_SRC;i_P_SRC++) {

  offset_i = 2*N_S_SRC*i_P_SRC*_N_LAYER_;

  for (j_S_SRC=0;j_S_SRC<N_S_SRC;j_S_SRC++) {

    fprintf(stderr," [%d,%d]",i_P_SRC,j_S_SRC);
    offset_j = offset_i + 2*j_S_SRC*_N_LAYER_;

    for (k_LAYER=0;k_LAYER<_N_LAYER_;k_LAYER++) {

      offset = offset_j + 2*k_LAYER;
      fprintf(stderr,"(%2d",offset);
      paPowerSpectrum LLL gridDimPsd,blockDimPsd RRR (d__psd, NF, osf, lenslet_pitch, 
						      atm->wavelength, atm->r0, atm->turbulence.L0, 
						      atm->d__turbulence, k_LAYER,
						      (phase_src->dev_ptr) + i_P_SRC, (slopes_src->dev_ptr) + j_S_SRC,
						      d__alpha, kappa);
      <<AA covariance with Wiener-Khinchin>>
      <<AA covariance reduction>>

      offset = offset_j + (2*k_LAYER+1);
      fprintf(stderr,",%2d)",offset);
      paPowerSpectrum LLL gridDimPsd,blockDimPsd RRR (d__psd, NF, osf, lenslet_pitch,
						      atm->wavelength, atm->r0, atm->turbulence.L0, 
						      atm->d__turbulence, k_LAYER,
						      (phase_src->dev_ptr) + i_P_SRC, (slopes_src->dev_ptr) + j_S_SRC,
						      d__beta, kappa);
      <<AA covariance with Wiener-Khinchin>>
      <<AA covariance reduction>>

	  }
  }
  fprintf(stderr,"\n");
 }

@ The power spectrum is computed with the following kernels:
<<paStats power spectrum kernel with sources>>=
__global__ void paPowerSpectrum(float2 *d__psd, int NF, int osf, float d,
				float wavelength, float r0, float L0,
                                profile *turb, int k_LAYER,
				source *src1, source *src2,
				float *alpha, float kappa)
{
  int i, j, k;
  float fx, fy, f_square, fs, gl, red, c_red, s_red, wavenumber;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  k = i*NF + j;
  if ( (i<NF) && (j<(NF)) ) {
    wavenumber = wavelength*0.5/PI;
    k = i*NF + j;
    d__psd[k].x = 0;
    d__psd[k].y = 0;
    gl = 1.0-turb->altitude[k_LAYER]/src2->height;
    red = 2*PI*turb->altitude[k_LAYER];
    fs = osf*(2.0/NF)*(kappa/(2*d));
    fx = (float) i;
    fy = (float) j;
    if (i>=(NF/2))
    fx = fx - NF;
    if (j>=(NF/2))
    fy = fy - NF;
    fx *= fs;
    fy *= fs;
    f_square = fx*fx + fy*fy;
    fs *= fs;
    red *= fx*(src2->theta_x - src1->theta_x) + fy*(src2->theta_y - src1->theta_y);
    sincosf( red, &s_red, &c_red);
    red = -wavenumber*turb->xi0[k_LAYER]*fs*wavelength*(fx*alpha[0] + fy*alpha[1])*
      powf(r0,-5.0/3.0)*
      phasePowerSpectrum(f_square, 1.0/L0)*
      gateAmp(gl*fx*d,gl*fy*d);
    d__psd[k].x += -red*s_red;
    d__psd[k].y +=  red*c_red;
  }
}

<<paStats power spectrum with sources (same heights)>>=
dim3 blockDimPsd(16,16);
dim3 gridDimPsd( 1+NF/16 , 1+NF/16 );
dim3 blockDimCov(16,16);
dim3 gridDimCov( 1+NU/16 , 1+NU/16 );

int i_P_SRC, j_S_SRC, offset0, offset;
fprintf(stderr,"Covariance 1x2 block:\n");
for (i_P_SRC=0;i_P_SRC<N_P_SRC;i_P_SRC++) {

  offset0 = 2*N_S_SRC*i_P_SRC;

  for (j_S_SRC=0;j_S_SRC<N_S_SRC;j_S_SRC++) {

    fprintf(stderr," [%d,%d]",i_P_SRC,j_S_SRC);

    offset = offset0 + 2*j_S_SRC;
    fprintf(stderr,"(%2d",offset);
    paPowerSpectrum LLL gridDimPsd,blockDimPsd RRR (d__psd, NF, osf, lenslet_pitch, 
						    atm->wavelength, atm->r0, atm->turbulence.L0, atm->d__turbulence,
						    (phase_src->dev_ptr) + i_P_SRC, (slopes_src->dev_ptr) + j_S_SRC,
						    d__alpha, kappa);
    <<AA covariance with Wiener-Khinchin>>
    <<AA covariance reduction>>

    offset = offset0 + (2*j_S_SRC+1);
    fprintf(stderr,",%2d)",offset);
    paPowerSpectrum LLL gridDimPsd,blockDimPsd RRR (d__psd, NF, osf, lenslet_pitch,
						    atm->wavelength, atm->r0, atm->turbulence.L0, atm->d__turbulence,
						    (phase_src->dev_ptr) + i_P_SRC, (slopes_src->dev_ptr) + j_S_SRC,
						    d__beta, kappa);
    <<AA covariance with Wiener-Khinchin>>
    <<AA covariance reduction>>
}
fprintf(stderr,"\n");
}
<<paStats power spectrum kernel with sources (same heights)>>=
__global__ void paPowerSpectrum(float2 *d__psd, int NF, int osf, float d,
				float wavelength, float r0, float L0,
                                profile *turb, source *src1, source *src2,
				float *alpha, float kappa)
{
  int i, j, k;
  float fx, fy, f_square, fs, gl, red, c_red, s_red, wavenumber, src_x, src_y;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  k = i*NF + j;
  if ( (i<NF) && (j<(NF)) ) {
    wavenumber = wavelength*0.5/PI;
    k = i*NF + j;
    d__psd[k].x = 0;
    d__psd[k].y = 0;
     for (int k_LAYER=0;k_LAYER<_N_LAYER_;k_LAYER++) {
      gl = (1-turb->altitude[k_LAYER]/src1->height);
      red = 2*PI;
      src_x = src2->theta_x - src1->theta_x;
      src_x *= turb->altitude[k_LAYER];
      src_y = src2->theta_y - src1->theta_y;
      src_y *= turb->altitude[k_LAYER];
      fs = osf*(2.0/NF)*(kappa/(2*d*gl));
      fx = (float) i;
      fy = (float) j;
      if (i>=(NF/2))
	fx = fx - NF;
      if (j>=(NF/2))
	fy = fy - NF;
      fx *= fs;
      fy *= fs;
      f_square = fx*fx + fy*fy;
      fs *= fs;
      //      red *= fx*(src_x + 0.5*d) + fy*(src_y + 0.5*d);
      red *= fx*(src_x) + fy*(src_y);
      sincosf( red, &s_red, &c_red);
      red = -wavenumber*turb->xi0[k_LAYER]*fs*wavelength*(fx*alpha[0] + fy*alpha[1])*
      powf(r0,-5.0/3.0)*
      phasePowerSpectrum(f_square, 1.0/L0)*
	gateAmp(gl*fx*d,gl*fy*d);
      d__psd[k].x += -red*s_red;
      d__psd[k].y +=  red*c_red;
    }
  }
}
@ 
%% Rectangular 2RBT
<<paStats power spectrum with sources (same heights,rect.)>>=
dim3 blockDimPsd(16,16);
dim3 gridDimPsd( 1+NF/16 , 1+NF/16 );
dim3 blockDimCov(16,16);
dim3 gridDimCov( 1+NU/16 , 1+NU/16 );

int i_P_SRC, j_S_SRC, offset0, offset;
fprintf(stderr,"Covariance 1x2 block:\n");
for (i_P_SRC=0;i_P_SRC<N_P_SRC;i_P_SRC++) {

  offset0 = 2*N_S_SRC*i_P_SRC;

  for (j_S_SRC=0;j_S_SRC<N_S_SRC;j_S_SRC++) {

    fprintf(stderr," [%d,%d]",i_P_SRC,j_S_SRC);

    offset = offset0 + 2*j_S_SRC;
    fprintf(stderr,"(%2d",offset);
    paPowerSpectrumRect LLL gridDimPsd,blockDimPsd RRR (d__psd, NF, osf, lenslet_pitch, 
						    atm->wavelength, atm->r0, atm->turbulence.L0, atm->d__turbulence,
						    (phase_src->dev_ptr) + i_P_SRC, (slopes_src->dev_ptr) + j_S_SRC,
						    d__alpha, kappa);
    <<AA covariance with Wiener-Khinchin>>
    <<PA covariance reduction>>

    offset = offset0 + (2*j_S_SRC+1);
    fprintf(stderr,",%2d)",offset);
    paPowerSpectrumRect LLL gridDimPsd,blockDimPsd RRR (d__psd, NF, osf, lenslet_pitch,
						    atm->wavelength, atm->r0, atm->turbulence.L0, atm->d__turbulence,
						    (phase_src->dev_ptr) + i_P_SRC, (slopes_src->dev_ptr) + j_S_SRC,
						    d__beta, kappa);
    <<AA covariance with Wiener-Khinchin>>
    <<PA covariance reduction>>
}
fprintf(stderr,"\n");
}
<<paStats power spectrum kernel with sources (same heights,rect.)>>=
__global__ void paPowerSpectrumRect(float2 *d__psd, int NF, int osf, float d,
				float wavelength, float r0, float L0,
                                profile *turb, source *src1, source *src2,
				float *alpha, float kappa)
{
  int i, j, k;
  float fx, fy, f_square, fs, gl, red, c_red, s_red, wavenumber, src_x, src_y;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  k = i*NF + j;
  if ( (i<NF) && (j<(NF)) ) {
    wavenumber = wavelength*0.5/PI;
    k = i*NF + j;
    d__psd[k].x = 0;
    d__psd[k].y = 0;
     for (int k_LAYER=0;k_LAYER<_N_LAYER_;k_LAYER++) {
      gl = (1-turb->altitude[k_LAYER]/src1->height);
      red = 2*PI;
      src_x = src2->theta_x - src1->theta_x;
      src_x *= turb->altitude[k_LAYER];
      src_y = src2->theta_y - src1->theta_y;
      src_y *= turb->altitude[k_LAYER];
      fs = osf*(2.0/NF)*(kappa/(2*d*gl));
      fx = (float) i;
      fy = (float) j;
      if (i>=(NF/2))
	fx = fx - NF;
      if (j>=(NF/2))
	fy = fy - NF;
      fx *= fs;
      fy *= fs;
      f_square = fx*fx + fy*fy;
      fs *= fs;
      red *= fx*(src_x + 0.5*d) + fy*(src_y + 0.5*d);
      sincosf( red, &s_red, &c_red);
      red = -wavenumber*turb->xi0[k_LAYER]*fs*wavelength*(fx*alpha[0] + fy*alpha[1])*
      powf(r0,-5.0/3.0)*
      phasePowerSpectrum(f_square, 1.0/L0)*
	gateAmp(gl*fx*d,gl*fy*d);
      d__psd[k].x += -red*s_red;
      d__psd[k].y +=  red*c_red;
    }
  }
}
<<PA covariance reduction>>=
pa_covariance_extraction LLL gridDimCov,blockDimCov RRR( d__cov + offset*NU2, NU,
							 d__psd, NF, kappa);
@ The extraction of the covariance is done with the kernel:
<<PA covariance extraction>>=
__global__ void pa_covariance_extraction(float *cov_out, int NC_out, 
				      float2 *cov_in, int NC_in, float kappa)
{
  int i, j, k_out, k_in, h;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  if ( (i<NC_out) && (j<(NC_out)) ) {
    h = (NC_out-1)/2;
    k_out = (NC_out - 1 - (i+h)%NC_out)*NC_out + (NC_out - 1 - (j+h)%NC_out);
    //    k_out = ((i+h)%NC_out)*NC_out + ((j+h)%NC_out);
    if (i>(NC_out/2))
      i = kappa*(i - NC_out) + NC_in;
    else
      i *= kappa;
    if (j>(NC_out/2))
      j = kappa*(j - NC_out) + NC_in;
    else
      j *= kappa;
    k_in = i*NC_in + j;      
    cov_out[k_out] = cov_in[k_in].x;
  }
}

@ 
The main parameters of [[paStats]] are displayed with the info routine: 
<<paStats info>>=
void paStats::info(int kappa, float d)
{
  fprintf(stderr,"\n\x1B[1;42m@(CEO)>paStats:\x1B[;42m\n");
  <<info content>>
  fprintf(stderr," . phase oversampling factor      : %d\n",osf);
  fprintf(stderr,"----------------------------------------------------\x1B[0m\n");
}
@
The memory is freed with the following routine:
<<paStats cleanup>>=
void paStats::cleanup(void)
{
fprintf(stderr,"@(CEO)>paStats: freeing memory!\n");
<<cleanup contents>>
}
@ 
The [[paStats]] covariance can be written to a file with:
<<save pa covariance to file>>=
void paStats::toFile(char *filename)
{
  dev2file(filename, d__cov, cov_size/sizeof(float));
}

@ 
The phase power spectrum is given by:
<<phase power spectrum>>=
 __device__ float phasePowerSpectrum(float f_square, float f0) {
  return 0.022895587108555*powf(f_square + f0*f0,-11.0/6.0);
}
@ 
The subaperture Fourier transform is given by
\begin{equation}
  \label{eq:9}
  {\mathrm sinc}(f_x){\mathrm sinc}(f_y)
\end{equation}
and written in
<<subaperture FT>>=
__device__ float gateAmp(float fx, float fy) {
  float out;
  out = sinc(fx)*sinc(fy);
  return out;
}
@ 
The subaperture PSF is given by
\begin{equation}
  \label{eq:9}
  {\mathrm sinc}^2(f_x){\mathrm sinc}^2(f_y)
\end{equation}
and written in
<<subaperture PSF>>=
__device__ float gatePSF(float fx, float fy) {
  float out;
  out = sinc(fx)*sinc(fy);
  return out*out;
}
@ that depends on the $sinc$ function:
\begin{equation}
  \label{eq:10}
  {\sin(\pi x)\over \pi x}
\end{equation}
<<sinc>>=
__device__ float sinc(float x) {
  return (x==0) ? 1.0 : sinf( PI*x) / (PI*x) ; 
}

<<aaStats covariance>>=
fprintf(stderr,"Covariance block: ");
for (int k=0;k<N_SRC2;k++) {
  fprintf(stderr,"#%d, ",k);
  if (cufftExecC2C(plan, d__psd + 4*k*NF2, d__psd + 4*k*NF2, CUFFT_FORWARD) 
      != CUFFT_SUCCESS){
    fprintf(stderr,"CUFFT Error: Unable to execute plan\n");
  }
  if (cudaThreadSynchronize() != cudaSuccess){
    fprintf(stderr, "Cuda error: Failed to synchronize\n");
  }
  dim3 blockDim(16,16);
  dim3 gridDim( 1+NU/16 , 1+NU/16 );
  covariance_extraction LLL gridDim,blockDim RRR( d__cov + 4*k*NU2    , NU,
						  d__psd + 4*k*NF2, NF, kappa);
  covariance_extraction LLL gridDim,blockDim RRR( d__cov + (4*k+1)*NU2, NU,
						  d__psd + (4*k+1)*NF2, NF, kappa);
  covariance_extraction LLL gridDim,blockDim RRR( d__cov + (4*k+2)*NU2, NU,
						  d__psd + (4*k+2)*NF2, NF, kappa);
  covariance_extraction LLL gridDim,blockDim RRR( d__cov + (4*k+3)*NU2, NU,
						  d__psd + (4*k+3)*NF2, NF, kappa);
}
fprintf(stderr,"\b\b\n");

<<paStats covariance>>=
if (cufftExecC2C(plan, d__psd, d__psd, CUFFT_FORWARD) 
    != CUFFT_SUCCESS){
  fprintf(stderr,"CUFFT Error: Unable to execute plan\n");
 }
if (cudaThreadSynchronize() != cudaSuccess){
  fprintf(stderr, "Cuda error: Failed to synchronize\n");
 }
blockDim = dim3(16,16);
gridDim = dim3( 1+NU/16 , 1+NU/16 );
covariance_extraction LLL gridDim,blockDim RRR( d__cov, NU, d__psd, NF, kappa);
covariance_extraction LLL gridDim,blockDim RRR( d__cov + NU2, NU, d__psd + NF2, NF, kappa);

<<paStats covariance with sources (different heights)>>=
blockDim = dim3(16,16);
gridDim = dim3( 1+NU/16 , 1+NU/16 );
for (int k_LAYER=0;k_LAYER<_N_LAYER_;k_LAYER++) {
  if (cufftExecC2C(plan, d__psd + 2*k_LAYER*NF2, d__psd + 2*k_LAYER*NF2, CUFFT_FORWARD) 
      != CUFFT_SUCCESS){
    fprintf(stderr,"CUFFT Error: Unable to execute plan\n");
  }
  if (cudaThreadSynchronize() != cudaSuccess){
    fprintf(stderr, "Cuda error: Failed to synchronize\n");
  }
  covariance_extraction LLL gridDim,blockDim RRR( d__cov + 2*k_LAYER*NU2,     NU, d__psd + 2*k_LAYER*NF2,     NF, kappa);
  covariance_extraction LLL gridDim,blockDim RRR( d__cov + (2*k_LAYER+1)*NU2, NU, d__psd + (2*k_LAYER+1)*NF2, NF, kappa);
}


@ The product between the covariance matrix and a vector is done by interpolating the matrix values into [[d__cov]] and multiplying and summing the interpolated covariance values with the vector values.
[[d__cov]] is a $[[NU]]\times[[NU]]$ array sampled at the coordinates: $$x,y = \left[ -{[[NU]]-1\over 2},\dots,{[[NU]]-1\over 2}  \right]\times [[sampling]]$$ covering a $\left([[NU]]-1\right)\times [[sampling]]$ area.
The covariance matrix is defined between the coordinate grids $(x_1,y_1)$ and $(x_2,y_2)$.
The slopes are sampled on the grid $(x_2,y_2)$ with $(x,y)_2 =d_2\left((i,j) + (1 - N_2)/2 \right)$ and $i,j=0,\dots,N_2-1$
 and the phase values are sampled on the grid $(x_1,y_1)$ with $(x,y)_1 =d_1\left(i + (1 - N_1)/2 \right)$ and $i,j=0,\dots,N_1-1$.
The covariance matrix size is then $N_1^2\times N_2^2$.
<<matrix-to-vector product>>=
void paStats::MVM(float *out_vector, float *in_vector, 
		  float d1, float g1, int N1, 
		  float d2, int N2,
		  atmosphere *atm, 
		  source *phase_src, int N_P_SRC,
		  source *slopes_src, int N_S_SRC) 
{
  dim3 blockDim(16,16);
  dim3 gridDim( 1 + N1/16 , 1 + N1/16 , N_P_SRC);
  stopwatch tid;
  tid.tic();
  MVM_kernel LLL gridDim,blockDim RRR (out_vector, in_vector, 
				       sampling, NU, d__cov,
				       d1, g1, N1,
				       d2, N2,
				       atm->d__turbulence,
				       phase_src->dev_ptr,
				       slopes_src->dev_ptr, N_S_SRC);
  tid.toc("Product phase/slope covariance");
}
@ with the kernel
<<matrix-to-vector product kernel>>=
__global__ void MVM_kernel(float *out_vector, float *in_vector, 
			   float sampling, int NU, float *cov,
			   float d1, float g1, int N1, 
			   float d2, int N2,
			   profile *turb, 
			   source *src1, source *src2, int N_SRC2) 
{
  int col ,row, i1, j1, i2, j2, k, i_P_SRC, j_S_SRC, offset;
  float xi, yi, x1, y1, covi_x, covi_y, g2;
  int ndx;
  float s, t, fs, ft, onemt, *z;
  i1 = blockIdx.x * blockDim.x + threadIdx.x;
  j1 = blockIdx.y * blockDim.y + threadIdx.y;
  i_P_SRC = blockIdx.z;
  if ( (i1<N1) & (j1<N1) ) {
    row = j1 + i1*N1 + i_P_SRC*N1*N1;
    out_vector[row] = 0;
    covi_x = covi_y = 0;
    for (j_S_SRC=0;j_S_SRC<N_SRC2;j_S_SRC++) {
      offset = j_S_SRC*2*_N_LAYER_;
      for (k=0;k<_N_LAYER_;k++) {
	g2 = 1.0 - turb->altitude[k]/src2[j_S_SRC].height;
	<<coordinates 1>>
	    for (i2=0;i2<N2;i2++) {
	      for (j2=0;j2<N2;j2++) {
		col = j2 + i2*N2;
		<<coordinates 2>>
		    //    covi_x = interpolate(xi,yi, cov + (2*k+offset)*NU*NU,sampling,NU);
		    //covi_y = interpolate(xi,yi, cov+(2*k+1+offset)*NU*NU,sampling,NU);
		<<bilinear interpolation>>
		onemt = 1 - t;
		z = cov + (2*k+offset)*NU*NU;
		covi_x =  ( ( z[ndx]*onemt + z[ndx+1]*t )*(1-s) + 
			 ( z[ndx+NU]*onemt + z[ndx+NU+1]*t )*s );
		out_vector[row] += covi_x*in_vector[col + 2*j_S_SRC*N2*N2];
		z = cov + (2*k+1+offset)*NU*NU;
		covi_y =  ( ( z[ndx]*onemt + z[ndx+1]*t )*(1-s) + 
			 ( z[ndx+NU]*onemt + z[ndx+NU+1]*t )*s );
		out_vector[row] += covi_y*in_vector[col + (2*j_S_SRC+1)*N2*N2];
	      }
	    }
      }
    }
  }
}
<<2D interpolation>>=
__device__ float interpolate(float xi, float yi, 
	   float *z, float sampling, int NU)
{
int ndx;
float s, t, fs, ft, onemt;
<<bilinear interpolation>>
<<bilinear interpolation end>>
}
<<2D interpolation kernel>>=
__global__ void interpolate(float *zi, float xi, float yi, 
	   float *z, float sampling, int NU)
{
int ndx;
float s, t, fs, ft, onemt;
<<bilinear interpolation>>
onemt = 1 - t;
*zi = ( z[ndx]*onemt + z[ndx+1]*t )*(1-s) + 
        ( z[ndx+NU]*onemt + z[ndx+NU+1]*t )*s;
}
@  $x_1$ and $y_1$ coordinates:
<<coordinates 1>>=
x1 = g1*d1*(i1 + (1-N1)*0.5);
y1 = g1*d1*(j1 + (1-N1)*0.5);
@  $x_2$ and $y_2$ coordinates:
<<coordinates 2>>=
xi = g2*d2*(i2 + (1-N2)*0.5) - x1;
yi = g2*d2*(j2 + (1-N2)*0.5) - y1;
@ The interpolation starts with normalizing the coordinates to the pixel size i.e.
<<bilinear interpolation>>=
s = (NU-1)*( xi/(sampling*(NU-1)) + 0.5 );
t = (NU-1)*( yi/(sampling*(NU-1)) + 0.5 );
@  and taking the floor integer part to locate the bottom--left coordinate of the pixels surrounding [[xi]] and [[yi]]
<<bilinear interpolation>>=
fs  = floorf(s);
ft  = floorf(t);
ndx = __float2int_rd( ft + fs*NU );
@ Next, one checks if the edges of the array have been reached
<<bilinear interpolation>>=
if (s==(NU-1)) { s += 1 - fs; ndx -= NU; } else { s -= fs; }    
if (t==(NU-1)) { t += 1 - ft; ndx -= 1; }   else { t -= ft; }
@ and finally the interpolation is computed as
<<bilinear interpolation end>>=	 
onemt = 1 - t;
return ( ( z[ndx]*onemt + z[ndx+1]*t )*(1-s) + 
        ( z[ndx+NU]*onemt + z[ndx+NU+1]*t )*s );
@ matrix--to--vector product
<<MAC>>=
covi = interpolate(xi,yi,cov + 2*k*NU*NU,sampling,NU);
out_vector[row] += covi*in_vector[col];
covi = interpolate(xi,yi,cov+(2*k+1)*NU*NU,sampling,NU);
out_vector[row] += covi*in_vector[col+N2*N2];
@
\subsection{Tests}
\label{sec:tests}

The test routine is written:
<<aaStats.bin>>=

#include <iostream>
#include <fstream>
#include <iomanip>
using namespace std;

#include "cublas_v2.h"
#include "ceo.h"
#include "aaStats.h"
#include "BTBT.h"
using namespace std;
#define N_RUN 5
#define N_SAMPLE 100

__global__ void fill(float *A, int m_a, int n_a) {
  int i, j, k;
  float n;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  k = i*m_a +j;
  n = (float) m_a*n_a;
  if (k<n)
    A[k] = ((float)k)/n;
}

int main( void) {
  atmosphere atm;
  aaStats aa;
  paStats pa;
  BTBT C, S;
  int k, data_size, M, N, NX, NY, NA, MA, k_N, k_SAMPLE, osf;
  float altitude[] = {0},
        xi0[] = {1},
        wind_speed[] = {10},
  	wind_direction[] = {0};
  float *x, *y, *d__x, *d__y, *d__A;
  stopwatch tid;
  cublasHandle_t handle;
  cublasCreate(&handle);
  cublasStatus_t status;

  atm.setup(0.15,30,altitude,xi0,wind_speed,wind_direction);

  int N_[N_RUN] = {20,40,64,84,150};
  float aa_full_mvm_et[N_RUN], pa_full_mvm_et[N_RUN], aa_comp_mvm_et[N_RUN], pa_comp_mvm_et[N_RUN], 
    aa_comp_eval_et[N_RUN], pa_comp_eval_et[N_RUN];

  dim3 blockDim(16,16);
  dim3 gridDim;
  float alpha, beta;
  alpha = 1;
  beta  = 0;
  osf = 2;

  std::ofstream aa_fid, pa_fid;
  aa_fid.open ("aa_runtime.txt");
  aa_fid.setf(ios::fixed, ios::floatfield);
  aa_fid.precision(3);
  aa_fid << "\nAASTATS:\n";
  aa_fid << " N   FULL MVM   COMP MVM   COMP EVAL\n";

  pa_fid.open ("pa_runtime.txt");
  pa_fid.setf(ios::fixed, ios::floatfield);
  pa_fid.precision(3);
  pa_fid << "\nPASTATS:\n";
  pa_fid << " N   FULL MVM   COMP MVM   COMP EVAL\n";

  for (k_SAMPLE=0;k_SAMPLE<N_SAMPLE;k_SAMPLE++) {

  //AASTATS TESTS
  for (k_N=0;k_N<N_RUN;k_N++) {

    N = N_[k_N];
    NX = N*N*2;
    data_size = sizeof(float)*NX;

    x = (float *)malloc( data_size );
    y = (float *)malloc( data_size );
    HANDLE_ERROR( cudaMalloc((void**)&d__x, data_size ) );
    HANDLE_ERROR( cudaMalloc((void**)&d__y, data_size ) );

    for (k=0;k<NX;k++) {
      x[k] = (float)k;
    }
    HANDLE_ERROR( cudaMemcpy( d__x, x, data_size, cudaMemcpyHostToDevice) );

    aa.setup(N,&atm,0.1);
    C.setup(2,2,N,aa.d__cov);
    aa_comp_eval_et[k_N] = aa.cov_eval_et;
    
    //printf("\n AA VARIANCE: %.4E rd^2\n",aa.variance(0.1, &atm, 4, 2048));

    tid.tic();
    C.MVM(d__y,d__x);
    tid.toc(aa_comp_mvm_et + k_N,"Covariance MVM");
    HANDLE_ERROR( cudaMemcpy( y, d__y, data_size, cudaMemcpyDeviceToHost) );
    /* printf("\nMVM:\n"); */
    /* for (k=0;k<NX;k++) { */
    /*   printf("(%2d) %4.2E\n",k,y[k]); */
    /* } */
    FILE *aa_fid;
    char filename[100];
    sprintf(filename,"aa_mvm%03d.bin",N);
    aa_fid = fopen(filename,"wb");
    fwrite(y,sizeof(float),NX,aa_fid);
    fclose(aa_fid);

    if (N<=100) {
      M = 2*N*N;
      data_size = sizeof(float)*M*M;
      HANDLE_ERROR( cudaMalloc((void**)&d__A, data_size ) );
      gridDim = dim3(1+M/16,1+M/16);
      tid.tic();
      fill LLL gridDim,blockDim RRR (d__A, M, M);
      tid.toc("Filling of A");
      tid.tic();
      status = cublasSgemv(handle, CUBLAS_OP_N, M, M, &alpha, d__A, M, d__x, 1, &beta, d__y, 1);
      tid.toc(aa_full_mvm_et + k_N,"A MVM");
      if (status!=CUBLAS_STATUS_SUCCESS)
    	printf(">>> ERROR! CUBLAS FAILED! <<<\n");
      HANDLE_ERROR( cudaFree( d__A ) );
    }  else aa_full_mvm_et[k_N]=0;

    aa.cleanup();
    C.cleanup();
    HANDLE_ERROR( cudaFree( d__x ) );
    HANDLE_ERROR( cudaFree( d__y ) );
    free(x);
    free(y);
  }
  for (k_N=0;k_N<N_RUN;k_N++) {
    aa_fid << setw(3) << N_[k_N] << "   " << setw(6) << aa_full_mvm_et[k_N] << "     " << aa_comp_mvm_et[k_N] << "     " << aa_comp_eval_et[k_N] << "\n";
  }

  //PASTATS TESTS
  for (k_N=0;k_N<N_RUN;k_N++) {

    N = 2*N_[k_N]+1;
    NX = N*N*2;
    NY = N*N;
    data_size = sizeof(float);

    x = (float *)malloc( data_size*NX );
    y = (float *)malloc( data_size*NY );
    HANDLE_ERROR( cudaMalloc((void**)&d__x, data_size*NX ) );
    HANDLE_ERROR( cudaMalloc((void**)&d__y, data_size*NY ) );

    for (k=0;k<NX;k++) {
      x[k] = (float)k;
    }
    HANDLE_ERROR( cudaMemcpy( d__x, x, data_size*NX, cudaMemcpyHostToDevice) );
    pa.setup(N_[k_N],osf,&atm,0.1);
    S.setup(1,2,N,pa.d__cov);
    pa_comp_eval_et[k_N] = pa.cov_eval_et;

    tid.tic();
    S.MVM(d__y,d__x);
    tid.toc(pa_comp_mvm_et + k_N,"Covariance MVM");
    HANDLE_ERROR( cudaMemcpy( y, d__y, data_size*NY, cudaMemcpyDeviceToHost) );
    /* printf("\nMVM:\n"); */
    /* for (k=0;k<NY;k++) { */
    /*   printf("(%3d) %+6.4E\n",k,y[k]); */
    /* } */
    FILE *aa_fid;
    char filename[100];
    sprintf(filename,"pa_mvm%03d.bin",N);
    aa_fid = fopen(filename,"wb");
    fwrite(y,sizeof(float),NY,aa_fid);
    fclose(aa_fid);

    if (N<=100) {
      MA = N*N;
      NA = 2*MA;
      data_size = sizeof(float)*MA*NA;
      HANDLE_ERROR( cudaMalloc((void**)&d__A, data_size ) );
      gridDim = dim3(1+MA/16,1+NA/16);
      tid.tic();
      fill LLL gridDim,blockDim RRR (d__A, MA , NA);
      tid.toc("Filling of A");
      tid.tic();
      status = cublasSgemv(handle, CUBLAS_OP_N, MA, NA, &alpha, d__A, MA, d__x, 1, &beta, d__y, 1);
      tid.toc(pa_full_mvm_et + k_N,"A MVM");
      if (status!=CUBLAS_STATUS_SUCCESS)
  	printf(">>> ERROR! CUBLAS FAILED! <<<\n");
      HANDLE_ERROR( cudaFree( d__A ) );
    } else pa_full_mvm_et[k_N]=0;

    pa.cleanup();
    S.cleanup();
    HANDLE_ERROR( cudaFree( d__x ) );
    HANDLE_ERROR( cudaFree( d__y ) );
    free(x);
    free(y);
  }
  for (k_N=0;k_N<N_RUN;k_N++) {
     pa_fid << setw(3) << N_[k_N] << "   " << setw(6) << pa_full_mvm_et[k_N] << "     " << pa_comp_mvm_et[k_N] << "     " << pa_comp_eval_et[k_N] << "\n";
  }

  } // SAMPLE LOOP

  atm.cleanup();
  cublasDestroy(handle);
  aa_fid.close();
  pa_fid.close();
}

@  The following is the Matlab script to test  the [[MVM_kernel]]:
<<MVM kernel test>>=
kern = parallel.gpu.CUDAKernel('aaStats.ptx','aaStats.cu','MVM_kernel');
kern.ThreadBlockSize = [16,16];
kern.GridSize = [2,2];
d1 = 2/3;
d2 = 2/3;
NU = 7;
N1 = 4;
N2 = 4;
g1 = 1;
g2 = 1;
[x,y] = meshgrid( linspace(-1,1,4) );
z = x(:) + 1i*y(:);
c = abs( bsxfun( @minus, z , z.') );
idx = [13 9 5 1 2 3 4];
cs = mat2cell( c , ones(1,4)*4,ones(1,4)*4);
cov = cell2mat(cellfun( @(x) x(idx)', cs(idx) , 'UniformOutput', false));
vout = gpuArray.zeros(16^2,1,'single');
vin = gpuArray.ones(16^2,1,'single');
sampling = 2/3;
