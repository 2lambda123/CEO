% -*- mode: Noweb; noweb-code-mode: c-mode -*-
[[aaStats]] contains a structure and the routines to compute the covariance matrix of the angle--of--arrival.
The aaStats structure is written in the header:
<<aaStats.h>>=
#ifndef __AASTATS_H__
#define __AASTATS_H__

#ifndef __CEO_H__
#include "ceo.h"
#endif

#ifndef __ATMOSPHERE_H__
#include "atmosphere.h"
#endif

//#define AASTATS_DEBUG
//#define PASTATS_DEBUG

<<aaStats structure>>

<<paStats stucture>>
@ 
The structures are :
<<aaStats structure>>=
struct aaStats {

  <<aaStats parameters>>

  void setup(int N, atmosphere *atm, float lenslet_pitch);
  void setup(int N, atmosphere *atm, float lenslet_pitch, float source_height);
  void setup(int N, atmosphere *atm, float lenslet_pitch, source *src, int N_SRC);

  void cleanup(void);

  void info(int kappa, float d);

  float variance(void);

  void toFile(char *filename);
};
@  and
<<paStats stucture>>=
struct paStats {

  <<paStats parameters>>

  void setup(int N, int osf, atmosphere *atm, float lenslet_pitch);
  void setup(int N, int osf, atmosphere *atm, float lenslet_pitch, float source_height);
  void setup(int N, int osf, atmosphere *atm, float lenslet_pitch, 
	     source *phase_src, int N_P_SRC, source *slopes_src, int N_S_SRC);

  void cleanup(void);

  void info(int kappa, float d);

  /*
  void MVM(float *in_vector, float *out_vector, 
	   float d1, float g1, int N1, 
	   float d2, float g2, int N2);
  */
  void MVM(float *out_vector, float *in_vector, 
	   float d1, float g1, int N1, 
	   float d2, int N2,
	   atmosphere *atm,
	   source *phase_src, int N_P_SRC,
	   source *slopes_src, int N_S_SRC) ;

  void toFile(char *filename);

  void variance(void);

};
#endif // __AASTATS_H__
@ The routines are expanded in the source file:
<<aaStats.cu>>=
#include "aaStats.h"

<<sinc>>

<<subaperture FT>>
<<subaperture PSF>>

<<phase power spectrum>>

<<aaStats power spectrum kernel>>
<<aaStats power spectrum kernel with source height>>
<<aaStats power spectrum kernel with sources>>
<<paStats power spectrum kernel with sources (same heights)>>

<<paStats power spectrum kernel>>
<<paStats power spectrum kernel with source height>>
<<paStats power spectrum kernel with sources>>

<<covariance extraction>>

<<aaStats setup>>
<<aaStats setup with source height>>
<<aaStats setup with sources>>

<<paStats setup>>
<<paStats setup with source height>>
<<paStats setup with sources>>

<<save aa covariance to file>>
<<save pa covariance to file>>

<<aaStats cleanup>>
<<paStats cleanup>>

<<aaStats info>>
<<paStats info>>

<<2D interpolation>>
<<2D interpolation kernel>>
<<matrix-to-vector product kernel>>
<<matrix-to-vector product>>

<<aaStats variance>>
@
Shack--Hartmann WFS centroids are a measure of the spatial derivatives of the wavefront averaged on each subaperture.
These derivatives are often referred as angle of arrivals $\vec \alpha=(\alpha_x\alpha_y,)$:
\begin{eqnarray}
  \label{eq:1}
  \alpha_x &=& {\lambda\over 2\pi d^2} {\partial\varphi\over\partial x} \ast \Pi\left(x\over d\right)\Pi\left(y\over d\right),\\
  \alpha_y &=& {\lambda\over 2\pi d^2} {\partial\varphi\over\partial y} \ast \Pi\left(x\over d\right)\Pi\left(y\over d\right),
\end{eqnarray}
where $\lambda$ is the sensing wavelength and $d$ in the size of one subaperture.

The covariance is derived from the power spectrum density of the angle of arrivals $W_{\vec \alpha \cdot\ \vec \beta}(\vec f)$:
  \begin{equation}
    \label{eq:2}
    W_{\vec \alpha\cdot\vec \beta}(\vec f) = \lambda^2\left( \vec f \cdot \vec\alpha \right)\left( \vec f \cdot \vec\beta \right) W_\varphi(\vec f) G^2(\vec f)
  \end{equation}
$W_\varphi(f)$ is the wavefront power spectrum density given by
\begin{equation}
  \label{eq:3}
  W_\varphi(f) = 0.0229 r_0^{-5/3} \left( f^2 + {1\over\mathcal L_0^2} \right)^{-11/6}.
\end{equation}
$G(\vec f)$ is the point spread function of a subaperture of the WFS,
\begin{equation}
  \label{eq:4}
  G(\vec f) = {\sin(\pi d f_x) \over \pi d f_x }{ \sin(\pi d f_y) \over \pi d f_y } .
\end{equation}

The covariance $C_{\vec \alpha \cdot\ \vec \beta}(\vec\rho)$ is derived from the Wiener--Khinchine theorem:
\begin{equation}
  \label{eq:5}
  C_{\vec \alpha \cdot\ \vec \beta}(\vec\rho) = \mathcal F^{-1} \left[ W_{\vec \alpha\cdot\vec \beta}(\vec f) \right] (\vec\rho)
\end{equation}
where $\mathcal F^{-1}$ stands for the inverse Fourier transform.

The covariance between $\varphi$ and $\vec \alpha$ is derived from the cross--power spectrum density given by:
  \begin{equation}
    \label{eq:2}
    W_{\varphi\vec \alpha}(\vec f) = -\iota\lambda\left( \vec f \cdot \vec\alpha \right) W_\varphi(\vec f) G(\vec f)
  \end{equation}
$W_\varphi(f)$ is the wavefront power spectrum density given by
\begin{equation}
  \label{eq:3}
  W_\varphi(f) = 0.0229 r_0^{-5/3} \left( f^2 + {1\over\mathcal L_0^2} \right)^{-11/6}.
\end{equation}
$G(\vec f)$ is the point spread function of a subaperture of the WFS,
\begin{equation}
  \label{eq:4}
  G(\vec f) = {\sin(\pi d f_x) \over \pi d f_x }{ \sin(\pi d f_y) \over \pi d f_y } .
\end{equation}

The covariance $C_{\varphi \vec \alpha}(\vec\rho)$ is derived from the Wiener--Khinchine theorem:
\begin{equation}
  \label{eq:5}
  C_{\varphi \vec \alpha}(\vec\rho) = \mathcal F^{-1} \left[ W_{\varphi\vec \alpha}(\vec f) \right] (\vec\rho)
\end{equation}
where $\mathcal F^{-1}$ stands for the inverse Fourier transform.

The covariance is computed when the setup function is called with the size of a block, an [[atmosphere]] structure and the lenslet pitch:
<<aaStats setup>>=
void aaStats::setup(int N_, atmosphere *atm, float lenslet_pitch)
{
  N_SRC2 = 1;
  int BATCH = 4;
  <<aaStats setup declarations>>
  <<aaStats setup allocations>>
  stopwatch tid;
  tid.tic();
  <<aaStats evaluate covariance>>
  tid.toc(&cov_eval_et,"Covariance evaluation");
}
<<aaStats setup with source height>>=
void aaStats::setup(int N_, atmosphere *atm, float lenslet_pitch, float source_height)
{
  N_SRC2 = 1;
  int BATCH = 4;
  <<aaStats setup declarations>>
  <<aaStats setup allocations>>
  stopwatch tid;
  tid.tic();
  <<aaStats evaluate covariance with source height>>
  tid.toc(&cov_eval_et,"Covariance evaluation");
}
@ The generic setup routine compute the covariance matrix for $[[N_SRC]]\times[[N_SRC]]$ sources
<<aaStats setup with sources>>=
void aaStats::setup(int N_, atmosphere *atm, float lenslet_pitch, source *src, int N_SRC)
{
  N_SRC2 = N_SRC*N_SRC;
  int BATCH = 1;
  <<aaStats setup declarations>>
  psd_size = sizeof(float2)*NF2;
  <<aaStats setup allocations>>
  stopwatch tid;
  tid.tic();
  <<aaStats evaluate covariance with sources>>
  tid.toc(&cov_eval_et,"Covariance evaluation");
}
<<aaStats setup declarations>>=
float alpha[2] = {1,0}, beta[2] = {0,1}, kappa; 
N = N_;
N2 = N*N;
NU = 2*N-1;
NU2 = NU*NU;
NF = 4096;
NF2 = NF*NF;
kappa = 4;
sampling = lenslet_pitch;

psd_size = sizeof(float2)*NF2*4;
cov_size = sizeof(float)*NU2*4*N_SRC2;
ind_size = sizeof(int)*N2;

<<aaStats setup allocations>>=
HANDLE_ERROR( cudaMalloc((void**)&d__psd, psd_size ) );
HANDLE_ERROR( cudaMalloc((void**)&d__alpha, 2*sizeof(float) ) );
HANDLE_ERROR( cudaMalloc((void**)&d__beta,  2*sizeof(float) ) );
HANDLE_ERROR( cudaMemcpy( d__alpha, alpha, 2*sizeof(float), cudaMemcpyHostToDevice) );
HANDLE_ERROR( cudaMemcpy( d__beta, beta, 2*sizeof(float), cudaMemcpyHostToDevice) );
HANDLE_ERROR( cudaMalloc((void**)&d__cov, cov_size ) );

fprintf(stderr,"@(CEO)>aaStats: Creating 2D covariance FFT plan\n");
int n_DFT[2] = {NF, NF};
int iodist = NF2;
/* Create a 2D FFT plan. */
if (cufftPlanMany(&plan, 2, n_DFT,
		  NULL, 1, iodist,
		  NULL, 1, iodist,
		  CUFFT_C2C,BATCH) != CUFFT_SUCCESS) {
  fprintf(stderr,
	  "CUFFT Error: Unable to create plan\n");
  return;
 }
if (cufftSetCompatibilityMode(plan, CUFFT_COMPATIBILITY_NATIVE)!= CUFFT_SUCCESS) {
  fprintf(stderr,
	  "CUFFT Error: Unable to set compatibility mode to native\n");
  return;
 }

info(kappa, sampling);

<<paStats setup>>=
void paStats::setup(int N_, int osf_, atmosphere *atm, float lenslet_pitch)
{
  N_SRC2 = 1;
  <<paStats setup declarations>>
  stopwatch tid;
  tid.tic();
  <<paStats evaluate covariance>>
  tid.toc(&cov_eval_et,"Covariance evaluation");
}
<<paStats setup with source height>>=
void paStats::setup(int N_, int osf_, atmosphere *atm, float lenslet_pitch, float source_height)
{
  N_SRC2 = 1;
  <<paStats setup declarations>>
  stopwatch tid;
  tid.tic();
  <<paStats evaluate covariance with source height>>
  tid.toc(&cov_eval_et,"Covariance evaluation");

info(kappa,sampling);
}
<<paStats setup with sources>>=
void paStats::setup(int N_, int osf_, atmosphere *atm, float lenslet_pitch, 
		      source *phase_src, int N_P_SRC, source *slopes_src, int N_S_SRC)
{
  N_SRC2 = N_P_SRC*N_S_SRC;
  float alpha[2] = {1,0}, beta[2] = {0,1}, kappa; 
  osf = osf_;
  N = osf*N_+1;
  N2 = N*N;
  NU = 2*N-1;
  NU2 = NU*NU;
  NF = 4096;
  NF2 = NF*NF;
  kappa = 4;
  sampling = lenslet_pitch/osf;

  
  if (phase_src->height==slopes_src->height) {
    psd_size = sizeof(float2)*NF2;
    cov_size = sizeof(float)*NU2*2*N_SRC2;
    ind_size = sizeof(int)*N2;
    int BATCH = 1;

    <<paStats setup allocation>>
    stopwatch tid;
    tid.tic();
    <<paStats evaluate covariance with sources (same heights)>>
    tid.toc(&cov_eval_et,"Covariance evaluation");
  }
  else {
    psd_size = sizeof(float2)*NF2;
    cov_size = sizeof(float)*NU2*2*_N_LAYER_*N_SRC2;
    ind_size = sizeof(int)*N2;
    int BATCH = 1;

    <<paStats setup allocation>>

    stopwatch tid;
    tid.tic();
    <<paStats evaluate covariance with sources (different heights)>>
    tid.toc(&cov_eval_et,"Covariance evaluation");
  }

info(kappa,sampling);

}
<<paStats setup declarations>>=
<<paStats setup variables>>
<<paStats setup allocation>>
<<paStats setup variables>>=
float alpha[2] = {1,0}, beta[2] = {0,1}, kappa; 
osf = osf_;
N = osf*N_+1;
N2 = N*N;
NU = 2*N-1;
NU2 = NU*NU;
NF = 4096;
NF2 = NF*NF;
kappa = 4;
sampling = lenslet_pitch/osf;

psd_size = sizeof(float2)*NF2*2;
cov_size = sizeof(float)*NU2*2;
ind_size = sizeof(int)*N2;
int BATCH = 2;

<<paStats setup allocation>>=
HANDLE_ERROR( cudaMalloc((void**)&d__psd, psd_size ) );
HANDLE_ERROR( cudaMalloc((void**)&d__alpha, 2*sizeof(float) ) );
HANDLE_ERROR( cudaMalloc((void**)&d__beta,  2*sizeof(float) ) );
HANDLE_ERROR( cudaMemcpy( d__alpha, alpha, 2*sizeof(float), cudaMemcpyHostToDevice) );
HANDLE_ERROR( cudaMemcpy( d__beta, beta, 2*sizeof(float), cudaMemcpyHostToDevice) );
HANDLE_ERROR( cudaMalloc((void**)&d__cov, cov_size ) );

fprintf(stderr,"\n@(CEO)>paStats: Creating 2D covariance FFT plan\n");
int n_DFT[2] = {NF, NF};
int iodist = NF2;
/* Create a 2D FFT plan. */
if (cufftPlanMany(&plan, 2, n_DFT,
		  NULL, 1, iodist,
		  NULL, 1, iodist,
		  CUFFT_C2C,BATCH) != CUFFT_SUCCESS) {
  fprintf(stderr,
	  "CUFFT Error: Unable to create plan\n");
  return;
 }
if (cufftSetCompatibilityMode(plan, CUFFT_COMPATIBILITY_NATIVE)!= CUFFT_SUCCESS) {
  fprintf(stderr,
	  "CUFFT Error: Unable to set compatibility mode to native\n");
  return;
 }

@ The covariance can be written to a file with:
<<save aa covariance to file>>=
void aaStats::toFile(char *filename)
{
  dev2file(filename, d__cov, cov_size/sizeof(float));
}
<<save pa covariance to file>>=
void paStats::toFile(char *filename)
{
  dev2file(filename, d__cov, cov_size/sizeof(float));
}
@
The covariance is computed with
<<aaStats evaluate covariance>>=
<<aaStats power spectrum>>
#ifdef AASTATS_DEBUG
HANDLE_ERROR( cudaDeviceSynchronize() );
psd = (float2 *)malloc( psd_size );
HANDLE_ERROR( cudaMemcpy( psd, d__psd, psd_size, cudaMemcpyDeviceToHost) );
int k;
fprintf(stderr,"\n@(CEO)>aaStats: power spectrum\n");
for (int i=0;i<NF;i++) {
  fprintf(stderr,"|");
  for (int j=0;j<NF;j++) {
    k = i*NF + j;
    fprintf(stderr,"|(%d,%d)%+4.2E;%+4.2E|",i,j,psd[k].x,psd[k].y);
  }
  fprintf(stderr,"|\n");
}
#endif

<<aaStats covariance>>
#ifdef AASTATS_DEBUG
cov = (float2 *)malloc( cov_size );
HANDLE_ERROR( cudaMemcpy( cov, d__cov, cov_size, cudaMemcpyDeviceToHost) );
fprintf(stderr,"\n@(CEO)>aaStats: covariance\n");
for (int i=0;i<NU;i++) {
  fprintf(stderr,"|");
  for (int j=0;j<NU;j++) {
    k = i*(NU) + j;
    fprintf(stderr,"|(%d,%d)%+4.2E|",i,j,cov[k].x);
  }
  fprintf(stderr,"|\n");
}
#endif

<<aaStats evaluate covariance with source height>>=
<<aaStats power spectrum with source height>>
<<aaStats covariance>>

<<aaStats evaluate covariance with sources>>=
<<aaStats power spectrum with sources>>

<<paStats evaluate covariance>>=
<<paStats power spectrum>>
#ifdef PASTATS_DEBUG
HANDLE_ERROR( cudaDeviceSynchronize() );
psd = (float2 *)malloc( psd_size );
HANDLE_ERROR( cudaMemcpy( psd, d__psd, psd_size, cudaMemcpyDeviceToHost) );
int k;
fprintf(stderr,"\n@(CEO)>paStats: power spectrum\n");
for (int i=0;i<MIN(NF,5);i++) {
  fprintf(stderr,"|");
  for (int j=0;j<MIN(NF,5);j++) {
    k = i*NF + j;
    fprintf(stderr,"|(%d,%d)%+6.4E;%+6.4E|",i,j,psd[k].x,psd[k].y);
  }
  fprintf(stderr,"|\n");
}
#endif

<<paStats covariance>>
#ifdef PASTATS_DEBUG
cov = (float2 *)malloc( cov_size );
HANDLE_ERROR( cudaMemcpy( cov, d__cov, cov_size, cudaMemcpyDeviceToHost) );
fprintf(stderr,"\n@(CEO)>paStats: covariance\n");
for (int i=0;i<MIN(NU,10);i++) {
  fprintf(stderr,"|");
  for (int j=0;j<MIN(NU,10);j++) {
    k = i*(NU) + j;
    fprintf(stderr,"|(%d,%d)%+6.4E|",i,j,cov[k].x);
  }
  fprintf(stderr,"|\n");
}
#endif

<<paStats evaluate covariance with source height>>=
<<paStats power spectrum with source height>>
<<paStats covariance>>

<<paStats evaluate covariance with sources (different heights)>>=
<<paStats power spectrum with sources (different heights)>>

<<paStats evaluate covariance with sources (same heights)>>=
<<paStats power spectrum with sources (same heights)>>

@ The main parameters of [[aaStats]] are displayed with the [[info]] routine:
<<aaStats info>>=
void aaStats::info(int kappa, float d)
{
  fprintf(stderr,"\n\x1B[1;42m@(CEO)>aaStats:\x1B[;42m\n");
  <<info content>>
  fprintf(stderr,"----------------------------------------------------\x1B[0m\n");
}
<<paStats info>>=
void paStats::info(int kappa, float d)
{
  fprintf(stderr,"\n\x1B[1;42m@(CEO)>paStats:\x1B[;42m\n");
  <<info content>>
  fprintf(stderr," . phase oversampling factor      : %d\n",osf);
  fprintf(stderr,"----------------------------------------------------\x1B[0m\n");
}
<<info content>>=
fprintf(stderr," . sampling [m]                   : %.2f\n",d);
fprintf(stderr," . size of covariance matrix block: %dX%d\n",NU,NU);
fprintf(stderr," . spectrum resolution            : %d\n",NF);
fprintf(stderr," . covariance oversampling factor : %d\n",kappa);
fprintf(stderr," . spectrum highest frequency     : %4.2E\n",(2.0/NF)*(kappa/(2*d)));
@ 
<<aaStats cleanup>>=
void aaStats::cleanup(void)
{
fprintf(stderr,"@(CEO)>aaStats: freeing memory!\n");
<<cleanup contents>>
}
<<paStats cleanup>>=
void paStats::cleanup(void)
{
fprintf(stderr,"@(CEO)>paStats: freeing memory!\n");
<<cleanup contents>>
}
<<cleanup contents>>=
cufftDestroy(plan);
HANDLE_ERROR( cudaFree( d__psd ) );
HANDLE_ERROR( cudaFree( d__alpha ) );
HANDLE_ERROR( cudaFree( d__beta ) );
HANDLE_ERROR( cudaFree( d__cov ) );
#ifdef AASTATS_DEBUG
free(psd);		
free(cov);		
#endif		
@
The parameters of the [[aaStats]] structure are:
<<aaStats parameters>>=
int N, N2, NU, NU2, NF, NF2, psd_size, cov_size, ind_size;
float2 *d__psd;
float *d__cov, *d__alpha, *d__beta, n_full, n_comp, b_full, b_comp, cov_eval_et, sampling;
cufftHandle plan;
#if defined(AASTATS_DEBUG) || defined(PASTATS_DEBUG)
float2 *psd, *cov;
#endif
int N_SRC2;
@ 
The parameters of the [[paStats]] structure are:
<<paStats parameters>>=
int osf;
<<aaStats parameters>>
@ 
The power spectrum  must be sampled such as its Fourier transform gives unbiased values of the covariance.
The largest spatial frequency is $f_{max}=\kappa/2d$ with $\kappa\ge 1$.
The number of sample is given by $[[N_F]]\ge [[N_SIDE_LENSLET]]$.
The spatial frequencies are given by
\begin{eqnarray}
  \label{eq:6}
  f_{x,y} &=& (i,j){2\over [[NF]] }{\kappa\over 2d}, (i,j) \in \left[ 0,\dots,[[NF]]/2-1\right] \\
  f_{x,y} &=& (i,j){2\over [[NF]] }{\kappa\over 2d}, (i,j) \in \left[ [[NF]]/2,\dots,[[NF]]-1\right] 
\end{eqnarray}
Note that [[NF]] must be even.
<<aaStats power spectrum>>=
dim3 blockDim(16,16);
dim3 gridDim( 1+NF/16 , 1+NF/16 );
aaPowerSpectrum LLL gridDim,blockDim RRR (d__psd, NF, lenslet_pitch, 
					atm->wavelength, atm->r0, atm->turbulence.L0,
					d__alpha, d__alpha, kappa);
aaPowerSpectrum LLL gridDim,blockDim RRR (d__psd + NF2, NF, lenslet_pitch,
					atm->wavelength, atm->r0, atm->turbulence.L0,
					d__alpha, d__beta, kappa);
aaPowerSpectrum LLL gridDim,blockDim RRR (d__psd + NF2*2, NF, lenslet_pitch,
					atm->wavelength, atm->r0, atm->turbulence.L0,
					d__beta, d__alpha, kappa);
aaPowerSpectrum LLL gridDim,blockDim RRR (d__psd + NF2*3, NF, lenslet_pitch,
					atm->wavelength, atm->r0, atm->turbulence.L0,
					d__beta, d__beta, kappa);
<<aaStats power spectrum with source height>>=
dim3 blockDim(16,16);
dim3 gridDim( 1+NF/16 , 1+NF/16 );
aaPowerSpectrum LLL gridDim,blockDim RRR (d__psd, NF, lenslet_pitch, 
					atm->wavelength, atm->r0, atm->turbulence.L0,
                                        atm->d__turbulence, source_height,
					d__alpha, d__alpha, kappa);
aaPowerSpectrum LLL gridDim,blockDim RRR (d__psd + NF2, NF, lenslet_pitch,
					atm->wavelength, atm->r0, atm->turbulence.L0,
                                        atm->d__turbulence, source_height,
					d__alpha, d__beta, kappa);
aaPowerSpectrum LLL gridDim,blockDim RRR (d__psd + NF2*2, NF, lenslet_pitch,
					atm->wavelength, atm->r0, atm->turbulence.L0,
                                        atm->d__turbulence, source_height,
					d__beta, d__alpha, kappa);
aaPowerSpectrum LLL gridDim,blockDim RRR (d__psd + NF2*3, NF, lenslet_pitch,
					atm->wavelength, atm->r0, atm->turbulence.L0,
                                        atm->d__turbulence, source_height,
					d__beta, d__beta, kappa);
<<aaStats power spectrum with sources>>=
dim3 blockDimPsd(16,16);
dim3 gridDimPsd( 1+NF/16 , 1+NF/16 );
dim3 blockDimCov(16,16);
dim3 gridDimCov( 1+NU/16 , 1+NU/16 );

int i_SRC, j_SRC, offset0, offset;
fprintf(stderr,"Covariance 4x4 block:\n");
for (i_SRC=0;i_SRC<N_SRC;i_SRC++) {

  offset0 = 4*N_SRC*i_SRC;

  for (j_SRC=0;j_SRC<N_SRC;j_SRC++) {

    fprintf(stderr," [%d,%d]",i_SRC,j_SRC);

    offset = offset0 + 2*j_SRC;
    fprintf(stderr,"(%2d",offset);
    aaPowerSpectrum LLL gridDimPsd,blockDimPsd RRR (d__psd, NF, lenslet_pitch, 
						    atm->wavelength, atm->r0, atm->turbulence.L0,
						    atm->d__turbulence, (src->dev_ptr) + i_SRC, (src->dev_ptr) + j_SRC,
						    d__alpha, d__alpha, kappa);
    <<AA covariance with Wiener-Khinchin>>
    <<AA covariance reduction>>

    offset = offset0 + (2*j_SRC+1);
    fprintf(stderr,",%2d",offset);
    aaPowerSpectrum LLL gridDimPsd,blockDimPsd RRR (d__psd, NF, lenslet_pitch, 
						    atm->wavelength, atm->r0, atm->turbulence.L0,
						    atm->d__turbulence, (src->dev_ptr) + i_SRC, (src->dev_ptr) + j_SRC,
						    d__alpha, d__beta, kappa);
    <<AA covariance with Wiener-Khinchin>>
    <<AA covariance reduction>>

    offset = offset0 + 2*(N_SRC+j_SRC);
    fprintf(stderr,",%2d",offset);
    aaPowerSpectrum LLL gridDimPsd,blockDimPsd RRR (d__psd, NF, lenslet_pitch, 
						    atm->wavelength, atm->r0, atm->turbulence.L0,
						    atm->d__turbulence, (src->dev_ptr) + i_SRC, (src->dev_ptr) + j_SRC,
						    d__beta, d__alpha, kappa);
    <<AA covariance with Wiener-Khinchin>>
    <<AA covariance reduction>>

    offset = offset0 + (2*(N_SRC+j_SRC)+1);
    fprintf(stderr,",%2d)",offset);
    aaPowerSpectrum LLL gridDimPsd,blockDimPsd RRR (d__psd, NF, lenslet_pitch, 
						    atm->wavelength, atm->r0, atm->turbulence.L0,
						    atm->d__turbulence, (src->dev_ptr) + i_SRC, (src->dev_ptr) + j_SRC,
						    d__beta, d__beta, kappa);
    <<AA covariance with Wiener-Khinchin>>
    <<AA covariance reduction>>
	}
  fprintf(stderr,"\n");
 }

<<AA covariance with Wiener-Khinchin>>=
if (cufftExecC2C(plan, d__psd, d__psd, CUFFT_FORWARD) 
    != CUFFT_SUCCESS){
  fprintf(stderr,"CUFFT Error: Unable to execute plan\n");
 }
if (cudaThreadSynchronize() != cudaSuccess){
  fprintf(stderr, "Cuda error: Failed to synchronize\n");
 }

<<AA covariance reduction>>=
covariance_extraction LLL gridDimCov,blockDimCov RRR( d__cov + offset*NU2, NU,
						      d__psd, NF, kappa);

@ The power spectrum is computed with the following kernel:
<<aaStats power spectrum kernel>>=
  __global__ void aaPowerSpectrum(float2 *d__psd, int NF, float d,
				float wavelength, float r0, float L0,
				float *alpha, float *beta, float kappa)
{
  int i, j, k;
  float fx, fy, f_square, fs;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  k = i*NF + j;
  if ( (i<NF) && (j<(NF)) ) {
    fx = (float) i;
    fy = (float) j;
    if (i>=(NF/2))
      fx = fx - NF;
    if (j>=(NF/2))
      fy = fy - NF;
    fs = (2.0/NF)*(kappa/(2*d));
    fx *= fs;
    fy *= fs;
    k = i*NF + j;
    f_square = fx*fx + fy*fy;
    wavelength *= wavelength;
    fs *= fs;
    d__psd[k].x = (k==0) ? 0 : 
      fs*wavelength*(fx*alpha[0] + fy*alpha[1])*(fx*beta[0] + fy*beta[1])*
      powf(r0,-5.0/3.0)*
      phasePowerSpectrum(f_square, 1.0/L0)*
      gatePSF(fx*d,fy*d);
    d__psd[k].y = 0;
  }
}
@ 
<<aaStats power spectrum kernel with source height>>=
__global__ void aaPowerSpectrum(float2 *d__psd, int NF, float d,
				float wavelength, float r0, float L0,
                                profile *turb, float source_height,
				float *alpha, float *beta, float kappa)
{
  int i, j, k;
  float fx, fy, f_square, fs, gl;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  k = i*NF + j;
  if ( (i<NF) && (j<(NF)) ) {
    k = i*NF + j;
    wavelength *= wavelength;
    d__psd[k].x = 0;
    for (int k_LAYER=0;k_LAYER<_N_LAYER_;k_LAYER++) {
      gl = (1-turb->altitude[k_LAYER]/source_height);
      fs = (2.0/NF)*(kappa/(2*d*gl));
      fx = (float) i;
      fy = (float) j;
      if (i>=(NF/2))
	fx = fx - NF;
      if (j>=(NF/2))
      fy = fy - NF;
      fx *= fs;
      fy *= fs;
      f_square = fx*fx + fy*fy;
      fs *= fs;
      d__psd[k].x += (k==0) ? 0 : turb->xi0[k_LAYER]*
	fs*wavelength*(fx*alpha[0] + fy*alpha[1])*(fx*beta[0] + fy*beta[1])*
	powf(r0,-5.0/3.0)*
	phasePowerSpectrum(f_square, 1.0/L0)*
	gatePSF(gl*fx*d,gl*fy*d);
    }
    d__psd[k].y = 0;
  }
}
<<aaStats power spectrum kernel with sources>>=
__global__ void aaPowerSpectrum(float2 *d__psd, int NF, float d,
				float wavelength, float r0, float L0,
                                profile *turb, source *src1, source *src2,
				float *alpha, float *beta, float kappa)
{
  int i, j, k;
  float fx, fy, f_square, fs, gl, red, c_red, s_red;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  k = i*NF + j;
  if ( (i<NF) && (j<(NF)) ) {
    k = i*NF + j;
    wavelength *= wavelength;
    d__psd[k].x = 0;
    d__psd[k].y = 0;
    for (int k_LAYER=0;k_LAYER<_N_LAYER_;k_LAYER++) {
      gl = (1-turb->altitude[k_LAYER]/src1->height);
      red = 2*PI*turb->altitude[k_LAYER];
      fs = (2.0/NF)*(kappa/(2*d*gl));
      fx = (float) i;
      fy = (float) j;
      if (i>=(NF/2))
	fx = fx - NF;
      if (j>=(NF/2))
      fy = fy - NF;
      fx *= fs;
      fy *= fs;
      f_square = fx*fx + fy*fy;
      fs *= fs;
      red *= fx*(src2->theta_x - src1->theta_x) + fy*(src2->theta_y - src1->theta_y);
      sincosf( red, &s_red, &c_red);
      red = (k==0) ? 0 : turb->xi0[k_LAYER]*
	fs*wavelength*(fx*alpha[0] + fy*alpha[1])*(fx*beta[0] + fy*beta[1])*
	powf(r0,-5.0/3.0)*
	phasePowerSpectrum(f_square, 1.0/L0)*
	gatePSF(gl*fx*d,gl*fy*d);
      d__psd[k].x += red*c_red;
      d__psd[k].y += red*s_red;
    }
  }
}
@ From the power spectrum, once can derive the variance:
<<aaStats variance>>=
float aaStats::variance(void) {
  float res;
  HANDLE_ERROR( cudaMemcpy( &res, d__cov + (N-1)*(NU+1), sizeof(float), cudaMemcpyDeviceToHost) );
  return res;
}

<<paStats power spectrum>>=
dim3 blockDim(16,16);
dim3 gridDim( 1+NF/16 , 1+NF/16 );
paPowerSpectrum LLL gridDim,blockDim RRR (d__psd, NF, osf, lenslet_pitch, 
					atm->wavelength, atm->r0, atm->turbulence.L0,
					d__alpha, kappa);
paPowerSpectrum LLL gridDim,blockDim RRR (d__psd + NF2, NF, osf, lenslet_pitch,
					atm->wavelength, atm->r0, atm->turbulence.L0,
					d__beta, kappa);

<<paStats power spectrum with source height>>=
dim3 blockDim(16,16);
dim3 gridDim( 1+NF/16 , 1+NF/16 );
paPowerSpectrum LLL gridDim,blockDim RRR (d__psd, NF, osf, lenslet_pitch, 
					atm->wavelength, atm->r0, atm->turbulence.L0,
                                        atm->d__turbulence, source_height,
					d__alpha, kappa);
paPowerSpectrum LLL gridDim,blockDim RRR (d__psd + NF2, NF, osf, lenslet_pitch,
					atm->wavelength, atm->r0, atm->turbulence.L0,
                                        atm->d__turbulence, source_height,
					d__beta, kappa);

<<paStats power spectrum with sources (different heights)>>=
dim3 blockDimPsd(16,16);
dim3 gridDimPsd( 1+NF/16 , 1+NF/16 );
dim3 blockDimCov(16,16);
dim3 gridDimCov( 1+NU/16 , 1+NU/16 );

int i_P_SRC, j_S_SRC, offset_i, offset_j, offset, k_LAYER;
fprintf(stderr,"PA covariance 1x2 block:\n");
for (i_P_SRC=0;i_P_SRC<N_P_SRC;i_P_SRC++) {

  offset_i = 2*N_S_SRC*i_P_SRC*_N_LAYER_;

  for (j_S_SRC=0;j_S_SRC<N_S_SRC;j_S_SRC++) {

    fprintf(stderr," [%d,%d]",i_P_SRC,j_S_SRC);
    offset_j = offset_i + 2*j_S_SRC*_N_LAYER_;

    for (k_LAYER=0;k_LAYER<_N_LAYER_;k_LAYER++) {

      offset = offset_j + 2*k_LAYER;
      fprintf(stderr,"(%2d",offset);
      paPowerSpectrum LLL gridDimPsd,blockDimPsd RRR (d__psd, NF, osf, lenslet_pitch, 
						      atm->wavelength, atm->r0, atm->turbulence.L0, 
						      atm->d__turbulence, k_LAYER,
						      (phase_src->dev_ptr) + i_P_SRC, (slopes_src->dev_ptr) + j_S_SRC,
						      d__alpha, kappa);
      <<AA covariance with Wiener-Khinchin>>
      <<AA covariance reduction>>

      offset = offset_j + (2*k_LAYER+1);
      fprintf(stderr,",%2d)",offset);
      paPowerSpectrum LLL gridDimPsd,blockDimPsd RRR (d__psd, NF, osf, lenslet_pitch,
						      atm->wavelength, atm->r0, atm->turbulence.L0, 
						      atm->d__turbulence, k_LAYER,
						      (phase_src->dev_ptr) + i_P_SRC, (slopes_src->dev_ptr) + j_S_SRC,
						      d__beta, kappa);
      <<AA covariance with Wiener-Khinchin>>
      <<AA covariance reduction>>

	  }
  }
  fprintf(stderr,"\n");
 }

<<paStats power spectrum with sources (same heights)>>=
dim3 blockDimPsd(16,16);
dim3 gridDimPsd( 1+NF/16 , 1+NF/16 );
dim3 blockDimCov(16,16);
dim3 gridDimCov( 1+NU/16 , 1+NU/16 );

int i_P_SRC, j_S_SRC, offset0, offset;
fprintf(stderr,"Covariance 1x2 block:\n");
for (i_P_SRC=0;i_P_SRC<N_P_SRC;i_P_SRC++) {

  offset0 = 2*N_S_SRC*i_P_SRC;

  for (j_S_SRC=0;j_S_SRC<N_S_SRC;j_S_SRC++) {

    fprintf(stderr," [%d,%d]",i_P_SRC,j_S_SRC);

    offset = offset0 + 2*j_S_SRC;
    fprintf(stderr,"(%2d",offset);
    paPowerSpectrum LLL gridDimPsd,blockDimPsd RRR (d__psd, NF, osf, lenslet_pitch, 
						    atm->wavelength, atm->r0, atm->turbulence.L0, atm->d__turbulence,
						    (phase_src->dev_ptr) + i_P_SRC, (slopes_src->dev_ptr) + j_S_SRC,
						    d__alpha, kappa);
    <<AA covariance with Wiener-Khinchin>>
    <<AA covariance reduction>>

    offset = offset0 + (2*j_S_SRC+1);
    fprintf(stderr,",%2d)",offset);
    paPowerSpectrum LLL gridDimPsd,blockDimPsd RRR (d__psd, NF, osf, lenslet_pitch,
						    atm->wavelength, atm->r0, atm->turbulence.L0, atm->d__turbulence,
						    (phase_src->dev_ptr) + i_P_SRC, (slopes_src->dev_ptr) + j_S_SRC,
						    d__beta, kappa);
    <<AA covariance with Wiener-Khinchin>>
    <<AA covariance reduction>>
}
fprintf(stderr,"\n");
}

@ The power spectrum is computed with the following kernel:
<<paStats power spectrum kernel>>=
  __global__ void paPowerSpectrum(float2 *d__psd, int NF, int osf, float d,
				float wavelength, float r0, float L0,
				float *alpha, float kappa)
{
  int i, j, k;
  float fx, fy, f_square, fs;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  k = i*NF + j;
  if ( (i<NF) && (j<(NF)) ) {
    fx = (float) i;
    fy = (float) j;
    if (i>=(NF/2))
      fx = fx - NF;
    if (j>=(NF/2))
      fy = fy - NF;
    fs = osf*(2.0/NF)*(kappa/(2*d));
    fx *= fs;
    fy *= fs;
    k = i*NF + j;
    f_square = fx*fx + fy*fy;
    fs *= fs;
    d__psd[k].y = -fs*wavelength*(fx*alpha[0] + fy*alpha[1])*
      powf(r0,-5.0/3.0)*
      phasePowerSpectrum(f_square, 1.0/L0)*
      gateAmp(fx*d,fy*d);
    d__psd[k].x = 0;
  }
}
<<paStats power spectrum kernel with source height>>=
__global__ void paPowerSpectrum(float2 *d__psd, int NF, int osf, float d,
				float wavelength, float r0, float L0,
                                profile *turb, float source_height,
				float *alpha, float kappa)
{
  int i, j, k;
  float fx, fy, f_square, fs, gl;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  k = i*NF + j;
  if ( (i<NF) && (j<(NF)) ) {
    k = i*NF + j;
    d__psd[k].y = 0;
    for (int k_LAYER=0;k_LAYER<_N_LAYER_;k_LAYER++) {
      gl = (1-turb->altitude[k_LAYER]/source_height);
      fs = osf*(2.0/NF)*(kappa/(2*d*gl));
      fx = (float) i;
      fy = (float) j;
      if (i>=(NF/2))
	fx = fx - NF;
      if (j>=(NF/2))
	fy = fy - NF;
      fx *= fs;
      fy *= fs;
      f_square = fx*fx + fy*fy;
      fs *= fs;
      d__psd[k].y += -turb->xi0[k_LAYER]*fs*wavelength*(fx*alpha[0] + fy*alpha[1])*
      powf(r0,-5.0/3.0)*
      phasePowerSpectrum(f_square, 1.0/L0)*
	gateAmp(gl*fx*d,gl*fy*d);
    }
    d__psd[k].x = 0;
  }
}
<<paStats power spectrum kernel with sources>>=
__global__ void paPowerSpectrum(float2 *d__psd, int NF, int osf, float d,
				float wavelength, float r0, float L0,
                                profile *turb, int k_LAYER,
				source *src1, source *src2,
				float *alpha, float kappa)
{
  int i, j, k;
  float fx, fy, f_square, fs, gl, red, c_red, s_red;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  k = i*NF + j;
  if ( (i<NF) && (j<(NF)) ) {
    k = i*NF + j;
    d__psd[k].x = 0;
    d__psd[k].y = 0;
    gl = 1.0-turb->altitude[k_LAYER]/src2->height;
    red = 2*PI*turb->altitude[k_LAYER];
    fs = osf*(2.0/NF)*(kappa/(2*d));
    fx = (float) i;
    fy = (float) j;
    if (i>=(NF/2))
    fx = fx - NF;
    if (j>=(NF/2))
    fy = fy - NF;
    fx *= fs;
    fy *= fs;
    f_square = fx*fx + fy*fy;
    fs *= fs;
    red *= fx*(src2->theta_x - src1->theta_x) + fy*(src2->theta_y - src1->theta_y);
    sincosf( red, &s_red, &c_red);
    red = -turb->xi0[k_LAYER]*fs*wavelength*(fx*alpha[0] + fy*alpha[1])*
      powf(r0,-5.0/3.0)*
      phasePowerSpectrum(f_square, 1.0/L0)*
      gateAmp(gl*fx*d,gl*fy*d);
    d__psd[k].x += -red*s_red;
    d__psd[k].y +=  red*c_red;
  }
}
<<paStats power spectrum kernel with sources (same heights)>>=
__global__ void paPowerSpectrum(float2 *d__psd, int NF, int osf, float d,
				float wavelength, float r0, float L0,
                                profile *turb, source *src1, source *src2,
				float *alpha, float kappa)
{
  int i, j, k;
  float fx, fy, f_square, fs, gl, red, c_red, s_red;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  k = i*NF + j;
  if ( (i<NF) && (j<(NF)) ) {
    k = i*NF + j;
    d__psd[k].x = 0;
    d__psd[k].y = 0;
    for (int k_LAYER=0;k_LAYER<_N_LAYER_;k_LAYER++) {
      gl = (1-turb->altitude[k_LAYER]/src1->height);
      red = 2*PI*turb->altitude[k_LAYER];
      fs = osf*(2.0/NF)*(kappa/(2*d*gl));
      fx = (float) i;
      fy = (float) j;
      if (i>=(NF/2))
	fx = fx - NF;
      if (j>=(NF/2))
	fy = fy - NF;
      fx *= fs;
      fy *= fs;
      f_square = fx*fx + fy*fy;
      fs *= fs;
      red *= fx*(src2->theta_x - src1->theta_x) + fy*(src2->theta_y - src1->theta_y);
      sincosf( red, &s_red, &c_red);
      red = -turb->xi0[k_LAYER]*fs*wavelength*(fx*alpha[0] + fy*alpha[1])*
      powf(r0,-5.0/3.0)*
      phasePowerSpectrum(f_square, 1.0/L0)*
	gateAmp(gl*fx*d,gl*fy*d);
      d__psd[k].x += -red*s_red;
      d__psd[k].y +=  red*c_red;
    }
  }
}
@ 
The phase power spectrum is given by:
<<phase power spectrum>>=
 __device__ float phasePowerSpectrum(float f_square, float f0) {
  return 0.022895587108555*powf(f_square + f0*f0,-11.0/6.0);
}
@ 
The subaperture Fourier transform is given by
\begin{equation}
  \label{eq:9}
  {\mathrm sinc}(f_x){\mathrm sinc}(f_y)
\end{equation}
and written in
<<subaperture FT>>=
__device__ float gateAmp(float fx, float fy) {
  float out;
  out = sinc(fx)*sinc(fy);
  return out;
}
@ 
The subaperture PSF is given by
\begin{equation}
  \label{eq:9}
  {\mathrm sinc}^2(f_x){\mathrm sinc}^2(f_y)
\end{equation}
and written in
<<subaperture PSF>>=
__device__ float gatePSF(float fx, float fy) {
  float out;
  out = sinc(fx)*sinc(fy);
  return out*out;
}
@ that depends on the $sinc$ function:
\begin{equation}
  \label{eq:10}
  {\sin(\pi x)\over \pi x}
\end{equation}
<<sinc>>=
__device__ float sinc(float x) {
  return (x==0) ? 1.0 : sinf( PI*x) / (PI*x) ; 
}
@ 
The covariance derived from the power spectrum is sampled every $\rho_s=d/\kappa$.
The covariance derived from the slopes of the lenslet array is sampled every $d$.
Consequently the lenslet--array--slope--covariance is extracted from the power--spectrum--covariance at $(i\kappa,j\kappa)$.
Due to the symmetry of the Fourier transform output, the subscripts in the power--spectrum--covariance are in fact given by
\begin{eqnarray}
  \label{eq:8}
  (i,j)\kappa, (i,j) \in \left[ 0,\dots,[[N]]-1 \right] \\
  \left[(i,j)-[[NU]]\right]\kappa + [[NF]], (i,j) \in \left[ [[N]],\dots,[[NU]]-1 \right]
\end{eqnarray}

The lenslet--array--slope--covariance is shifted such as the baseline coordinate $(0,0$) is a the center of the array i.e.
\begin{equation}
  \label{eq:7}
  (i,j) \leftarrow \left[ (i,j) + (2[[N]]-2)/2 \right] \mod ( 2[[N]]-1 )
\end{equation}
<<aaStats covariance>>=
fprintf(stderr,"Covariance block: ");
for (int k=0;k<N_SRC2;k++) {
  fprintf(stderr,"#%d, ",k);
  if (cufftExecC2C(plan, d__psd + 4*k*NF2, d__psd + 4*k*NF2, CUFFT_FORWARD) 
      != CUFFT_SUCCESS){
    fprintf(stderr,"CUFFT Error: Unable to execute plan\n");
  }
  if (cudaThreadSynchronize() != cudaSuccess){
    fprintf(stderr, "Cuda error: Failed to synchronize\n");
  }
  dim3 blockDim(16,16);
  dim3 gridDim( 1+NU/16 , 1+NU/16 );
  covariance_extraction LLL gridDim,blockDim RRR( d__cov + 4*k*NU2    , NU,
						  d__psd + 4*k*NF2, NF, kappa);
  covariance_extraction LLL gridDim,blockDim RRR( d__cov + (4*k+1)*NU2, NU,
						  d__psd + (4*k+1)*NF2, NF, kappa);
  covariance_extraction LLL gridDim,blockDim RRR( d__cov + (4*k+2)*NU2, NU,
						  d__psd + (4*k+2)*NF2, NF, kappa);
  covariance_extraction LLL gridDim,blockDim RRR( d__cov + (4*k+3)*NU2, NU,
						  d__psd + (4*k+3)*NF2, NF, kappa);
}
fprintf(stderr,"\b\b\n");

<<paStats covariance>>=
if (cufftExecC2C(plan, d__psd, d__psd, CUFFT_FORWARD) 
    != CUFFT_SUCCESS){
  fprintf(stderr,"CUFFT Error: Unable to execute plan\n");
 }
if (cudaThreadSynchronize() != cudaSuccess){
  fprintf(stderr, "Cuda error: Failed to synchronize\n");
 }
blockDim = dim3(16,16);
gridDim = dim3( 1+NU/16 , 1+NU/16 );
covariance_extraction LLL gridDim,blockDim RRR( d__cov, NU, d__psd, NF, kappa);
covariance_extraction LLL gridDim,blockDim RRR( d__cov + NU2, NU, d__psd + NF2, NF, kappa);

<<paStats covariance with sources (different heights)>>=
blockDim = dim3(16,16);
gridDim = dim3( 1+NU/16 , 1+NU/16 );
for (int k_LAYER=0;k_LAYER<_N_LAYER_;k_LAYER++) {
  if (cufftExecC2C(plan, d__psd + 2*k_LAYER*NF2, d__psd + 2*k_LAYER*NF2, CUFFT_FORWARD) 
      != CUFFT_SUCCESS){
    fprintf(stderr,"CUFFT Error: Unable to execute plan\n");
  }
  if (cudaThreadSynchronize() != cudaSuccess){
    fprintf(stderr, "Cuda error: Failed to synchronize\n");
  }
  covariance_extraction LLL gridDim,blockDim RRR( d__cov + 2*k_LAYER*NU2,     NU, d__psd + 2*k_LAYER*NF2,     NF, kappa);
  covariance_extraction LLL gridDim,blockDim RRR( d__cov + (2*k_LAYER+1)*NU2, NU, d__psd + (2*k_LAYER+1)*NF2, NF, kappa);
}

@ The extraction of the covariance is done with the kernel:
<<covariance extraction>>=
__global__ void covariance_extraction(float *cov_out, int NC_out, 
				      float2 *cov_in, int NC_in, float kappa)
{
  int i, j, k_out, k_in, h;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  if ( (i<NC_out) && (j<(NC_out)) ) {
    h = (NC_out-1)/2;
    k_out = (NC_out - 1 - (i+h)%NC_out)*NC_out + (NC_out - 1 - (j+h)%NC_out);
    if (i>=((NC_out+1)/2))
      i = kappa*(i - NC_out) + NC_in;
    else
      i *= kappa;
    if (j>=(NC_out+1)/2)
      j = kappa*(j - NC_out) + NC_in;
    else
      j *= kappa;
    k_in = i*NC_in + j;      
    cov_out[k_out] = cov_in[k_in].x;
  }
}

@ The product between the covariance matrix and a vector is done by interpolating the matrix values into [[d__cov]] and multiplying and summing the interpolated covariance values with the vector values.
[[d__cov]] is a $[[NU]]\times[[NU]]$ array sampled at the coordinates: $$x,y = \left[ -{[[NU]]-1\over 2},\dots,{[[NU]]-1\over 2}  \right]\times [[sampling]]$$ covering a $\left([[NU]]-1\right)\times [[sampling]]$ area.
The covariance matrix is defined between the coordinate grids $(x_1,y_1)$ and $(x_2,y_2)$.
The slopes are sampled on the grid $(x_2,y_2)$ with $(x,y)_2 =d_2\left((i,j) + (1 - N_2)/2 \right)$ and $i,j=0,\dots,N_2-1$
 and the phase values are sampled on the grid $(x_1,y_1)$ with $(x,y)_1 =d_1\left(i + (1 - N_1)/2 \right)$ and $i,j=0,\dots,N_1-1$.
The covariance matrix size is then $N_1^2\times N_2^2$.
<<matrix-to-vector product>>=
void paStats::MVM(float *out_vector, float *in_vector, 
		  float d1, float g1, int N1, 
		  float d2, int N2,
		  atmosphere *atm, 
		  source *phase_src, int N_P_SRC,
		  source *slopes_src, int N_S_SRC) 
{
  dim3 blockDim(16,16);
  dim3 gridDim( 1 + N1/16 , 1 + N1/16 , N_P_SRC);
  stopwatch tid;
  tid.tic();
  MVM_kernel LLL gridDim,blockDim RRR (out_vector, in_vector, 
				       sampling, NU, d__cov,
				       d1, g1, N1,
				       d2, N2,
				       atm->d__turbulence,
				       phase_src->dev_ptr,
				       slopes_src->dev_ptr, N_S_SRC);
  tid.toc("Product phase/slope covariance");
}
@ with the kernel
<<matrix-to-vector product kernel>>=
__global__ void MVM_kernel(float *out_vector, float *in_vector, 
			   float sampling, int NU, float *cov,
			   float d1, float g1, int N1, 
			   float d2, int N2,
			   profile *turb, 
			   source *src1, source *src2, int N_SRC2) 
{
  int col ,row, i1, j1, i2, j2, k, i_P_SRC, j_S_SRC, offset;
  float xi, yi, x1, y1, covi_x, covi_y, g2;
  i1 = blockIdx.x * blockDim.x + threadIdx.x;
  j1 = blockIdx.y * blockDim.y + threadIdx.y;
  i_P_SRC = blockIdx.z;
  if ( (i1<N1) & (j1<N1) ) {
    row = j1 + i1*N1 + i_P_SRC*N1*N1;
    out_vector[row] = 0;
    covi_x = covi_y = 0;
    for (j_S_SRC=0;j_S_SRC<N_SRC2;j_S_SRC++) {
      offset = j_S_SRC*2*_N_LAYER_;
      for (k=0;k<_N_LAYER_;k++) {
	g2 = 1.0 - turb->altitude[k]/src2[j_S_SRC].height;
	<<coordinates 1>>
	    for (i2=0;i2<N2;i2++) {
	      for (j2=0;j2<N2;j2++) {
		col = j2 + i2*N2;
		<<coordinates 2>>
		    covi_x = interpolate(xi,yi,cov + (2*k+offset)*NU*NU,sampling,NU);
		covi_y = interpolate(xi,yi,cov+(2*k+1+offset)*NU*NU,sampling,NU);
		out_vector[row] += covi_x*in_vector[col + 2*j_S_SRC*N2*N2];
		out_vector[row] += covi_y*in_vector[col + (2*j_S_SRC+1)*N2*N2];
	      }
	    }
      }
    }
  }
}
<<2D interpolation>>=
__device__ float interpolate(float xi, float yi, 
	   float *z, float sampling, int NU)
{
int ndx;
float s, t, fs, ft, onemt;
<<bilinear interpolation>>
<<bilinear interpolation end>>
}
<<2D interpolation kernel>>=
__global__ void interpolate(float *zi, float xi, float yi, 
	   float *z, float sampling, int NU)
{
int ndx;
float s, t, fs, ft, onemt;
<<bilinear interpolation>>
onemt = 1 - t;
*zi = ( z[ndx]*onemt + z[ndx+1]*t )*(1-s) + 
        ( z[ndx+NU]*onemt + z[ndx+NU+1]*t )*s;
}
@  $x_1$ and $y_1$ coordinates:
<<coordinates 1>>=
x1 = g1*d1*(i1 + (1-N1)*0.5);
y1 = g1*d1*(j1 + (1-N1)*0.5);
@  $x_2$ and $y_2$ coordinates:
<<coordinates 2>>=
xi = g2*d2*(i2 + (1-N2)*0.5) - x1;
yi = g2*d2*(j2 + (1-N2)*0.5) - y1;
@ The interpolation starts with normalizing the coordinates to the pixel size i.e.
<<bilinear interpolation>>=
s = (NU-1)*( xi/(sampling*(NU-1)) + 0.5 );
t = (NU-1)*( yi/(sampling*(NU-1)) + 0.5 );
@  and taking the floor integer part to locate the bottom--left coordinate of the pixels surrounding [[xi]] and [[yi]]
<<bilinear interpolation>>=
fs  = floorf(s);
ft  = floorf(t);
ndx = __float2int_rd( ft + fs*NU );
@ Next, one checks if the edges of the array have been reached
<<bilinear interpolation>>=
if (s==(NU-1)) { s += 1 - fs; ndx -= NU; } else { s -= fs; }    
if (t==(NU-1)) { t += 1 - ft; ndx -= 1; }   else { t -= ft; }
@ and finally the interpolation is computed as
<<bilinear interpolation end>>=	 
onemt = 1 - t;
return ( ( z[ndx]*onemt + z[ndx+1]*t )*(1-s) + 
        ( z[ndx+NU]*onemt + z[ndx+NU+1]*t )*s );
@ matrix--to--vector product
<<MAC>>=
covi = interpolate(xi,yi,cov + 2*k*NU*NU,sampling,NU);
out_vector[row] += covi*in_vector[col];
covi = interpolate(xi,yi,cov+(2*k+1)*NU*NU,sampling,NU);
out_vector[row] += covi*in_vector[col+N2*N2];
@
\subsection{Tests}
\label{sec:tests}

The test routine is written:
<<aaStats.bin>>=

#include <iostream>
#include <fstream>
#include <iomanip>
using namespace std;

#include "cublas_v2.h"
#include "ceo.h"
#include "aaStats.h"
#include "BTBT.h"
using namespace std;
#define N_RUN 5
#define N_SAMPLE 100

__global__ void fill(float *A, int m_a, int n_a) {
  int i, j, k;
  float n;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  k = i*m_a +j;
  n = (float) m_a*n_a;
  if (k<n)
    A[k] = ((float)k)/n;
}

int main( void) {
  atmosphere atm;
  aaStats aa;
  paStats pa;
  BTBT C, S;
  int k, data_size, M, N, NX, NY, NA, MA, k_N, k_SAMPLE, osf;
  float altitude[] = {0},
        xi0[] = {1},
        wind_speed[] = {10},
  	wind_direction[] = {0};
  float *x, *y, *d__x, *d__y, *d__A;
  stopwatch tid;
  cublasHandle_t handle;
  cublasCreate(&handle);
  cublasStatus_t status;

  atm.setup(0.15,30,altitude,xi0,wind_speed,wind_direction);

  int N_[N_RUN] = {20,40,64,84,150};
  float aa_full_mvm_et[N_RUN], pa_full_mvm_et[N_RUN], aa_comp_mvm_et[N_RUN], pa_comp_mvm_et[N_RUN], 
    aa_comp_eval_et[N_RUN], pa_comp_eval_et[N_RUN];

  dim3 blockDim(16,16);
  dim3 gridDim;
  float alpha, beta;
  alpha = 1;
  beta  = 0;
  osf = 2;

  std::ofstream aa_fid, pa_fid;
  aa_fid.open ("aa_runtime.txt");
  aa_fid.setf(ios::fixed, ios::floatfield);
  aa_fid.precision(3);
  aa_fid << "\nAASTATS:\n";
  aa_fid << " N   FULL MVM   COMP MVM   COMP EVAL\n";

  pa_fid.open ("pa_runtime.txt");
  pa_fid.setf(ios::fixed, ios::floatfield);
  pa_fid.precision(3);
  pa_fid << "\nPASTATS:\n";
  pa_fid << " N   FULL MVM   COMP MVM   COMP EVAL\n";

  for (k_SAMPLE=0;k_SAMPLE<N_SAMPLE;k_SAMPLE++) {

  //AASTATS TESTS
  for (k_N=0;k_N<N_RUN;k_N++) {

    N = N_[k_N];
    NX = N*N*2;
    data_size = sizeof(float)*NX;

    x = (float *)malloc( data_size );
    y = (float *)malloc( data_size );
    HANDLE_ERROR( cudaMalloc((void**)&d__x, data_size ) );
    HANDLE_ERROR( cudaMalloc((void**)&d__y, data_size ) );

    for (k=0;k<NX;k++) {
      x[k] = (float)k;
    }
    HANDLE_ERROR( cudaMemcpy( d__x, x, data_size, cudaMemcpyHostToDevice) );

    aa.setup(N,&atm,0.1);
    C.setup(2,2,N,aa.d__cov);
    aa_comp_eval_et[k_N] = aa.cov_eval_et;
    
    //printf("\n AA VARIANCE: %.4E rd^2\n",aa.variance(0.1, &atm, 4, 2048));

    tid.tic();
    C.MVM(d__y,d__x);
    tid.toc(aa_comp_mvm_et + k_N,"Covariance MVM");
    HANDLE_ERROR( cudaMemcpy( y, d__y, data_size, cudaMemcpyDeviceToHost) );
    /* printf("\nMVM:\n"); */
    /* for (k=0;k<NX;k++) { */
    /*   printf("(%2d) %4.2E\n",k,y[k]); */
    /* } */
    FILE *aa_fid;
    char filename[100];
    sprintf(filename,"aa_mvm%03d.bin",N);
    aa_fid = fopen(filename,"wb");
    fwrite(y,sizeof(float),NX,aa_fid);
    fclose(aa_fid);

    if (N<=100) {
      M = 2*N*N;
      data_size = sizeof(float)*M*M;
      HANDLE_ERROR( cudaMalloc((void**)&d__A, data_size ) );
      gridDim = dim3(1+M/16,1+M/16);
      tid.tic();
      fill LLL gridDim,blockDim RRR (d__A, M, M);
      tid.toc("Filling of A");
      tid.tic();
      status = cublasSgemv(handle, CUBLAS_OP_N, M, M, &alpha, d__A, M, d__x, 1, &beta, d__y, 1);
      tid.toc(aa_full_mvm_et + k_N,"A MVM");
      if (status!=CUBLAS_STATUS_SUCCESS)
    	printf(">>> ERROR! CUBLAS FAILED! <<<\n");
      HANDLE_ERROR( cudaFree( d__A ) );
    }  else aa_full_mvm_et[k_N]=0;

    aa.cleanup();
    C.cleanup();
    HANDLE_ERROR( cudaFree( d__x ) );
    HANDLE_ERROR( cudaFree( d__y ) );
    free(x);
    free(y);
  }
  for (k_N=0;k_N<N_RUN;k_N++) {
    aa_fid << setw(3) << N_[k_N] << "   " << setw(6) << aa_full_mvm_et[k_N] << "     " << aa_comp_mvm_et[k_N] << "     " << aa_comp_eval_et[k_N] << "\n";
  }

  //PASTATS TESTS
  for (k_N=0;k_N<N_RUN;k_N++) {

    N = 2*N_[k_N]+1;
    NX = N*N*2;
    NY = N*N;
    data_size = sizeof(float);

    x = (float *)malloc( data_size*NX );
    y = (float *)malloc( data_size*NY );
    HANDLE_ERROR( cudaMalloc((void**)&d__x, data_size*NX ) );
    HANDLE_ERROR( cudaMalloc((void**)&d__y, data_size*NY ) );

    for (k=0;k<NX;k++) {
      x[k] = (float)k;
    }
    HANDLE_ERROR( cudaMemcpy( d__x, x, data_size*NX, cudaMemcpyHostToDevice) );
    pa.setup(N_[k_N],osf,&atm,0.1);
    S.setup(1,2,N,pa.d__cov);
    pa_comp_eval_et[k_N] = pa.cov_eval_et;

    tid.tic();
    S.MVM(d__y,d__x);
    tid.toc(pa_comp_mvm_et + k_N,"Covariance MVM");
    HANDLE_ERROR( cudaMemcpy( y, d__y, data_size*NY, cudaMemcpyDeviceToHost) );
    /* printf("\nMVM:\n"); */
    /* for (k=0;k<NY;k++) { */
    /*   printf("(%3d) %+6.4E\n",k,y[k]); */
    /* } */
    FILE *aa_fid;
    char filename[100];
    sprintf(filename,"pa_mvm%03d.bin",N);
    aa_fid = fopen(filename,"wb");
    fwrite(y,sizeof(float),NY,aa_fid);
    fclose(aa_fid);

    if (N<=100) {
      MA = N*N;
      NA = 2*MA;
      data_size = sizeof(float)*MA*NA;
      HANDLE_ERROR( cudaMalloc((void**)&d__A, data_size ) );
      gridDim = dim3(1+MA/16,1+NA/16);
      tid.tic();
      fill LLL gridDim,blockDim RRR (d__A, MA , NA);
      tid.toc("Filling of A");
      tid.tic();
      status = cublasSgemv(handle, CUBLAS_OP_N, MA, NA, &alpha, d__A, MA, d__x, 1, &beta, d__y, 1);
      tid.toc(pa_full_mvm_et + k_N,"A MVM");
      if (status!=CUBLAS_STATUS_SUCCESS)
  	printf(">>> ERROR! CUBLAS FAILED! <<<\n");
      HANDLE_ERROR( cudaFree( d__A ) );
    } else pa_full_mvm_et[k_N]=0;

    pa.cleanup();
    S.cleanup();
    HANDLE_ERROR( cudaFree( d__x ) );
    HANDLE_ERROR( cudaFree( d__y ) );
    free(x);
    free(y);
  }
  for (k_N=0;k_N<N_RUN;k_N++) {
     pa_fid << setw(3) << N_[k_N] << "   " << setw(6) << pa_full_mvm_et[k_N] << "     " << pa_comp_mvm_et[k_N] << "     " << pa_comp_eval_et[k_N] << "\n";
  }

  } // SAMPLE LOOP

  atm.cleanup();
  cublasDestroy(handle);
  aa_fid.close();
  pa_fid.close();
}

@  The following is the Matlab script to test  the [[MVM_kernel]]:
<<MVM kernel test>>=
kern = parallel.gpu.CUDAKernel('aaStats.ptx','aaStats.cu','MVM_kernel');
kern.ThreadBlockSize = [16,16];
kern.GridSize = [2,2];
d1 = 2/3;
d2 = 2/3;
NU = 7;
N1 = 4;
N2 = 4;
g1 = 1;
g2 = 1;
[x,y] = meshgrid( linspace(-1,1,4) );
z = x(:) + 1i*y(:);
c = abs( bsxfun( @minus, z , z.') );
idx = [13 9 5 1 2 3 4];
cs = mat2cell( c , ones(1,4)*4,ones(1,4)*4);
cov = cell2mat(cellfun( @(x) x(idx)', cs(idx) , 'UniformOutput', false));
vout = gpuArray.zeros(16^2,1,'single');
vin = gpuArray.ones(16^2,1,'single');
sampling = 2/3;
