% -*- mode: Noweb; noweb-code-mode: c-mode -*-
@
\index{gmtMirrors}
\section{The files}
\label{sec:files}

\subsection{Header}
\label{sec:header}

<<gmtMirrors.h>>=
#ifndef __GMTMIRRORS_H_
#define __GMTMIRRORS_H_

#ifndef __RAYTRACING_H__
#include "rayTracing.h"
#endif 

#ifndef __SOURCE_H__
#include "source.h"
#endif

<<GMT M1 structure>>
<<GMT M2 structure>>

#endif // __GMTMIRRORS_H_
@

\subsection{Source}
\label{sec:source}

<<gmtMirrors.cu>>=
#include "gmtMirrors.h"
<<GMT chief ray tracing kernel>>
<<GMT ray tracing kernel>>
<<GMT blocking kernel>>
<<GMT track kernel>>
<<M1 edge sensors initialization kernel>>
<<M1 edge sensor data kernel>>

<<GMT M1 functions>>
<<GMT M2 functions>>
@ 

\subsection{Python}
\label{sec:python}

\index{gmtMirrors!python}
<<gmtMirrors.pxd>>=
from numpy cimport ndarray
from utilities cimport cuFloatArray, cuDoubleArray
from rayTracing cimport rtd, vector, coordinate_system, bundle, \
    zernikeS, ZernikeS, Coordinate_system, Bundle, Coordinates
from source cimport Source
cdef extern from "gmtMirrors.h":
<<gmtMirrors.pxd contents>>
<<class definitions>>
@ 

\subsubsection{GMT mirrors}
\label{sec:gmt-mirrors}

\index{gmtMirrors!python!GmtMirrors}

<<gmtMirrors.pxd contents>>=
    cdef cppclass gmt_m1:
        vector *v0_EDGE_SENSOR
        vector *dv0_EDGE_SENSOR
        vector *v_EDGE_SENSOR
        vector *dv_EDGE_SENSOR
        void test_ray_tracing()
        <<python GMT M12 functions>>
        void track(float *, float *, int, int)
        void edge_sensors_data()
@  where
<<python GMT M12 functions>>=
int M_ID
rtd D_assembly, D_full, D_clear, L, conic_c, conic_k
coordinate_system aperture_CS
coordinate_system conic_CS
coordinate_system rigid_body_CS
coordinate_system motion_CS
coordinate_system TT_CS
void setup(float , int )
void setup(float , int , int)
void setup(float , int, zernikeS *)
void setup(float , int, zernikeS *, int)
void cleanup()
void update(vector , vector ,int )
void reset()
void trace(bundle *)
void blocking(bundle *)
void global_tiptilt(float , float )
@
<<class definition>>=
cdef class GmtMirrors:
    cdef:
        readonly float D, D_px, focal_plane_distance, focal_plane_radius
        readonly GMT_M1 M1
        readonly GMT_M2 M2   
@ 
<<gmtMirrors.pyx>>=
cdef class GmtMirrors:
    """
    A class container from GMT_M1 and GMT_M2 classes

    Parameters
    ----------
    D : float
        The size of the pupil plane in meter
    D_px : int
        The size of the pupil plane in pixel
    M1_radial_order : int, optionnal
        The largest radial order of the Zernike polynomials on M1 segments, default to 0
    M2_radial_order : int, optionnal
        The largest radial order of the Zernike polynomials on M2 segments, default to 0

    Attributes
    ----------
    D : float
        The size of the pupil plane in meter
    D_px : int
        The size of the pupil plane in pixel
    M1 : GMT_M1
        The GMT M1 CEO class
    M2 : GMT_M2
        The GMT M2 CEO class
    sphere_radius : float
        The curvature radius of the ray tracing reference sphere

    See also
    --------
    GMT_M1 : the class for GMT M1 model
    GMT_M2 : the class for GMT M2 model
    Source : a class for astronomical sources
    cuFloatArray : an interface class between GPU host and device data for floats

    Examples
    --------
    >>> import ceo

    The mandatory parameters are the size of the pupil plane in meter or in pixel

    >>> gmt = ceo.GMT_MX(25.5,256)

    If more that one source (lets say 3) is going to be propagated through the telescope:

    >>> gmt = ceo.GMT_MX(25.5,256, N_SRC=3)

    A combination of Zernike polynomials can be applied to M1 and M2 segments by specifying the largest radial order on each mirror

    >>> gmt = ceo.GMT_MX(25.5,256, M1_radial_order=8, M2_radial_order=14)

    A source is propagated (geometrically) through the telescope with the following procedure:
u
    >>> src = ceo.Source("R",rays_box_size=25.5,rays_box_sampling=256,rays_origin=[0.0,0.0,25])
    >>> gmt.propagate(src)

    and the wavefront phase is retrieved either as a 2D map cuFloatArray object with

    >>> gpu_ps2d = src.phase()

    or as a 1D vector with 

    >>> gpu_ps1d = src.wavefront.phase()
    """
    def __cinit__(self, float D, float D_px, 
                 int M1_radial_order=0, int M2_radial_order=0):
        self.D = D
        self.D_px = D_px
        self.M1 = GMT_M1(D, D_px, radial_order=M1_radial_order)
        self.M2 = GMT_M2(D, D_px, radial_order=M2_radial_order)
        self.focal_plane_distance = -5.830
        self.focal_plane_radius   =  2.197173

    def propagate(self,Source src,where_to="exit pupil",M2_is_a_stop=True):
        """
        Propagate the Source object to the pupil plane conjugated to M1

        Parameters
        ----------
        src : Source
            The Source object
        where_to: char, optional
            Either "exit pupil" or "focal plane"; default: "exit pupil"
        M2_is_a_stop: boolean, optional
            Set if M2 acts also a stop; default: True
        """
        #src.reset()
        if M2_is_a_stop:
            self.M2.blocking(src.rays)
        self.M1.trace(src.rays)
        self.M2.trace(src.rays)
#        src.sphere_distance
#        src.rays.to_sphere(self.sphere_radius,sphere_distance = src.sphere_distance)
        if where_to=="exit pupil":
            src.rays.to_sphere(focal_plane_distance=self.focal_plane_distance,
                               focal_plane_radius=self.focal_plane_radius)
            src.opd2phase()
        if where_to=="focal plane":
            src.rays.to_z_plane(self.focal_plane_distance)

    def reset(self):
        """
        Reset M1 and M2 mirror segments to their original locations and shapes
        """
        self.M1.reset()
        self.M1.zernike.reset()
        self.M2.reset()
        self.M2.zernike.reset()
@
\subsubsection{GMT M1}
\label{sec:gmt-m1-1}

\index{gmtMirrors!python!GMT\_M1}
<<class definitions>>=
cdef class GMT_M1:
    cdef:
        gmt_m1 *_c_gmt_m12
        public Coordinates v0_EDGE_SENSOR, v_EDGE_SENSOR, \
            dv0_EDGE_SENSOR, dv_EDGE_SENSOR
    <<GMT M12 class properties>>    
@
<<gmtMirrors.pyx>>=
# GMT M1
cdef class GMT_M1:
    <<GMT M12 docstring>>

    def __cinit__(self, float D, int D_px, int radial_order=0, int N_SRC=1):
        self._c_gmt_m12 = new gmt_m1()
        <<GMT M12 constructor>>

        self.v0_EDGE_SENSOR    = Coordinates((48,3))
        self.v0_EDGE_SENSOR.v  = self._c_gmt_m12.v0_EDGE_SENSOR
        self.dv0_EDGE_SENSOR   = Coordinates((24,3))
        self.dv0_EDGE_SENSOR.v = self._c_gmt_m12.dv0_EDGE_SENSOR
        self.v_EDGE_SENSOR     = Coordinates((48,3))
        self.v_EDGE_SENSOR.v   = self._c_gmt_m12.v_EDGE_SENSOR
        self.dv_EDGE_SENSOR   = Coordinates((24,3))
        self.dv_EDGE_SENSOR.v = self._c_gmt_m12.dv_EDGE_SENSOR

    <<GMT M12 methods>>

    def test(self):
        self._c_gmt_m12.test_ray_tracing();

    def track(self, ndarray x, ndarray y, int segId):

        cdef cuFloatArray gx, gy, gz
        gx = cuFloatArray( host_data = x )
        gy = cuFloatArray( host_data = y )
        self._c_gmt_m12.track(gx._c_gpu.dev_data,
                              gy._c_gpu.dev_data,
                              x.size, segId)
        return gx.host(), gy.host()

    def edge_sensors_data(self):
        self._c_gmt_m12.edge_sensors_data()

    def reset(self):
        """
        Reset the segments to their original prescription
        """
        self.motion_CS.origin[:] = 0.0
        self.motion_CS.euler_angles[:] = 0.0
        self.motion_CS.update()
        self.edge_sensors_data()
@
<<GMT M12 constructor>>=
self.zernike = ZernikeS(radial_order,N_SURF=7)
self._c_gmt_m12.setup(D, D_px, <zernikeS *> self.zernike._c_zernikeS, 0)

self.aperture_CS   = Coordinate_system(7)
self.conic_CS      = Coordinate_system(7)
self.motion_CS     = Coordinate_system(7)
self.rigid_body_CS = Coordinate_system(7)
self.TT_CS         = Coordinate_system(1)

self.aperture_CS.init(   &(self._c_gmt_m12.aperture_CS)   )
self.conic_CS.init(      &(self._c_gmt_m12.conic_CS)      )
self.motion_CS.init(     &(self._c_gmt_m12.motion_CS)     )
self.rigid_body_CS.init( &(self._c_gmt_m12.rigid_body_CS) )
self.TT_CS.init(         &(self._c_gmt_m12.TT_CS)         )

@ 
<<GMT M12 methods>>=
def __dealloc__(self):
    self._c_gmt_m12.cleanup()

def trace(self, Bundle rays):
    """
    Ray tracing to the mirror

    Parameters
    ----------
    rays : Bundle
        A ray bundle used to propagate the light

    See also
    --------
    Bundle: a class representing a bundle of light rays used for geometric propagation
    """
    self._c_gmt_m12.trace(rays._c_bundle)

def blocking(self, Bundle rays):
    """
    Makes the mirror acting as a stop

    Parameters
    ----------
    rays : Bundle
        A ray bundle used to propagate the light

    See also
    --------
    Bundle: a class representing a bundle of light rays used for geometric propagation
    """
    self._c_gmt_m12.blocking(rays._c_bundle)

def update(self, list origin=[0.0,0.0,0.0], list euler_angles=[0.0,0.0,0.0], int idx=0):
    """
    Updates the position of the mirror segments

    Parameters
    ----------
    origin : list of float, optional
        The location of a segment center; default: [0,0,0]
    euler_angles : list of float, optional
        The tip, tilt and clock angles of a segment; default: [0,0,0]
    idx : int
        The segment index from 1 to 7
    """
    assert idx>0 and idx<8, "The segment index must be between 1 and 7!"
    self.motion_CS.origin[idx-1,:] = origin
    self.motion_CS.euler_angles[idx-1,:] = euler_angles
    self.motion_CS.update()

def global_tiptilt(self, float tip, float tilt):
    """
    Applies a global tip--tilt to M1

    Parameters
    ----------
    tip : float
        The x axis angle
    tilt : float
        The y axis angle
    """
    self._c_gmt_m12.global_tiptilt(tip, tilt);

property D_assembly:
    def __get__(self):
        return self._c_gmt_m12.D_assembly

property D_full:
    def __get__(self):
        return self._c_gmt_m12.D_full

property D_clear:
    def __get__(self):
        return self._c_gmt_m12.D_clear

property L:
    def __get__(self):
        return self._c_gmt_m12.L

property conic_c:
    def __get__(self):
        return self._c_gmt_m12.conic_c

property conic_k:
    def __get__(self):
        return self._c_gmt_m12.conic_k

property M_ID:
    def __get__(self):
        return self._c_gmt_m12.M_ID
@ with
<<GMT M12 docstring>>=
"""
A class to represent GMT M1 or M2 segmented mirror

Parameters
----------
D : float
    The size in meter of the pupil plane (must be equal or larger than the telescope diameter)
D_px : float
    The size in pxixel of the pupil plane
radial_order : int, optional
    The radial order of the last Zernike polynomials, default to 0

Attributes
----------
D_assembly : rtd
    The mirror assembly diameter
D_full : rtd
    The segment full aperture diameter
D_clear : rtd
    The segment clear aperture diameter
L : rtd
    The distance from the optical axis to the center of the tilted peripheral segments
conic_c : rtd
    The inverse of the mirror radius of curvature
conic_k : rtd
    The conic parametert
M_ID : int
    The mirror ID #
zernike : ZernikeS
    The figure of the segments as Zernike surface object
aperture_CS : Coordinate_system
    The segment aperture coordinate system
conic_CS : Coordinate_system
    The segment conic coordinate system
motion_CS : Coordinate_system
    The segment motion coordinate system
rigid_body_CS : Coordinate_system
    The segment rigid body coordinate system
TT_CS : Coordinate_system
    The mirror global tip-tilt coordinate system

Examples
--------
>>> import ceo
>>> M1 = ceo.GMT_M1(25.5,101)

With multiple sources:

>>> M2 = ceo.GMT_M2(25.5,101,N_SRC=4)

With Zernike modes

>>> M1 = ceo.GMT_M1(25.5,101,radial_order=4)

An M1 segment (#2) is displaced in x of 2 micron and tilted in y of 50mas with

>>> import math
>>> theta = 50e-3*math.pi/180/3600
>>> M1.update(origin=[2e-6,0,0],euler_angles=[0,theta,0],idx=2)

A global tip-tilt of M1 is achieved with

>>> M1.global_tiptilt(theta,-theta)

M2 pointing neutral and coma neutral tip-tilt are realized with

>>> M2.pointing_neutral(theta,-theta)
>>> M2.coma_neutral(theta,-theta)
"""
@ and with
<<GMT M12 class properties>>=
cdef:
    public ZernikeS zernike
    public Coordinate_system aperture_CS
    public Coordinate_system conic_CS
    public Coordinate_system rigid_body_CS
    public Coordinate_system motion_CS
    public Coordinate_system TT_CS
@ 

\subsubsection{GMT M2}
\label{sec:gmt-m2-1}

\index{gmtMirrors!python!GMT\_M2}
<<gmtMirrors.pxd contents>>=
    cdef cppclass gmt_m2:
        <<python GMT M12 functions>>
        void pointing_neutral(float, float)
        void coma_neutral(float, float)
@
<<gmtMirrors.pyx>>=
# GMT M2
cdef class GMT_M2:
    <<GMT M12 docstring>>
    cdef gmt_m2 *_c_gmt_m12
    <<GMT M12 class properties>>    
    
    def __cinit__(self, float D, int D_px, radial_order=0, int N_SRC=1):
        self._c_gmt_m12 = new gmt_m2()
        <<GMT M12 constructor>>

    <<GMT M12 methods>>

    def pointing_neutral(self, float tip, float tilt):
        """
        Applies a pointing neutral global tip--tilt to M2

        Parameters
        ----------
        tip : float
            The x axis angle
        tilt : float
            The y axis angle
        """
        self._c_gmt_m12.pointing_neutral(tip, tilt);

    def coma_neutral(self, float tip, float tilt):
        """
        Applies a coma neutral global tip--tilt to M2

        Parameters
        ----------
        tip : float
            The x axis angle
        tilt : float
            The y axis angle
        """
        self._c_gmt_m12.coma_neutral(tip, tilt);

    def reset(self):
        """
        Reset the segments to their original prescription
        """
        self.motion_CS.origin[:] = 0.0
        self.motion_CS.euler_angles[:] = 0.0
        self.motion_CS.update()
@
\section{GMT M1}
\label{sec:gmt-m1}

\index{gmtMirrors!gmt\_m1}
A new structure to hold GMT M1 and M2 parameters and functions is defined.
<<GMT M1 structure>>=
struct gmt_m1 {
  <<GMT M12 parameters>>
  <<GMT M1 parameters>>
  <<GMT M12 functions>>
  void edge_sensors_data(void);
};
@  with
<<GMT M12 functions>>=
void setup(float _D_, int _D_px_);
void setup(float _D_, int _D_px_, zernikeS *ZS);
void setup(float _D_, int _D_px_, int N_SRC);
void setup(float _D_, int _D_px_, zernikeS *ZS, int N_SRC);
void cleanup(void);
void update(vector _origin_, vector _euler_angles_,int idx);
void reset(void);
void trace(bundle *rays);
void blocking(bundle *rays);
void global_tiptilt(float tip, float tilt);
void test_ray_tracing(void);
void track(float *x, float *y, int N, int idx);
@ 
The GMT M12 parameters are:
\begin{itemize}
\item the mirror ID:
<<GMT M12 parameters>>=
int M_ID;
@
\item the mirror assembly diameter $[[D_assembly]]$:
<<GMT M12 parameters>>=
rtd D_assembly;
@
\item the segment clear aperture diameter $[[D_clear]]$:
<<GMT M12 parameters>>=
rtd D_clear;
@
\item the segment full aperture diameter $[[D_full]]$:
<<GMT M12 parameters>>=
rtd D_full;
@
\item the obscuration ratio of the center segment $[[ri]]$
<<GMT M12 parameters>>=
rtd ri;
@
\item the tilt angle of the peripheral segment $[[beta]]$degree
<<GMT M12 parameters>>=
rtd beta;
@
\item the distance from the optical axis to the center of the tilted peripheral segments $[[L]]$m:
<<GMT M12 parameters>>=
rtd L;
@
\item the size of the square array containing M1 in meter and pixel [[D]] and [[D_px]]:
<<GMT M12 parameters>>=
rtd D;
int D_px;
@
\item the mirror total area as seen by an on--axis source in square meter and number of pixel
<<GMT M12 parameters>>=
rtd area0;
float area0_px;
@ 
\item the mirror total area as seen by the star propagating through the telescope
<<GMT M12 parameters>>=
rtd area;
@
\item the number of segment $[[N]]=7$
<<GMT M12 parameters>>=
int N;
@
\item the edge to center depth of the segment conic $[[depth]]$:
<<GMT M12 parameters>>=
rtd depth;
@
\item the reference frames of the apertures:
<<GMT M12 parameters>>=
coordinate_system aperture_CS;
@
\item the reference frames and origins of the conics:
<<GMT M12 parameters>>=
coordinate_system conic_CS;
vector conic_origin[7], *d__conic_origin;
@
\item the conic parameters:
<<GMT M12 parameters>>=
rtd conic_c, conic_k;
@
\item the reference frames of the rigid bodies:
<<GMT M12 parameters>>=
coordinate_system rigid_body_CS;
@
\item the reference frames of the motions:
<<GMT M12 parameters>>=
coordinate_system motion_CS;
@
\item the mirror height
<<GMT M12 parameters>>=
rtd height;
@
\item the M1 pupil mask [[V]]:
<<GMT M12 parameters>>=
mask *V;
@
\item the segment index offset (0 for M1 and 3 for M2):
<<GMT M12 parameters>>=
int idx_offset;
@
\item an array of Zernike surface, one per segment, [[ZS]]:
<<GMT M12 parameters>>=
zernikeS *ZS;
@
\item the segment piston mask
<<GMT M12 parameters>>=
int *d__piston_mask;
@
\item the reference frames of the edge sensors:
<<GMT M12 parameters>>=
coordinate_system edge_sensors_CS;
@
\item global tip--tilt transformation variables:
  \begin{itemize}
  \item a coordinate system:
<<GMT M12 parameters>>=
coordinate_system TT_CS;
@
\item a pointer to a matrix array:
<<GMT M12 parameters>>=
double *d__C;
@
\item a CUBLAS handle:
<<GMT M12 parameters>>=
cublasHandle_t handle;
@
\end{itemize}
 \end{itemize}


\subsection{Setup \& Cleanup}
\label{sec:setup--cleanup-1}

The GMT M1 segment have all the same clear aperture of 8.365m diameter.
The center segment has a hole of 2.4412m diameter.
The center aperture is centered on the vertex of the conic surface that defines M1.
The vertex is set as the origin of the global coordinate system (GCS).
The center of the peripheral segments are evenly located on a circle of radius 8.710m with a phase of 30 degrees.
The peripheral segments also tilted inwards by 13.522 degrees.
The [[GMT_M1]] structure is initialized with the size of the square array containing M1 in meter and pixel.
The size must be 25.5m or more to contain M1 fully.
\index{gmtMirrors!gmt\_m1!setup}
<<GMT M1 functions>>=
void gmt_m1::setup(float _D_, int _D_px_)
{
  ZS = NULL;
  <<M1 parameters>>
  <<GMT setup common>>
  <<M1 edge sensors>>
}
@ or
\index{gmtMirrors!gmt\_m1!setup}
<<GMT M1 functions>>=
void gmt_m1::setup(float _D_, int _D_px_, zernikeS *_ZS_)
{
  ZS = _ZS_;
  <<M1 parameters>>
  <<GMT setup common>>
  <<M1 edge sensors>>
}
@ where
<<M1 parameters>>=
M_ID    = 1;
D_px    = _D_px_;
D       = _D_;
D_assembly = 25.498;
D_full  = 8.417;
D_clear = 8.365;
area    = 368;
area0   = 368;
ri      = 2.4412/8.365;
beta    = 13.601685*PI/180.0;
L       = 8.710;
N       = 7;
conic_c = 1.0/36.0;
conic_k = 1-0.9982857;
height  = 0.0;
idx_offset = 0;
V = NULL;
@  
If an array of sources is propagated through the telescope then
\index{gmtMirrors!gmt\_m1!setup}
<<GMT M1 functions>>=
void gmt_m1::setup(float _D_, int _D_px_, int N_SRC)
{
  ZS = NULL;
  <<M1 parameters>>
  <<GMT setup common>>
  <<M1 edge sensors>>
}
@ or
\index{gmtMirrors!gmt\_m1!setup}
<<GMT M1 functions>>=
void gmt_m1::setup(float _D_, int _D_px_, zernikeS *_ZS_, int N_SRC)
{
  ZS = _ZS_;
  <<M1 parameters>>
  <<GMT setup common>>
  <<M1 edge sensors>>
}
@  where
<<GMT setup common>>=
vector __v0 = {0.0,0.0,0.0},
       __v = {D_full*0.5,0.0,0.0},
       origin[12],
       euler_angles[12];
rtd D_c, o, zo;
 int k, idx;    
char tag[16];

depth = conic_equation(&__v,&__v0,conic_k,conic_c);
D_c = L;
__v.x = L;
zo = conic_equation(&__v,&__v0,conic_k,conic_c);

<<M12 rigid body definition>>

<<M12 aperture definition>>

<<M12 conic definition>>

<<M12 motion definition>>

<<GMT global tip-tilt setup>>
@
\subsubsection{Rigid body coordinate systems}
\label{sec:rigid-body-coord}

The rigid body coordinate systems are aligned with the segment coordinate systems.
The origins $[x_O, y_O, z_O]$ of the segment coordinate systems are given with respect to the global coordinate system which origin is at the vertex of M1 conic surface: 
\begin{eqnarray}
  \label{eq:35}
  x_{O,k} &=& L\cos(\theta_{O,k}), \\
  y_{O,k} &=& L\sin(\theta_{O,k}), \\
  z_O &=& F(L),\\
\end{eqnarray}
with, for M1, $L = 8.71$m, $\theta_{O,k}=\pi(3-2k)/6, \forall k \in [0,5]$, $x_{O,6}=y_{O,6}=0$ and
\begin{equation}
  \label{eq:36}
  F(\rho) = {c\rho^2 \over 1 + \sqrt{1 - \kappa c^2 \rho^2} }.
\end{equation}
In addition to the change of origin with respect to the GCS, the segment coordinate system is rotated around the z--axis of $-k\pi/3$radian and then tilted around the x--axis of $\beta$.
\begin{center}
\input{rigidBodyCS.tex}
\end{center}
<<M12 rigid body definition>>=
origin[N-1].x = origin[N-1].y = 0.0;
origin[N-1].z = height;
euler_angles[N-1].x = euler_angles[N-1].y = 0.0;
euler_angles[N-1].z = (idx_offset/2)*PI;
for (k=0; k<N-1; k++)
{
  o = PI*(3-2*k)/6.0;
  <<segment index offset>>
  origin[idx].x = D_c*cos(o);
  origin[idx].y = D_c*sin(o);
  origin[idx].z = height + zo;
  euler_angles[idx].x = beta;
  euler_angles[idx].y = 0.0;
  euler_angles[idx].z = -PI*k/3.0;
}
sprintf(tag,"M%d RIGID BODY",M_ID);
rigid_body_CS.setup(origin, euler_angles, N, tag);
@ with
<<segment index offset>>=
idx = (k + idx_offset)%6;
@
\subsubsection{Aperture coordinate systems}
\label{sec:apert-coord-syst}


The coordinate systems of the segment apertures are defined with respect to the coordinate systems of the rigid body motions.
The apertures are directly above the segments such as they rest on the rim of the segments. 
<<M12 aperture definition>>=
origin[N-1].x = origin[N-1].y = 0.0;
origin[N-1].z = depth;
euler_angles[N-1].x = euler_angles[N-1].y = euler_angles[N-1].z = 0.0;
for (k=0; k<N-1; k++)
{
  <<segment index offset>>
  origin[idx].x = 0.0;
  origin[idx].y = 0.0;
  origin[idx].z = depth;
  euler_angles[idx].x = 0.0;
  euler_angles[idx].y = 0.0;
  euler_angles[idx].z = 0.0;
}
sprintf(tag,"M%d APERTURE",M_ID);
aperture_CS.setup(origin, euler_angles, N, tag);
@
\subsubsection{Conic coordinate systems}
\label{sec:conic-coord-syst}


The coordinate systems of the segment conics are defined with respect to the coordinate systems of the rigid body motions.
Both coordinate systems share the same origin but x--axis and y--axis are parallel to the x--axis and y--axis of the GCS.
The origins of the segment conics are also given in the coordinate systems of the segment conics.
\begin{center}
\begin{tikzpicture}
  \draw[->] (-25mm,0) -- (35mm,0) node[below] {$\bar x$};
  \draw[->] (0,-25mm) -- (0,35mm) node[right] {$\bar y$};
  \draw[thin,dashed] (0,0) circle [radius=21mm];
  \coordinate (O) at (0,0);
  \draw (O) circle [radius=10mm] node[above left=3mm] {7};
  \draw[->,thick,red] ($(O)+(-5mm,0)$) -- ($(O)+(5mm,0)$) node[below] {$\hat x$};
  \draw[->,thick,red] ($(O)+(0,-5mm)$) -- ($(O)+(0,5mm)$) node[right] {$\hat y$};
  \foreach \x in {1,...,6} {
    \coordinate (O) at (150-\x*60:21mm);
    \draw (O) circle [radius=10mm] node[above left=3mm] {\x};
    \draw[->,thick,red] ($(O)+(-5mm,0)$) -- ($(O)+(5mm,0)$) node[below] {$\check x$};
    \draw[->,thick,red] ($(O)+(0,-5mm)$) -- ($(O)+(0,5mm)$) node[right] {$\check y$};

  }    
\end{tikzpicture}  
\end{center}
<<M12 conic definition>>=
origin[N-1].x = origin[N-1].y = origin[N-1].z = 0.0;
euler_angles[N-1].x = euler_angles[N-1].y = 0.0;
euler_angles[N-1].z = (idx_offset/2)*PI;
conic_origin[N-1].x = conic_origin[N-1].y = conic_origin[N-1].z = 0.0; 
for (k=0; k<N-1; k++)
{
  <<segment index offset>>
  o = PI*(3-2*k)/6.0;
  origin[idx].x = 0.0;
  origin[idx].y = 0.0;
  origin[idx].z = 0.0;
  euler_angles[idx].x = beta;
  euler_angles[idx].y = 0.0;
  euler_angles[idx].z = -PI*k/3.0;
  conic_origin[idx].x = -D_c*cos(o);
  conic_origin[idx].y = -D_c*sin(o);
  conic_origin[idx].z = -zo;
}
//euler_angles[0].x = 30.0*PI/180.0/3600.0;
sprintf(tag,"M%d CONIC",M_ID);
conic_CS.setup(origin, euler_angles, N, tag);
HANDLE_ERROR( cudaMalloc((void**)&d__conic_origin, sizeof(vector)*N ) );
HANDLE_ERROR( cudaMemcpy( d__conic_origin, conic_origin, 
			    sizeof(vector)*N, cudaMemcpyHostToDevice ) );
@
\subsubsection{Segment motion coordinate systems}
\label{sec:segm-moti-coord}


The motion coordinate systems are defined with respect to the coordinate systems of the rigid body motions.
For unperturbed segments, both coordinate systems coincide.
<<M12 motion definition>>=
for (k=0; k<N; k++)
{
  origin[k].x = 0.0;
  origin[k].y = 0.0;
  origin[k].z = 0.0;
  euler_angles[k].x = 0.0;
  euler_angles[k].y = 0.0;
  euler_angles[k].z = 0.0;
}
sprintf(tag,"M%d MOTION",M_ID);
motion_CS.setup(origin, euler_angles, N, tag);
@ 

\subsubsection{Cleanup, update \& reset}
\label{sec:cleanup-update-reset}


Memory is freed with
\index{gmtMirrors!gmt\_m1!cleanup}
<<GMT M1 functions>>=
void gmt_m1::cleanup(void)
{
  fprintf(stdout,"@(CEO)>gmt_m1: freeing memory!\n");
  <<GMT cleanup common>>
  <<GMT M1 cleanup common>>
}
@ with
<<GMT cleanup common>>=
fprintf(stdout," |-");
<<GMT global tip-tilt cleanup>>
fprintf(stdout," |-");
aperture_CS.cleanup();
fprintf(stdout," |-");
conic_CS.cleanup();
fprintf(stdout," |-");
rigid_body_CS.cleanup();
fprintf(stdout," |-");
motion_CS.cleanup();
fprintf(stdout," |-");
edge_sensors_CS.cleanup();
HANDLE_ERROR( cudaFree( d__conic_origin ) );
@
The rigid body motion parameters are updated with:
\index{gmtMirrors!gmt\_m1!update}
<<GMT M1 functions>>=
void gmt_m1::update(vector _origin_, vector _euler_angles_,int idx)
{
    <<GMT M12 update>>
}
@ where
<<GMT M12 update>>=
  //fprintf(stdout,"\n\x1B[31m");
motion_CS.update( _origin_, _euler_angles_, --idx);
//motion_CS.info();
@ 
The rigid body motion are reset to 0 with:
\index{gmtMirrors!gmt\_m1!reset}
<<GMT M1 functions>>=
void gmt_m1::reset(void)
{
    <<GMT M12 reset>>
}
@ where
<<GMT M12 reset>>=
vector zero;
zero.x = 0.0;
zero.y = 0.0;
zero.z = 0.0;
//fprintf(stdout,"\n\x1B[31m");
for (int k=0; k<N; k++)
   motion_CS.update( zero, zero, k);
//motion_CS.info();
@ 
\subsection{Blocking}
\label{sec:blocking}

The rays blocking with M1 is computed with
\index{gmtMirrors!gmt\_m1!blocking}
<<GMT M1 functions>>=
void gmt_m1::blocking(bundle *rays)
{
  <<GMT blocking common>>
}
@ where
<<GMT blocking common>>=
 rtd R2, Rri2;
 R2 = D_clear*D_clear*0.25;
 Rri2 = R2*ri*ri;
 V = &(rays->V);
 // fprintf(stdout,"R2=%5.2f - Rri2=%5.2f\n",R2,Rri2);  
 // printf("N_BUNDLE=%d\n",rays->N_BUNDLE);
 int nel = rays->N_RAY*rays->N_BUNDLE;
 dim3 blockDim(N_THREAD2);
 dim3 gridDim(nel/N_THREAD2+1);
 fill_ones_char LLL gridDim,blockDim RRR (V->m,nel);
 blockDim = dim3(N_THREAD,N_THREAD);
 gridDim  = dim3(rays->N_RAY/N_THREAD2+1,1,rays->N_BUNDLE);
 m1_blocking_kernel LLL gridDim , blockDim RRR (V->m, rays->d__ray, rays->N_RAY, 
					     Rri2, R2,
					     aperture_CS.d__R,
					     aperture_CS.d__origin,
					     rigid_body_CS.d__R,
					     rigid_body_CS.d__origin,
					     motion_CS.d__R,
					     motion_CS.d__origin);
 intersection LLL gridDim , blockDim RRR (V->m, rays->d__ray, rays->N_RAY);
@ and with the kernel
<<GMT blocking kernel>>=
__global__ void m1_blocking_kernel(char *mask, ray *d__ray, int N_RAY, 
				rtd inner2, rtd outer2,
				rtd *d__aperture_R, vector *d__aperture_origin,
				rtd *d__rigid_body_R, vector *d__rigid_body_origin,
				rtd *d__motion_R, vector *d__motion_origin)
{
  int i, j, ij, iCoordSys, iSource;
  rtd rho2;
  rtd x, y, z, x1, y1, s0, k, l, m;
  vector xyz, klm, xyz_GS, klm_GS;

  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = threadIdx.y;
  //  iCoordSys = blockIdx.y;
  ij = j * gridDim.x * blockDim.x + i;
  iSource = blockIdx.z;
  j = ij;
  ij += iSource*N_RAY;
  if  ( ( j<N_RAY ) && (d__ray[ij].v) )// & (iCoordSys<1) )
  {

    for (iCoordSys=0; iCoordSys<7; iCoordSys++)
      {

        <<from global CS to motion CS>>

	<<from motion CS to aperture intersection>>

	if (rho2<=outer2)
	  {
	    mask[ij] = 0;
          }
       }
   }
}
@
\subsection{Ray tracing}
\label{sec:ray-tracing}

  \begin{figure}
    \centering    
    \input{raytracingWorkflow.tex}
    \caption{Ray tracing flowchart for GMT M1 and M2 mirrors.}
    \label{fig:1}
  \end{figure}

The rays propagation through M1 is computed with
\index{gmtMirrors!gmt\_m1!trace}
<<GMT M1 functions>>=
void gmt_m1::trace(bundle *rays)
{
  rays->V.area = area0;
  <<GMT trace common>>
}
@ where
<<GMT trace common>>=
 dim3 blockDim, gridDim;
 rtd R2, Rri2;
 R2 = D_clear*D_clear*0.25;
 Rri2 = R2*ri*ri;
 /* if (V!=NULL) { */
 /*    blockDim = dim3(N_THREAD,N_THREAD); */
 /*    gridDim  = dim3(rays->N_RAY/N_THREAD2+1,1,rays->N_BUNDLE); */
 /*    intersection LLL gridDim , blockDim RRR (V->m, rays->d__ray, rays->N_RAY); */
 /* } */
 V = &(rays->V);
 // fprintf(stdout,"R2=%5.2f - Rri2=%5.2f\n",R2,Rri2);  
 blockDim = dim3(1,1);
 gridDim  = dim3(1,1,rays->N_BUNDLE);
 m1_trace_chief_kernel LLL gridDim , blockDim RRR (V->m, rays->d__chief_ray, 1, 
						   conic_CS.d__R,
						   conic_CS.d__origin,
						   conic_k, conic_c,
						   d__conic_origin,
						   rigid_body_CS.d__R,
						   rigid_body_CS.d__origin,
						   motion_CS.d__R,
						   motion_CS.d__origin,
						   ZS->max_n, ZS->n_mode,
						   ZS->d__a, ZS->d__cx, ZS->d__cy,
						   0.5*D_full);
 blockDim = dim3(N_THREAD,N_THREAD);
 gridDim  = dim3(rays->N_RAY/N_THREAD2+1,1,rays->N_BUNDLE);
 HANDLE_ERROR( cudaMemset(V->m, 0, sizeof(char)*rays->N_RAY*rays->N_BUNDLE ) );
 HANDLE_ERROR( cudaMemset(rays->d__piston_mask, 0, 
			  sizeof(int)*rays->N_RAY*rays->N_BUNDLE ) );
 m1_trace_kernel LLL gridDim , blockDim RRR (V->m, rays->d__ray, rays->N_RAY, 
					     Rri2, R2,
					     aperture_CS.d__R,
					     aperture_CS.d__origin,
					     conic_CS.d__R,
					     conic_CS.d__origin,
					     conic_k, conic_c,
					     d__conic_origin,
					     rigid_body_CS.d__R,
					     rigid_body_CS.d__origin,
					     motion_CS.d__R,
					     motion_CS.d__origin,
					     ZS->max_n, ZS->n_mode,
					     ZS->d__a, ZS->d__cx, ZS->d__cy,
					     0.5*D_full,
					     rays->d__chief_ray,
					     rays->d__piston_mask);
intersection LLL gridDim , blockDim RRR (V->m, rays->d__ray, rays->N_RAY);
float previous_nnz = rays->V.nnz;
//fprintf(stdout,"M%d previous nnz rays: %f\n",M_ID,previous_nnz);
rays->V.set_filter_quiet();
//fprintf(stdout,"M%d current nnz rays: %f\n",M_ID,rays->V.nnz);
if (previous_nnz<rays->N_RAY)
  rays->V.area *= rays->V.nnz/previous_nnz;
//fprintf(stdout,"M%d current area: %f\n",M_ID,rays->V.area);
@ and with the kernel
<<GMT ray tracing kernel>>=
__global__ void m1_trace_kernel(char *mask, ray *d__ray, int N_RAY, 
				rtd inner2, rtd outer2,
				rtd *d__aperture_R, vector *d__aperture_origin,
				rtd *d__conic_R, vector *d__conic_origin,
                                const rtd Fk, const rtd Fc,
                                vector *d__conic_self_origin,
				rtd *d__rigid_body_R, vector *d__rigid_body_origin,
				rtd *d__motion_R, vector *d__motion_origin,
				int max_n, int n_mode,
				rtd *d__a, rtd *d__cx, rtd *d__cy, rtd R,
				ray *d__chief_ray,
				int *d__piston_mask)
{
  int i, j, ij, iCoordSys, iSource, b_n_mode;
  rtd rho2;
  rtd x, y, z, x1, y1, s0, k, l, m;
  rtd s1, S, K, L ,M, dSds;
  rtd G2, a;
  vector d__origin, xyz, klm, xyz_GS, klm_GS;

  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = threadIdx.y;
  //  iCoordSys = blockIdx.y;
  ij = j * gridDim.x * blockDim.x + i;
  iSource = blockIdx.z;
  j = ij;
  ij += iSource*N_RAY;
  b_n_mode = max_n*(max_n+1)*0.5;
  if  ( ( j<N_RAY ) && (d__ray[ij].v) )// & (iCoordSys<1) )
  {

    for (iCoordSys=0; iCoordSys<7; iCoordSys++)
      {

	d__origin = d__conic_self_origin[iCoordSys];

        <<from global CS to motion CS>>

	<<from motion CS to aperture intersection>>

	if (rho2<=outer2)
	  {
	    mask[ij] = 1;
	    d__piston_mask[ij] = iCoordSys + 1;

            <<from motion CS to conic intersection and back to global CS>>
	    d__ray[ij].optical_path_difference += 
		d__ray[ij].optical_path_length - d__chief_ray[iSource].optical_path_length;
	    return;
	  }
      }
  }
}
@ and the chief ray kernel
<<GMT chief ray tracing kernel>>=
__global__ void m1_trace_chief_kernel(char *mask, ray *d__ray, int N_RAY, 
				      rtd *d__conic_R, vector *d__conic_origin,
				      const rtd Fk, const rtd Fc,
				      vector *d__conic_self_origin,
				      rtd *d__rigid_body_R, vector *d__rigid_body_origin,
				      rtd *d__motion_R, vector *d__motion_origin,
				      int max_n, int n_mode,
				      rtd *d__a, rtd *d__cx, rtd *d__cy, rtd R)
{
  int j, ij, iCoordSys, iSource;
  rtd x1, y1, s0, k, l, m;
  rtd s1, S, K, L ,M, dSds;
  rtd G2, a;
  vector d__origin, xyz, klm, xyz_GS, klm_GS;

  iSource = blockIdx.z;
  ij = iSource*N_RAY;
  iCoordSys = 0;

  d__origin = d__conic_self_origin[iCoordSys];

  <<from global CS to rigid body CS>>

  <<from motion CS to conic CS>>
  <<GMT intersection with conic>>
  <<reflection from the surface>>
  <<from conic CS to motion CS>>
  <<from rigid body CS to global CS>>

}
@ The following is a test routine to validate the sequence of transformation in the ray tracing kernel:
<<GMT M1 functions>>=
void gmt_m1::test_ray_tracing(void)
{
  int iCoordSys;
  vector in, out;

  in.x = 8.71*cos(PI/6);
  in.y = 8.71*sin(PI/6);
  in.z = 0.0;

  printf("Output vector:\n");
  for (iCoordSys = 0; iCoordSys<N; iCoordSys++)
    {
      printf(" #%d\n",iCoordSys);
        forward_transform(&out, &in,
                          rigid_body_CS.R+iCoordSys*9,
                          rigid_body_CS.origin+iCoordSys);
        printf(". x = %.2e ; y = %.2e ; z = %.2e\n",out.x,out.y,out.z);

        forward_transform(&out, &out,
                          motion_CS.R+iCoordSys*9,
                          motion_CS.origin+iCoordSys);
        printf(". x = %.2e ; y = %.2e ; z = %.2e\n",out.x,out.y,out.z);

	backward_transform_centered(&out, &out,
				    conic_CS.R+iCoordSys*9);
        printf(". x = %.2e ; y = %.2e ; z = %.2e\n",out.x,out.y,out.z);

	forward_transform_centered(&out, &out,
				    conic_CS.R+iCoordSys*9);
        printf(". x = %.2e ; y = %.2e ; z = %.2e\n",out.x,out.y,out.z);

        backward_transform(&out, &out,
                          motion_CS.R+iCoordSys*9,
                          motion_CS.origin+iCoordSys);
        printf(". x = %.2e ; y = %.2e ; z = %.2e\n",out.x,out.y,out.z);

        backward_transform(&out, &out,
                          rigid_body_CS.R+iCoordSys*9,
                          rigid_body_CS.origin+iCoordSys);
        printf(". x = %.2e ; y = %.2e ; z = %.2e\n",out.x-in.x,out.y-in.y,out.z-in.z);
    }
    
}
@ 
The transformation of the coordinates and directions of the rays is performed in 3 steps, 
<<from global CS to motion CS>>=
<<from global CS to rigid body CS>>
<<from rigid body CS to motion CS>>
@ (i) the rays are transformed into the CS of the segment,
<<from global CS to rigid body CS>>=
// RIGID BODY >>> 
forward_transform(&xyz_GS, &(d__ray[ij].coordinates),
		  d__rigid_body_R+iCoordSys*9, d__rigid_body_origin+iCoordSys);
forward_transform_centered(&klm_GS, &(d__ray[ij].directions),
			   d__rigid_body_R+iCoordSys*9);
@ (ii) the segments are perturbed
<<from rigid body CS to motion CS>>=
// MOTION >>>  
forward_transform(&xyz_GS, &xyz_GS,
		  d__motion_R+iCoordSys*9, d__motion_origin+iCoordSys);
forward_transform_centered(&klm_GS, &klm_GS,
			    d__motion_R+iCoordSys*9);
@  and (iii) the rays are transformed into the CS of the aperture:
<<from motion CS to aperture intersection>>=
// APERTURE >>>
forward_transform(&xyz, &xyz_GS,
		  d__aperture_R+iCoordSys*9,
		  d__aperture_origin+iCoordSys);
forward_transform_centered(&klm, &klm_GS,
			   d__aperture_R+iCoordSys*9);
 
	x = xyz.x;
	y = xyz.y;
	z = xyz.z;
	k = klm.x;
	l = klm.y;
	m = klm.z;

        <<GMT intersection with aperture plane>>

        rho2 = x1*x1 + y1*y1;
	if ( (iCoordSys==6) && (rho2<inner2) )
	  {
	    return;
	  }
@
The intersection with and reflection from the surface is done with
<<from motion CS to conic intersection and back to global CS>>=
<<from motion CS to conic CS>>
<<GMT intersection with aspheric>>
<<reflection from the surface>>
<<from conic CS to motion CS>>
<<from motion CS to rigid body CS>>
<<from rigid body CS to global CS>>
@ 
<<from motion CS to conic CS>>=
// CONIC >>>
backward_transform_centered(&xyz, &xyz_GS,
			    d__conic_R+iCoordSys*9);
backward_transform_centered(&klm, &klm_GS,
			    d__conic_R+iCoordSys*9);
@ 
<<reflection from the surface>>=
G2 = K*K + L*L + M*M;
a  = k*K + l*L + m*M;

a *= -2.0/G2;
klm.x += a*K;
klm.y += a*L;
klm.z += a*M;
@ 
<<from conic CS to motion CS>>=
 // CONIC <<<
 forward_transform_centered(&xyz_GS, &xyz,
			    d__conic_R+iCoordSys*9);
 forward_transform_centered(&klm_GS, &klm,
			    d__conic_R+iCoordSys*9);
@ 
<<from motion CS to rigid body CS>>=
 // MOTION <<<
 backward_transform(&xyz_GS, &xyz_GS,
		    d__motion_R+iCoordSys*9, d__motion_origin+iCoordSys);
 backward_transform_centered(&klm_GS, &klm_GS,
			     d__motion_R+iCoordSys*9);
@ 
<<from rigid body CS to global CS>>=
 // RIGID_BODY <<<
 backward_transform(&(d__ray[ij].coordinates), &xyz_GS,
		    d__rigid_body_R+iCoordSys*9,
		    d__rigid_body_origin+iCoordSys);
 backward_transform_centered(&(d__ray[ij].directions), &klm_GS,
			     d__rigid_body_R+iCoordSys*9);

@
The vignetting by the aperture is computed as the intersection between the aperture mask and the ray vignetting flags: 
<<aperture intersection>>=
__global__ void intersection(char *mask, ray *d__ray, int N_RAY)
{
  int i, j, ij, iSource;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = threadIdx.y;
  ij = j * gridDim.x * blockDim.x + i;
  iSource = blockIdx.z;
  if  ( ij<N_RAY )
  {
    ij += iSource*N_RAY;
    d__ray[ij].v &= mask[ij];
  }
}
@
The intersection with the aperture plane is computed with
<<GMT intersection with aperture plane>>=
if (m==0) { return; }
s0 = -z/m;
x1 = x + k*s0;
y1 = y + l*s0;
@ 
The intersection with the plane $z=0$ in the conic coordinate transformed is computed with  
<<GMT intersection with aspheric>>=
k  = klm.x;
l  = klm.y;
m  = klm.z;
if (m==0) { return; }
s0 = -xyz.z/m;
x1 = xyz.x + k*s0;
y1 = xyz.y + l*s0;
d__ray[ij].optical_path_length = s0;
s0 = s1 = 0;
for (j=0; j<SNELL_N_ITERATION; j++)
{
  xyz.x = x1 + k*s0;
  xyz.y = y1 + l*s0;
  xyz.z = m*s0;
  <<aspheric surface>>
  <<aspheric surface derivatives>>
  dSds = K*k + L*l + M*m;
  if (dSds==0) { break; }
  s1 = s0 - S/dSds;
  if (abs(s1-s0)<TOL)
    {
      xyz.x = x1 + k*s1;
      xyz.y = y1 + l*s1;
      xyz.z = m*s1;
      <<aspheric surface derivatives>>
      d__ray[ij].optical_path_length += s1;
      d__ray[ij].n_iteration = j;
      break;
    }
  s0 = s1;
}
@ 
<<aspheric surface>>=
S = aspheric_surface(&xyz, &d__origin, Fk, Fc, max_n, 
                     d__a + iCoordSys*n_mode, R);
@
<<aspheric surface derivatives>>=
K = partial_x_aspheric_surface(&xyz, &d__origin, Fk, Fc, max_n, 
                               d__cx + iCoordSys*b_n_mode, R);
L = partial_y_aspheric_surface(&xyz, &d__origin, Fk, Fc, max_n, 
                               d__cy + iCoordSys*b_n_mode, R);
M = partial_z_aspheric_surface();
@
<<GMT intersection with conic>>=
k  = klm.x;
l  = klm.y;
m  = klm.z;
if (m==0) { return; }
s0 = -xyz.z/m;
x1 = xyz.x + k*s0;
y1 = xyz.y + l*s0;
d__ray[ij].optical_path_length = s0;
s0 = s1 = 0;
for (j=0; j<SNELL_N_ITERATION; j++)
{
  xyz.x = x1 + k*s0;
  xyz.y = y1 + l*s0;
  xyz.z = m*s0;
  <<conic surface>>
  <<conic surface derivatives>>
  dSds = K*k + L*l + M*m;
  if (dSds==0) { break; }
  s1 = s0 - S/dSds;
  if (abs(s1-s0)<TOL)
    {
      xyz.x = x1 + k*s1;
      xyz.y = y1 + l*s1;
      xyz.z = m*s1;
      <<conic surface derivatives>>
      d__ray[ij].optical_path_length += s1;
      d__ray[ij].n_iteration = j;
      break;
    }
  s0 = s1;
}
@ 
<<conic surface>>=
S = conic_surface(&xyz, &d__origin, Fk, Fc);
@
<<conic surface derivatives>>=
K = partial_x_conic_surface(&xyz, &d__origin, Fk, Fc);
L = partial_y_conic_surface(&xyz, &d__origin, Fk, Fc);
M = partial_z_conic_surface();
@
\subsection{Mirror location tracker}
\label{sec:mirr-locat-track}

The track function transforms the coordinates $(x,y,0)$ in the motion CS of segment [[idx]] to the GCS.

\index{gmtMirrors!gmt\_m1!track}
<<GMT M1 functions>>=
void gmt_m1::track(float *d__x, float *d__y, int N, int idx)
{
  <<GMT track common>>
}
@  with
<<GMT track common>>=
dim3 blockDim(N_THREAD,1);
dim3 gridDim(N/N_THREAD+1,1);
track_kernel LLL gridDim, blockDim RRR (d__x, d__y, N,
					idx,
					rigid_body_CS.d__R,
					rigid_body_CS.d__origin,
					motion_CS.d__R,
					motion_CS.d__origin);
@ and
<<GMT track kernel>>= 
__global__ void track_kernel(float *x, float *y, const int N,
			     const int iCoordSys,
			     rtd *d__rigid_body_R, vector *d__rigid_body_origin,
			     rtd *d__motion_R, vector *d__motion_origin)
 {
   int i;
   vector v;
   i = blockIdx.x * blockDim.x + threadIdx.x;
   if (i<N) {
     v.x = x[i];
     v.y = y[i];
     v.z = 0.0;
     // MOTION <<<
     backward_transform(&v, &v,
			d__motion_R+iCoordSys*9, d__motion_origin+iCoordSys);
     // RIGID_BODY <<<
     backward_transform(&v, &v,
			d__rigid_body_R+iCoordSys*9,
			d__rigid_body_origin+iCoordSys);
     x[i] = v.x;
     y[i] = v.y;
   }
}

@ 
\subsection{Global tip--tilt}
\label{sec:global-tip-tilt}

\def\ijk{\ensuremath{\left[\vec i,\vec j, \vec k\right]}}
\def\uvw{\ensuremath{\left[\vec u,\vec v, \vec w\right]_k}}
\def\uvwp{\ensuremath{\left[\vec u^\prime,\vec v^\prime, \vec w^\prime\right]}}
\def\RS{\ensuremath{R_{{\cal S},k}}}
\def\RT{\ensuremath{R_{\cal T}}}
\def\RM{\ensuremath{R_{\cal M}}}

The GCS is defined with the 3 ortho--normal unit vectors \ijk.
The segment coordinate systems also called rigid body CSs are defined with the 3 ortho-normal vectors \uvw.
\uvw are derived from \ijk with the matrix \RS
\begin{equation}
  \label{eq:37}
  \uvw = \RS^T \ijk.
\end{equation}
Within the rigid body CSs, motion CSs (\uvwp) are defined with
\begin{equation}
  \label{eq:38}
  \uvwp = \RM^T \uvw = \RM^T \RS^T \ijk,
\end{equation}
where \RM is the 3D rotation matrix of each segment.

When a global tip--tilt is applied to M1, \ijk becomes $\RT^T\ijk$ with \RT the tip--tilt matrix, and the motion CSs are given by
\begin{equation}
  \label{eq:39}
  \uvwp = \RS^T\RT^T\ijk.
\end{equation}

From Eq.~(\ref{eq:38}) and Eq.~(\ref{eq:39}), the 3D rotation matrix of each segment as a result of a global tip--tilt is given by
\begin{equation}
  \label{eq:40}
  \RM = \RS^T \RT \RS.
\end{equation}
<<global tip-tilt transformation>>=
 cublasDgemm(handle,
	     CUBLAS_OP_N, CUBLAS_OP_N,
	     3,3,3,
	     &alpha,
	     rigid_body_CS.d__R+k9, 3,
	     TT_CS.d__R, 3,
	     &beta,
	     d__C, 3);
 cublasDgemm(handle,
	     CUBLAS_OP_N, CUBLAS_OP_T,
	     3,3,3,
	     &alpha,
	     d__C, 3,
	     rigid_body_CS.d__R+k9, 3,
	     &beta,
	     motion_CS.d__R+k9, 3);

 HANDLE_ERROR( cudaMemcpy( motion_CS.R+k9, motion_CS.d__R+k9, 
			   sizeof(double)*9, cudaMemcpyDeviceToHost ) );
 /* 
 int i, j, idx = 0;
for (i=0;i<3;i++)
   {
     fprintf(stdout,"||  ");
     for (j=0;j<3;j++)
       {
	 idx = j + i*3 + k9;
	 fprintf(stdout,"%+.4e  ",motion_CS.R[idx]);
       }
     fprintf(stdout,"||\n");
   }
 */
@
From \RM, the Euler angles corresponding to the 3 rotations of each segment are derived
\begin{eqnarray}
  \label{eq:41}
  \alpha &=& \arctan\left( \RM(32) \over \RM(33) \right) \\\nonumber
  \beta  &=& \arcsin\left( -\RM(31) \right) \\\nonumber
  \gamma &=& \arctan\left( \RM(21) \over \RM(11) \right) 
\end{eqnarray}
<<global tip-tilt transformation>>=
motion_CS.euler_angles[k].x = atan2(motion_CS.R[7+k9],motion_CS.R[8+k9]);
motion_CS.euler_angles[k].y = asin(-1.0*motion_CS.R[6+k9]);
motion_CS.euler_angles[k].z = atan2(motion_CS.R[3+k9],motion_CS.R[k9]);
@
The tip--tilt transformation is also applied to the origin of each segment $\vec O_k$ and the difference between the two origins is the translation of the motion CS, i.e.
\begin{equation}
  \label{eq:42}
  \vec O_k^\prime = \vec O_k - \vec O_R - \RT^T\left( \vec O_k -\vec O_R \right)
\end{equation}
where $\vec O_R$ is the rotation point.
<<global tip-tilt transformation>>=
 forward_transform(motion_CS.origin + k, rigid_body_CS.origin + k,
		   TT_CS.R, TT_CS.origin);
 motion_CS.origin[k].x = rigid_body_CS.origin[k].x - TT_CS.origin->x - motion_CS.origin[k].x;
 motion_CS.origin[k].y = rigid_body_CS.origin[k].y - TT_CS.origin->y - motion_CS.origin[k].y;
 motion_CS.origin[k].z = rigid_body_CS.origin[k].z - TT_CS.origin->z - motion_CS.origin[k].z;
 forward_transform_centered(motion_CS.origin + k, motion_CS.origin + k, rigid_body_CS.R + k9);
 HANDLE_ERROR( cudaMemcpy( motion_CS.d__origin+k, motion_CS.origin+k, 
			   sizeof(vector), cudaMemcpyHostToDevice ) );

/*
 fprintf(stdout,"#%d >> MOTION CS origins [micron]  : %+.3e, %+.3e, %+.3e\n",k,
	 motion_CS.origin[k].x*1e6,
	 motion_CS.origin[k].y*1e6,
	 motion_CS.origin[k].z*1e6);

 float r2d;
 r2d = 1000*3600*180.0/PI;
 fprintf(stdout,"#%d >> MOTION CS Euler angles [mas]: %+.3e, %+.3e, %+.3e\n",k,
	 r2d*motion_CS.euler_angles[k].x,
	 r2d*motion_CS.euler_angles[k].y,
	 r2d*motion_CS.euler_angles[k].z);
*/
@ 
\index{gmtMirrors!gmt\_m1!global\_tiptilt}
<<GMT M1 functions>>=
void gmt_m1::global_tiptilt(float tip, float tilt)
{
  <<GMT global tip-tilt common>>
}    
@  with
<<GMT global tip-tilt setup>>=
sprintf(tag,"GLOBAL TIP-TILT");
vector TT_CS_origin, TT_CS_euler_angles;
TT_CS_origin.x = TT_CS_origin.y = TT_CS_origin.z = 0.0;
TT_CS_euler_angles.x = TT_CS_euler_angles.y = TT_CS_euler_angles.z = 0.0;
TT_CS.setup(&TT_CS_origin, &TT_CS_euler_angles, 1, tag);
cublasCreate(&handle);
HANDLE_ERROR( cudaMalloc((void**)&d__C, sizeof(double)*9 ) );
@
<<GMT global tip-tilt cleanup>>=
TT_CS.cleanup();
cublasDestroy(handle);
HANDLE_ERROR( cudaFree( d__C ) );
@  and 
<<GMT global tip-tilt common>>=
double alpha, beta;
alpha = 1.0;
beta  = 0.0;
int k, k9;
vector origin, euler_angles;
origin.x = origin.y = origin.z = 0.0;
euler_angles.x = tip;
euler_angles.y = tilt;
euler_angles.z = 0.0;
TT_CS.update(origin,euler_angles,0);
for (k=0;k<N;k++)
  {
    k9 = k*9;
    <<global tip-tilt transformation>>
  }
@ 
@
\subsection{Edge sensors}
\label{sec:edge-sensors}

\index{gmtMirrors!gmt\_m1!edge\_sensors}
Edge sensors are set on the rim of each segment.
12 edges sensors are located on the central segment.
Pairs of edge sensor are at an angle $\pm \alpha$ with respect to the line joining the center of the segment to the center of the peripheral segment.
The coordinates of the edge sensor in the rigid body CS are
\begin{equation}
  \label{eq:1}
  \left|
  \begin{array}{c}
    l_{7,k} \\
    r_{7,k}
  \end{array}
  \right|
   = {1\over 2}[[D_full]]\exp\left(i \left( {\pi(3-2k)\over 6} \pm \alpha  \right)\right), \forall k=0,\dots,5.
\end{equation}
Each peripheral segment has 2 pairs of edge sensors facing the adjacent peripheral segments.
The coordinates of the edge sensors of a peripheral segment in the rigid body CS are:
\begin{eqnarray}
  \label{eq:2}
  \left|
  \begin{array}{c}
    l_{k,3} \\
    r_{k,3}
  \end{array}
  \right|
   &=& {1\over 2}[[D_full]]\exp\left(i \left( -{\pi\over 6} \pm \alpha \right) \right), \\
  \left|
  \begin{array}{c}
    l_{k,5} \\
    r_{k,5}
  \end{array}
  \right|
   &=& {1\over 2}[[D_full]]\exp\left(i  \left( -{5\pi\over 6} \pm \alpha \right) \right). 
\end{eqnarray}
Each peripheral segment has also a pair of edge sensor facing the central segment whose coordinates, in the rigid body CS, are:
\begin{equation}
  \label{eq:3}
  \left|
  \begin{array}{c}
    l_{k,4} \\
    r_{k,4}
  \end{array}
  \right|
   = {1\over 2}[[D_full]]\exp\left(i \left( -{\pi\over 2} \pm \alpha \right) \right).  
\end{equation}
The heights of the edge sensors are $z=0$ in the rigid body CS of the segment they belong to.

\begin{figure}
\begin{center}
\input{edgeSensor.tex}
\end{center}  
  \caption{Edge sensor layout.}
  \label{fig:3}
\end{figure}

The total number of unique edge sensors coordinates in the rigid body CS is 18 whose 12 are on the central segment and 6 on the peripheral segments leading to a total of 48 edge sensors coordinates in the GCS and 24 edge sensor mesurements.
<<GMT M1 parameters>>=
int N_EDGE_SENSOR, N_EDGE_SENSOR_DATA;
<<M1 edge sensors>>=
N_EDGE_SENSOR = 48;
N_EDGE_SENSOR_DATA = 24;
@ The $\alpha$ angle is set to 19.5degree
<<GMT M1 parameters>>=
rtd alpha;
<<M1 edge sensors>>=
alpha = 19.5;
@
The coordinates of the edge sensors in the GCS are saved in the vectors [[d__v0_EDGE_SENSOR]] for a perfectly aligned telescope and in the vectors [[d__v_EDGE_SENSOR]] for a perturbed telescope.
<<GMT M1 parameters>>=
vector *v0_EDGE_SENSOR, *v_EDGE_SENSOR, *d__v0_EDGE_SENSOR, *d__v_EDGE_SENSOR;
<<M1 edge sensors>>=
int n_byte, n_byte_DATA;
n_byte      = sizeof(vector)*N_EDGE_SENSOR;
n_byte_DATA = sizeof(vector)*N_EDGE_SENSOR_DATA;
v0_EDGE_SENSOR = (vector *)malloc(n_byte);
v_EDGE_SENSOR  = (vector *)malloc(n_byte);
HANDLE_ERROR( cudaMalloc((void**)&d__v0_EDGE_SENSOR, n_byte ) );
HANDLE_ERROR( cudaMalloc((void**)&d__v_EDGE_SENSOR,  n_byte ) );
<<GMT M1 cleanup common>>=
free( v0_EDGE_SENSOR );
free( v_EDGE_SENSOR );
HANDLE_ERROR( cudaFree( d__v0_EDGE_SENSOR ) );
HANDLE_ERROR( cudaFree( d__v_EDGE_SENSOR ) );
@
The edge sensor 24 measurements are saved in the vector [[d__dv0_EDGE_SENSOR]] and [[d__dv_EDGE_SENSOR]] for a perfectly aligned and perturbed telescope, respectively.
<<GMT M1 parameters>>=
vector *dv0_EDGE_SENSOR, *d__dv0_EDGE_SENSOR;
vector *dv_EDGE_SENSOR, *d__dv_EDGE_SENSOR;
<<M1 edge sensors>>=
dv0_EDGE_SENSOR  = (vector *)malloc(n_byte_DATA);
HANDLE_ERROR( cudaMalloc((void**)&d__dv0_EDGE_SENSOR, n_byte_DATA ) );
dv_EDGE_SENSOR  = (vector *)malloc(n_byte_DATA);
HANDLE_ERROR( cudaMalloc((void**)&d__dv_EDGE_SENSOR, n_byte_DATA ) );
<<GMT M1 cleanup common>>=
free( dv0_EDGE_SENSOR );
HANDLE_ERROR( cudaFree( d__dv0_EDGE_SENSOR ) );
free( dv_EDGE_SENSOR );
HANDLE_ERROR( cudaFree( d__dv_EDGE_SENSOR ) );
@
The edge sensor coordinates in the GCS are computed with:
<<M1 edge sensors>>=
fprintf(stdout,"@(CEO)>gmt_m1: Initializing edge sensors coordinates!\n");
dim3 blockDim(6,1);
dim3 gridDim(1,1);
edge_sensors_read LLL gridDim, blockDim RRR (d__v0_EDGE_SENSOR, N-1, D_full, alpha,
					     rigid_body_CS.d__R,
                                             rigid_body_CS.d__origin,
                                             motion_CS.d__R,
                                             motion_CS.d__origin);
HANDLE_ERROR( cudaMemcpy( v0_EDGE_SENSOR, d__v0_EDGE_SENSOR, 
                          n_byte, cudaMemcpyDeviceToHost ) );
HANDLE_ERROR( cudaMemcpy( d__v_EDGE_SENSOR, d__v0_EDGE_SENSOR, 
                          n_byte, cudaMemcpyDeviceToDevice ) );
HANDLE_ERROR( cudaMemcpy( v_EDGE_SENSOR, d__v_EDGE_SENSOR, 
                          n_byte, cudaMemcpyDeviceToHost ) );
@  and the reference measurements with:
<<M1 edge sensors>>=
HANDLE_ERROR( cudaMemset(d__dv0_EDGE_SENSOR, 0, n_byte_DATA ) );
edge_sensors_data_kernel LLL gridDim, blockDim RRR (d__dv_EDGE_SENSOR,
                                                   d__v_EDGE_SENSOR,
                                                   d__dv0_EDGE_SENSOR,
                                                   N-1);
HANDLE_ERROR( cudaMemcpy( d__dv0_EDGE_SENSOR, d__dv_EDGE_SENSOR, 
                          n_byte_DATA, cudaMemcpyDeviceToDevice ) );
HANDLE_ERROR( cudaMemcpy( dv0_EDGE_SENSOR, d__dv0_EDGE_SENSOR, 
                          n_byte_DATA, cudaMemcpyDeviceToHost ) );
HANDLE_ERROR( cudaMemset(d__dv_EDGE_SENSOR, 0, n_byte_DATA ) );
HANDLE_ERROR( cudaMemcpy( dv_EDGE_SENSOR, d__dv_EDGE_SENSOR, 
                          n_byte_DATA, cudaMemcpyDeviceToHost ) );
@ with
<<M1 edge sensors initialization kernel>>=
 __global__ void edge_sensors_read(vector *v, const int N_OUT_SEGMENT, 
				   const rtd D, const rtd alpha,
				   rtd *d__rigid_body_R, vector *d__rigid_body_origin,
				   rtd *d__motion_R, vector *d__motion_origin)
{
  int i, iCoordSys, k;
  rtd R, a, offset_angle;
  i = threadIdx.x;
  if (i<N_OUT_SEGMENT)
  {
    R = 0.5*D;
    a = alpha/180;

    <<central segment edge sensors new>>

    __syncthreads();

    <<outer segment edge sensors new>>

  }
}
@ 
First the coordinates $l_{7,k}$ are computed,
<<central segment edge sensors new>>=
iCoordSys = 6;
k = i;
offset_angle = (3.0-2.0*i)/6.0 + a;
<<edge sensor coordinates>>
@
followed by the coordinates $r_{7,k}$
<<central segment edge sensors new>>=
k             += N_OUT_SEGMENT;
offset_angle = (3.0-2.0*i)/6.0 - a;
<<edge sensor coordinates>>
@
The coordinates of the edge sensors of segment \# $k=[[iCoordSys]]$ are computed next, starting with  $l_{k,4}$ and $r_{k,4}$:
<<outer segment edge sensors new>>=
iCoordSys    = i;
k            = 2*N_OUT_SEGMENT + i;
offset_angle = -0.5 + a;
<<edge sensor coordinates>>
k += 6;
offset_angle = -0.5 - a;
<<edge sensor coordinates>>
@ then $l_{k,3}$ and $r_{k,3}$:
<<outer segment edge sensors new>>=
k += 6;
offset_angle = -1.0/6.0 + a;
<<edge sensor coordinates>>
k += 6;
offset_angle = -1.0/6.0 - a;
<<edge sensor coordinates>>
@ and finally $l_{k,5},$ and $r_{k,5}$:
<<outer segment edge sensors new>>=
k += 6;
offset_angle = -5.0/6.0 + a;
<<edge sensor coordinates>>
k += 6;
offset_angle = -5.0/6.0 - a;
<<edge sensor coordinates>>
@ 
The coordinates are first calculated in the motion CS,
<<edge sensor coordinates>>=
sincospi( offset_angle, &(v[k].y), &(v[k].x) );
v[k].x       *= R;
v[k].y       *= R;
v[k].z       = 0.0;
@ 
then they are transformed from the motion CS to the rigid body CS,
<<edge sensor coordinates>>=
// MOTION <<<
backward_transform(v+k, v+k,
		   d__motion_R+iCoordSys*9, d__motion_origin+iCoordSys);
@ 
and finally, they are transformed from the rigid body CS to the GCS.
<<edge sensor coordinates>>=
// RIGID_BODY <<<
backward_transform(v+k, v+k,
		   d__rigid_body_R+iCoordSys*9,
		   d__rigid_body_origin+iCoordSys);
@ 
The edge sensor measurements consist in the coordinates of the vector joining pair of edge sensors.
The edge sensors coordinates are stored in the [[d__v0_EDGE_SENSOR]] and  [[d__v0_EDGE_SENSOR]] arrays as shown in the diagram below.
The vectors linking pairs of edge sensors are also drawn.

\begin{tikzpicture}[>=stealth',node distance=2cm,edge sensor block/.style={draw, anchor=base, minimum height=7mm,minimum width=2cm}]
  \node[edge sensor block] (l7k) {$l_{7,k}$};
  \node[edge sensor block, right of=l7k] (r7k) {$r_{7,k}$};
  \node[edge sensor block, right of=r7k] (lk4) {$l_{k,4}$};
  \node[edge sensor block, right of=lk4] (rk4) {$r_{k,4}$};
  \node[edge sensor block, right of=rk4] (lk3) {$l_{k,3}$};
  \node[edge sensor block, right of=lk3] (rk3) {$r_{k,3}$};
  \node[edge sensor block, right of=rk3] (lk5) {$l_{k,5}$};
  \node[edge sensor block, right of=lk5] (rk5) {$r_{k,5}$};
  \draw[->] (l7k.north) to [out=30,in=150] (rk4.north);
  \draw[->] (r7k.south) to [out=-90,in=-90] (lk4.south);
  \draw[->] (lk3.north) to [out=30,in=150] (rk5.north);
  \draw[->] (rk3.south) to [out=-90,in=-90] (lk5.south);
  \draw[blue!20] ($(l7k.south west)-(2mm,2mm)$) rectangle ($(rk5.north east)+(2mm,2mm)$);
 \end{tikzpicture}

They measurements are computed with
<<GMT M1 functions>>=
void gmt_m1::edge_sensors_data(void)
{
  dim3 blockDim(6,1);
  dim3 gridDim(1,1);
  edge_sensors_read LLL gridDim, blockDim RRR (d__v_EDGE_SENSOR, N-1, D_full, alpha,
       					     rigid_body_CS.d__R,
                                             rigid_body_CS.d__origin,
                                             motion_CS.d__R,
                                             motion_CS.d__origin);
  edge_sensors_data_kernel LLL gridDim, blockDim RRR (d__dv_EDGE_SENSOR,
						     d__v_EDGE_SENSOR,
						     d__dv0_EDGE_SENSOR,
						     N-1);
  HANDLE_ERROR( cudaMemcpy( dv_EDGE_SENSOR, d__dv_EDGE_SENSOR,
			    sizeof(vector)*N_EDGE_SENSOR_DATA, cudaMemcpyDeviceToHost ) );
}
@  
with the kernel
<<M1 edge sensor data kernel>>=
__global__ void edge_sensors_data_kernel(vector *d__dv_EDGE_SENSOR, 
					vector *d__v_EDGE_SENSOR, 
					vector *d__dv0_EDGE_SENSOR, 
					const int N_OUT_SEGMENT)
{
  int k;
  k = threadIdx.x;
  if (k<N_OUT_SEGMENT)
    {
      d__dv_EDGE_SENSOR[k]                 =
      	d__v_EDGE_SENSOR[k+3*N_OUT_SEGMENT] - 
        d__v_EDGE_SENSOR[k] - 
        d__dv0_EDGE_SENSOR[k];
      d__dv_EDGE_SENSOR[k+  N_OUT_SEGMENT] =
      	d__v_EDGE_SENSOR[k+2*N_OUT_SEGMENT] - 
        d__v_EDGE_SENSOR[k+  N_OUT_SEGMENT] - 
        d__dv0_EDGE_SENSOR[k+N_OUT_SEGMENT];
      d__dv_EDGE_SENSOR[k+2*N_OUT_SEGMENT] =
      	d__v_EDGE_SENSOR[(k+1)%6+7*N_OUT_SEGMENT] - 
        d__v_EDGE_SENSOR[k+4*N_OUT_SEGMENT] - 
        d__dv0_EDGE_SENSOR[k+2*N_OUT_SEGMENT];
      d__dv_EDGE_SENSOR[k+3*N_OUT_SEGMENT] =
      	d__v_EDGE_SENSOR[(k+1)%6+6*N_OUT_SEGMENT] - 
        d__v_EDGE_SENSOR[k+5*N_OUT_SEGMENT] - 
        d__dv0_EDGE_SENSOR[k+3*N_OUT_SEGMENT];
    }
}
@
\section{GMT M2}
\label{sec:gmt-m2}

\index{gmtMirrors!gmt\_m2}
A new structure to hold GMT M1 parameters and functions is defined.
<<GMT M2 structure>>=
struct gmt_m2 {
  <<GMT M12 parameters>>
  <<GMT M12 functions>>
  void pointing_neutral(float tip, float tilt);
  void coma_neutral(float tip, float tilt);
};
@
\subsection{Setup \& Cleanup}
\label{sec:setup--cleanup-2}

\index{gmtMirrors!gmt\_m2!setup}
<<GMT M2 functions>>=
void gmt_m2::setup(float _D_, int _D_px_)
{
  <<M2 parameters>>
  <<GMT setup common>>
}
@ with
<<M2 parameters>>=
 M_ID    = 2;
 D_px    = _D_px_;
 D       = _D_;
 D_assembly = 3.168;
 D_full  = 1.0425*1.005; // slightly larger to always encompass M1; needed for the Zernike
 D_clear = 1.0415;
 ri      = 0.0;
 beta    = -14.777462*PI/180.0;
 L       = 1.08774;
 N       = 7;
 conic_c = -1.0/4.1639009;
 conic_k = 1-0.71692784;
 height  = 20.26247614;
 idx_offset = 3;
@  
If an array of sources is propagated through the telescope then
\index{gmtMirrors!gmt\_m2!setup}
<<GMT M2 functions>>=
void gmt_m2::setup(float _D_, int _D_px_, int N_SRC)
{
  ZS = NULL;
  M_ID    = 2;
  <<M2 parameters>>
  <<GMT setup common>>
}
@ 
\index{gmtMirrors!gmt\_m2!setup}
<<GMT M2 functions>>=
void gmt_m2::setup(float _D_, int _D_px_, zernikeS *_ZS_, int N_SRC)
{
  ZS = _ZS_;
  M_ID    = 2;
  <<M2 parameters>>
  <<GMT setup common>>
}
@ 
Memory is freed with
\index{gmtMirrors!gmt\_m2!cleanup}
<<GMT M2 functions>>=
void gmt_m2::cleanup(void)
{
  fprintf(stdout,"@(CEO)>gmt_m2: freeing memory!\n");
  <<GMT cleanup common>>
}
@
\subsection{Blocking}
\label{sec:blocking-2}

The rays blocking with M2 is computed with
\index{gmtMirrors!gmt\_m2!blocking}
<<GMT M2 functions>>=
void gmt_m2::blocking(bundle *rays)
{
  <<GMT blocking common>>
}
@
\subsection{Ray tracing}
\label{sec:ray-tracing-2}

The rays propagation through M1 is computed with
\index{gmtMirrors!gmt\_m2!trace}
<<GMT M2 functions>>=
void gmt_m2::trace(bundle *rays)
{ 
  <<GMT trace common>>
}
@
The rigid body motion parameters are updated with:
\index{gmtMirrors!gmt\_m2!update}
<<GMT M2 functions>>=
void gmt_m2::update(vector _origin_, vector _euler_angles_,int idx)
{
    <<GMT M12 update>>
}
@ 
The rigid body motion are reset to 0 with:
\index{gmtMirrors!gmt\_m2!reset}
<<GMT M2 functions>>=
void gmt_m2::reset(void)
{
    <<GMT M12 reset>>
}
@
\subsection{Global motions}
\label{sec:global-motions}

\subsection{Global tip--tilt}
\label{sec:global-tip-tilt-1}

\index{gmtMirrors!gmt\_m2!global\_tiptilt}
<<GMT M2 functions>>=
void gmt_m2::global_tiptilt(float tip, float tilt)
{
  <<GMT global tip-tilt common>>
}    
@
\subsubsection{Tip--tilt neutral}
\label{sec:tip-tilt-neutral}

\index{gmtMirrors!gmt\_m2!pointing\_neutral}
<<GMT M2 functions>>=
void gmt_m2::pointing_neutral(float tip, float tilt)
{
  double alpha, beta, *d__C;
  vector origin, euler_angles;
  cublasHandle_t handle;
  coordinate_system TT_CS;

  origin.x = origin.y = 0.0;
  origin.z = height - 4390.312E-03;
  euler_angles.x = tip;
  euler_angles.y = tilt;
  euler_angles.z = 0.0;

  TT_CS.setup(origin, euler_angles);
  cublasCreate(&handle);

  alpha = 1;
  beta  = 0;
  HANDLE_ERROR( cudaMalloc((void**)&d__C, sizeof(double)*9 ) );
  int k, k9;
  for (k=0;k<N;k++)
    {
      k9 = k*9;
      <<global tip-tilt transformation>>
    }

  cublasDestroy(handle);
  TT_CS.cleanup();
  HANDLE_ERROR( cudaFree( d__C ) );
}
@
\subsubsection{Coma neutral}
\label{sec:coma-neutral}

\index{gmtMirrors!gmt\_m2!coma\_neutral}
<<GMT M2 functions>>=
void gmt_m2::coma_neutral(float tip, float tilt)
{
  double alpha, beta, *d__C;
  vector origin, euler_angles;
  cublasHandle_t handle;
  coordinate_system TT_CS;

  origin.x = origin.y = 0.0;
  origin.z = height - 2246.410E-03;
  euler_angles.x = tip;
  euler_angles.y = tilt;
  euler_angles.z = 0.0;

  TT_CS.setup(origin, euler_angles);
  cublasCreate(&handle);

  alpha = 1;
  beta  = 0;
  HANDLE_ERROR( cudaMalloc((void**)&d__C, sizeof(double)*9 ) );
  int k, k9;
  for (k=0;k<N;k++)
    {
      k9 = k*9;
      <<global tip-tilt transformation>>
    }

  cublasDestroy(handle);
  TT_CS.cleanup();
  HANDLE_ERROR( cudaFree( d__C ) );
}
@

