% -*- mode: Noweb; noweb-code-mode: c-mode -*-
@
\section{The files}

\subsection{Header}

<<utilities.h>>=
#ifndef __UTILITIES_H__
#define __UTILITIES_H__

#include <sys/stat.h>
#include <stdio.h>
#include <cuda.h>
#include <cuda_runtime.h>
#include <curand.h>
#include <curand_kernel.h>
#include <cufft.h>
#include "cublas_v2.h"
#include "cusparse_v2.h"

#define PI 3.141592653589793
#define RADIAN2ARCSEC (180*3600/PI)
#define MIN(a, b)  (((a) < (b)) ? (a) : (b))
#define MAX(a, b)  (((a) > (b)) ? (a) : (b))
#define CUBLAS_VERBOSE 0

static void HandleError( cudaError_t err,
                         const char *file,
                         int line ) {
  if (err != cudaSuccess)  {
    fprintf(stderr,"\n\x1B[31m@(CEO)>ERROR: %s in %s at line %d\x1B[0m\n", 
	    cudaGetErrorString( err ), file, line );
    exit( EXIT_FAILURE );
  }
}
#define HANDLE_ERROR( err ) (HandleError( err, __FILE__, __LINE__ ))

static void HandleErrorCUFFT( cufftResult_t err,
			      const char *msg,
			      const char *file,
			      int line ) {
  if (err != CUFFT_SUCCESS)  {
    fprintf(stderr,"\n\x1B[31m@(CEO)>CUFFT ERROR: %s in %s at line %d\x1B[0m\n", 
	    msg, file, line );
    exit( EXIT_FAILURE );
  }
}
#define HANDLE_ERROR_CUFFT( err, msg ) (HandleErrorCUFFT( err, msg, __FILE__, __LINE__ ))

static void HandleErrorCUSPARSE( cusparseStatus_t err,
			      const char *msg,
			      const char *file,
			      int line ) {
  if (err != CUSPARSE_STATUS_SUCCESS)  {
    fprintf(stderr,"\n\x1B[31m@(CEO)>CUSPARSE ERROR: %s in %s at line %d\x1B[0m\n", 
	    msg, file, line );
    exit( EXIT_FAILURE );
  }
}
#define HANDLE_ERROR_CUSPARSE( err, msg ) (HandleErrorCUSPARSE( err, msg, __FILE__, __LINE__ ))   

inline float sign(float x) {
  return (float) ( (x > 0) - (x < 0) );
}

int round_up_to_nhp2(int n);

#define ARCSEC(a) (a*PI/180/3600)

<<lenslet2array>>

<<lenslet2row>>

<<threads2lenslet>>

<<tic-toc>>

void CUBLAS_ERROR(cublasStatus_t status);

<<mask structure>>
<<statistics definition>>

<<lenslet 2 actuator>>
__global__ void circular_pupil(char *pupil, int N);
__global__ void GMT_pupil(char *pupil, const int N, const float S, float Dsh, const float c, const char v);
//__global__ void valid_lenslet(char *mask, int N_pupil, float threshold);
__global__ void fried_geometry(char *lenslet_mask, char *actuator_mask, 
                               int NL, int n, float threshold);
__global__ void fried_geometry_vs_pupil(char *lenslet_mask, char *actuator_mask, 
                                        const int NL, const int n, const float threshold, const char *pupil);
char fried_geometry_setup(char *lenslet_mask, char *actuator_mask, 
                          int NL, int n, float threshold);
char fried_geometry_setup_vs_pupil(char *lenslet_mask, char *actuator_mask, 
			  int NL, int n, float threshold, char *pupil);

void dev2file(const char* filename, float* d__data, int n_data);
void dev2file(const char* filename, float* d__data, int n_data, 
              int n_data_page, int n_page);
void dev2file(const char* filename, float* d__data, int n_data, 
              int *n_data_page, int n_page);
void dev2file(const char* filename, int* d__data, int n_data);
void dev2file(const char* filename, float2* d__data, int n_data);
void dev2file(const char* filename, char* d__data, int n_data);

double atmosphere_refractive_index(float wavelength, float altitude, float temperature, float humidity);
double atmospheric_dispersion(float wavelength, float delta_wavelength,
			      float zenith, float altitude, 
			      float temperature, float humidity);

void dev2host( float *host_data, float *dev_data, int N);
void host2dev( float **dev_data, float *host_data, int N);
void freedev( float **dev_data );

<<gpu data structure>>

#endif  // __UTILITIES_H__
@

\subsection{Source}

<<utilities.cu>>=
#ifndef __UTILITIES_H__
#include "utilities.h"
#endif

int round_up_to_nhp2(int n) {
  int v; // compute the next highest power of 2 of 32-bit v
  v = n;
  v--;
  v |= v >> 1;
  v |= v >> 2;
  v |= v >> 4;
  v |= v >> 8;
  v |= v >> 16;
  v++;
  return v;
}

<<cublas error>>

<<fill ones>>
<<fill ones (char)>>
<<fill ones filtered>>
<<statistics functions>>
<<mask functions>>
<<circular pupil>>
<<GMT pupil>>

<<Fried geometry masks>>
<<Fried geometry>>
<<Fried geometry masks (arbitrary pupil)>>
<<Fried geometry (arbitrary pupil)>>

<<device to file>>

<<atmosphere refractive index>>
<<atmospheric dispersion>>

<<data to host from device>>
<<data to device from host>>
<<free device>>

<<gpu data structure function>>
@

\subsection{Python}
\label{sec:python}

<<ceo.pxd>>=
cdef extern from "utilities.h":
@

\section{Functions}
\label{sec:functions}

\subsection{Mapping to lenslet array}
\label{sec:mapp-lensl-array}

When dealing with lenslet arrays, a thread in a given thread block correspond to a pixel coordinate $[i,j]$ in a given lenslet $[i_l,j_L]$.
The following function computes the coordinates $[i,j]$ and $[i_l,j_L]$ based on the thread and block index, the block size and the number of pixel per lenslet [[n_px_lenslet]].
<<threads2lenslet>>=
__device__ inline char threads2lenslet(dim3 threadIdx, dim3 blockIdx, dim3 blockDim, 
				      int *i_px_lenslet, int *j_px_lenslet, int n_px_lenslet, 
				       int *i_lenslet, int *j_lenslet, int n_lenslet) 
{
  <<from threads to lenslet coordinates>>
  return 1;
}
@ The pixel coordinate in the image is given by
<<from threads to lenslet coordinates>>=
*i_px_lenslet = threadIdx.x + blockIdx.x * blockDim.x;
*j_px_lenslet = threadIdx.y + blockIdx.y * blockDim.y;
@ Then the lenslet coordinate $[i_l,j_L]$ are derived from
<<from threads to lenslet coordinates>>=
*i_lenslet = *i_px_lenslet/n_px_lenslet;
if (*i_lenslet>=n_lenslet)
  return 0;
*j_lenslet = *j_px_lenslet/n_px_lenslet;
if (*j_lenslet>=n_lenslet)
  return 0;
@ and finally the pixel coordinate $[i,j]$ in lenslet $[i_l,j_L]$ is
<<from threads to lenslet coordinates>>=
*i_px_lenslet -=  *i_lenslet*n_px_lenslet;
*j_px_lenslet -=  *j_lenslet*n_px_lenslet;
@ 
Fig.~\ref{fig:1} shows the arrangements for $ 2\times2\times3$ blocks of $16\times16$ threads mapping a $6\times6$ lenslet array with $5\times5$ pixels per lenslet.
The third dimension of the block grid gives the source index.
\begin{figure}
  \centering
  \begin{tikzpicture}
    \foreach \z in {0,4,8} { 
    \begin{scope}[xshift=-\z mm,yshift=-\z mm]
      \fill[orange!50] (-2mm,-2mm) rectangle (34mm,34mm);
      \foreach \x in {0,16} { 
        \foreach \y in {0,16} {
          \begin{scope}[xshift=\x mm,yshift=\y mm]
            \fill[green!50,draw=black,thick] (0,0) rectangle (16mm,16mm);
            \draw[step=1mm,gray,thin] (0,0) grid (16mm,16mm);
          \end{scope}
        }
      }
      \draw[step=5mm,red,very thin] (0,0) grid (30mm,30mm);
    \end{scope}
}
  \end{tikzpicture}
  \caption{$2\times2\times3$ blocks of $16\times16$ threads mapping a $6\times6$ lenslet array with $5\times5$ pixels per lenslet}
  \label{fig:1}
\end{figure}
@
Once the coordinates $[i,j]$ and $[i_l,j_L]$ have been computed, the linear index in the image is computed with
<<lenslet2array>>=
__device__ inline int lenslet2array(int i_px_lenslet, int j_px_lenslet, int n_px_lenslet, 
			 int i_lenslet, int j_lenslet, int n_lenslet, int i_source)
{
  int index;
  index =  i_lenslet*n_px_lenslet + i_px_lenslet;
  index += i_source*n_px_lenslet*n_lenslet;
  index *= n_lenslet*n_px_lenslet;
  index += j_lenslet*n_px_lenslet + j_px_lenslet;
  return index;
}
@ Fig.~\ref{fig:2} shows the global coordinates of pixel $[i_g,j_g]$ in an image made of the horizontal concatenation of 3 lenslet arrays.
$i_g$ and $j_g$ are related to the coordinates $[i,j]$ and $[i_l,j_L]$ through the following relation
\begin{eqnarray}
  \label{eq:1}
  i_g &=& i_SN_LN_P + i_LN_p+i \\
  j_g &=& j_LN_p+i \\
\end{eqnarray}
where $i_S$ is the source index, $N_L$ is the size of one lenslet array and $N_P$ is the number of pixel per lenslet.
The linear global index $k_g$ is given by
\begin{equation}
  \label{eq:2}
  k_g = i_gN_LN_P + j_g
\end{equation}
where $N_s$ is the number of sources.
\begin{figure}
  \centering
  \begin{tikzpicture}[x=1mm,y=1mm]
    \foreach \z in {0,30,60} { 
      \begin{scope}[xshift=\z mm]
        \fill[orange!50,draw=black,thick] (0,0) rectangle (30,30);
      \end{scope}
    }
    \draw[step=1mm,gray,thin] (0,0) grid (90,30);
    \draw[step=5mm,red,very thin] (0,0) grid (90,30);
    \fill[blue!70] (36,16) rectangle (37,17);
    \draw[blue!70] (-2,16.5) -- (36.5,16.5);
    \draw[blue!70] (36.5,-2) -- (36.5,16.5);
    \node[anchor=east] at (-2,16.5) {$i_SN_LN_P + i_LN_p+i$};
    \node[anchor=north] at (36.5,-2) {$j_LN_p+j$};
  \end{tikzpicture}
  \caption{3 $6\times6$ lenslet arrays with $5\times5$ pixels per lenslet}
  \label{fig:2}
\end{figure}

To compute the Fourier transform of the wavefront of each lenslet in a batch, all the lenslets are concatenated into a single column:
<<lenslet2row>>=
__device__ inline int lenslet2row(int i_px_lenslet, int j_px_lenslet, int n_px_lenslet, 
			 int i_lenslet, int j_lenslet, int n_lenslet, 
			 int i_source)
{
  int index;
  index = i_lenslet*n_lenslet + j_lenslet;
  index += i_source*n_lenslet*n_lenslet;
  index *= n_px_lenslet;
  index += i_px_lenslet;
  index *= n_px_lenslet;
  index += j_px_lenslet;
  return index;
}
@ Fig.~\ref{fig:3} shows the global coordinates of pixel $[i_g,j_g]$ in an image made of the vertical concatenation of all the lenslets.
$i_g$ and $j_g$ are related to the coordinates $[i,j]$ and $[i_l,j_L]$ through the following relation
\begin{eqnarray}
  \label{eq:3}
  i_g &=& (i_LN_L+j_L + i_SN_L^2)N_P + i \\
  j_g &=& j \\
\end{eqnarray}
where $i_S$ is the source index, $N_L$ is the size of one lenslet array and $N_P$ is the number of pixel per lenslet.
The linear global index $k_g$ is given by
\begin{equation}
  \label{eq:4}
  k_g = i_gN_P + j_g
\end{equation}
where $N_s$ is the number of sources.
\begin{figure}
  \centering
  \begin{tikzpicture}[x=1mm,y=1mm]
    \fill[orange!50,draw=black,thick] (0,0) rectangle (5,33);
    \draw[step=1mm,gray,thin] (0,0) grid (5,33);
    \draw[step=5mm,red,very thin] (0,0) grid (5,33);
    \fill[blue!70] (3,16) rectangle (4,17);
    \draw[blue!70] (-2,16.5) -- (3.5,16.5);
    \draw[blue!70] (3.5,-2) -- (3.5,16.5);
    \node[anchor=east] at (-2,16.5) {$(i_LN_L+j_L + i_SN_L^2)N_P + i$};
    \node[anchor=north] at (3.5,-2) {$j$};
  \end{tikzpicture}
  \caption{3 $6\times6$ lenslet arrays with $5\times5$ pixels per lenslet}
  \label{fig:3}
\end{figure}

\subsection{Stopwatch}
\label{sec:stopwatch}

In the following, a structure to time a chunk of CUDA code is defined:
<<tic-toc>>=
struct stopwatch{
  cudaEvent_t     start, stop;
  void tic(void) {
    HANDLE_ERROR( cudaEventCreate( &start ) );
    HANDLE_ERROR( cudaEventCreate( &stop ) );
    HANDLE_ERROR( cudaEventRecord( start, 0 ) );
  }
  void toc(void) {
    HANDLE_ERROR( cudaEventRecord( stop, 0 ) );
    HANDLE_ERROR( cudaEventSynchronize( stop ) );
    float   elapsedTime;
    HANDLE_ERROR( cudaEventElapsedTime( &elapsedTime,
                                        start, stop ) );
    printf("\x1B[33mElapsed time: %8.2E ms\x1B[0m\n", elapsedTime );
    HANDLE_ERROR( cudaEventDestroy( start ) );
    HANDLE_ERROR( cudaEventDestroy( stop ) );
  }
  void toc(char *message) {
    HANDLE_ERROR( cudaEventRecord( stop, 0 ) );
    HANDLE_ERROR( cudaEventSynchronize( stop ) );
    float   elapsedTime;
    HANDLE_ERROR( cudaEventElapsedTime( &elapsedTime,
                                        start, stop ) );
    printf("\x1B[33m%s: Elapsed time: %8.2E ms\x1B[0m\n", message, elapsedTime );
    HANDLE_ERROR( cudaEventDestroy( start ) );
    HANDLE_ERROR( cudaEventDestroy( stop ) );
  }
  void toc(float *elapsedTime, char *message) {
    HANDLE_ERROR( cudaEventRecord( stop, 0 ) );
    HANDLE_ERROR( cudaEventSynchronize( stop ) );
    HANDLE_ERROR( cudaEventElapsedTime( elapsedTime,
                                        start, stop ) );
    printf("\x1B[33m%s: Elapsed time: %8.2E ms\x1B[0m\n", message, *elapsedTime );
    HANDLE_ERROR( cudaEventDestroy( start ) );
    HANDLE_ERROR( cudaEventDestroy( stop ) );
  }
  void toc(float *elapsedTime) {
    HANDLE_ERROR( cudaEventRecord( stop, 0 ) );
    HANDLE_ERROR( cudaEventSynchronize( stop ) );
    HANDLE_ERROR( cudaEventElapsedTime( elapsedTime,
                                        start, stop ) );
    HANDLE_ERROR( cudaEventDestroy( start ) );
    HANDLE_ERROR( cudaEventDestroy( stop ) );
  }
};
@
The python wrapper is 
<<ceo.pxd>>=
## stopwatch structure
    cdef cppclass stopwatch:
        void tic()
        void toc()
        void toc(float *)
@ 
<<ceo.pyx>>=
## stopwatch structure
cdef class StopWatch:
    """ 
    Creates a stopwatch object.

    Parameters
    ----------
    
    Returns
    -------
    out: Stopwatch
        A Stopwatch object.

    Examples
    --------

    """
    cdef ceo.stopwatch *_c_stopwatch
    cdef float *elapsedTime

    def __cinit__(self):
	self._c_stopwatch = new ceo.stopwatch()

    def tic(self):
        self._c_stopwatch.tic()

    def toc(self,elapsedTime=None):
        if elapsedTime is None:  
            self._c_stopwatch.toc()
        else:
            self._c_stopwatch.toc(self.elapsedTime)

@

\subsection{Statistics definitions}
\label{sec:stat-defin}

Statistical moment are computed with the structure [[stats]]
<<statistics definition>>=
struct stats {
  cublasHandle_t handle;
  cublasStatus_t status;
  void setup(void);
  void cleanup(void);
  float mean(const float *data, int n_data);
  float mean(const float *data, mask *M, int n_data);
  float var(const float *data, int n_data);
  float std(const float *data, int n_data);
  float diff_var(const float *data_1, const float *data_2, int n_data);
  float diff_std(const float *data_1, const float *data_2, int n_data);
  float var(const float *data1, mask *M, int n_data);
  float std(const float *data1, mask *M, int n_data);
  float diff_var(const float *data1, const float *data2, mask *M, int n_data);
  float diff_std(const float *data1, const float *data2, mask *M, int n_data);
};
<<statistics functions>>=
void stats::setup(void) {
  cublasCreate(&handle);
}
void stats::cleanup(void) {
  cublasDestroy(handle);
}
<<mean>> 
<<mean filtered data>>
<<variance>> 
<<differential variance>> 
<<standart deviation>>
<<differential standart deviation>>
<<variance filtered data>>
<<standart deviation filtered data>>
<<differential variance filtered data>>
<<differential standard deviation filtered data>>
@  
Computing the mean of a vector [[data]]$=x$, $\bar x = \langle x \rangle$:
<<mean>>=
float stats::mean(const float *data, int n_data) {
  float results, *ones;
  HANDLE_ERROR( cudaMalloc((void**)&ones, sizeof(float)*n_data ) );
  dim3 blockDim(256);
  dim3 gridDim(n_data/256+1);
  fill_ones LLL gridDim,blockDim RRR (ones, n_data);
  CUBLAS_ERROR( cublasSdot(handle, n_data, data, 1, ones, 1, &results) );
  HANDLE_ERROR( cudaFree( ones ) );
  return results/n_data;
}
@  with the kernel
<<fill ones>>=
__global__ void fill_ones(float *ones, int n_data) 
{
int i;
i = blockIdx.x * blockDim.x + threadIdx.x;
 if (i<n_data)
       ones[i] = 1.;
}
<<fill ones (char)>>=
__global__ void fill_ones_char(char *ones, int n_data) 
{
int i;
i = blockIdx.x * blockDim.x + threadIdx.x;
 if (i<n_data)
       ones[i] = 1;
}

@  
Computing the mean of a vector [[data]]$=x\times f$, $\bar xf = \langle xf \rangle$ where $f$ is a filtering vector the same size than $x$ and made of 0 and 1:
<<mean filtered data>>=
float stats::mean(const float *data, mask *M, int n_data) {
  float results;
  CUBLAS_ERROR( cublasSdot(handle, n_data, data, 1, M->f, 1, &results) );
  return results/M->nnz;
}

@  
Computing the variance of a vector [[data]]$=x$, $\sigma^2_x=\langle x^2 \rangle - \langle x \rangle^2$:
<<variance>>=
float stats::var(const float *data, int n_data) {
  <<variance algorithm>>
  return results;
}
@  with 
<<variance algorithm>>=
float results, mean_data, *ones;
HANDLE_ERROR( cudaMalloc((void**)&ones, sizeof(float)*n_data ) );
dim3 blockDim(256);
dim3 gridDim(n_data/256+1);
fill_ones LLL gridDim,blockDim RRR (ones, n_data);
CUBLAS_ERROR( cublasSdot(handle, n_data, data, 1, ones, 1, &mean_data) );
HANDLE_ERROR( cudaFree( ones ) );
mean_data /= n_data;
CUBLAS_ERROR( cublasSdot(handle, n_data, data, 1, data, 1, &results) );
results /= n_data;
results -= (mean_data*mean_data);
@  
Computing the standart deviation $\sigma_x$ of a vector [[data]]$=x$:
<<standart deviation>>=
float stats::std(const float *data, int n_data) {
  <<variance algorithm>>
  return sqrtf(results);
}
@  
Computing the variance of a vector [[data]]$=x\times f$, $\sigma^2_{xf}=\langle (xf)^2 \rangle - \langle xf \rangle^2$ where $f$ is a filtering vector the same size than $x$ and made of 0 and 1:
<<variance filtered data>>=
float stats::var(const float *data1, mask *M, int n_data) {
  float results, mean_data, *data;
  HANDLE_ERROR( cudaMalloc((void**)&data, sizeof(float)*n_data ) );
  CUBLAS_ERROR( cublasScopy(handle, n_data, data1, 1, data, 1) );
  <<variance filtered data steps>>
  return results;
}
<<differential variance filtered data>>=
float stats::diff_var(const float *data1, const float *data2, mask *M, int n_data) {
  float results, mean_data, *data;
  HANDLE_ERROR( cudaMalloc((void**)&data, sizeof(float)*n_data ) );
  float alpha = -1;
  CUBLAS_ERROR( cublasScopy(handle, n_data, data1, 1, data, 1) );
  CUBLAS_ERROR( cublasSaxpy(handle, n_data, &alpha, data2, 1, data, 1) );
  <<variance filtered data steps>>
  return results;
}
<<differential standard deviation filtered data>>=
float stats::diff_std(const float *data1, const float *data2, mask *M, int n_data) {
  float results, mean_data, *data;
  HANDLE_ERROR( cudaMalloc((void**)&data, sizeof(float)*n_data ) );
  float alpha = -1;
  CUBLAS_ERROR( cublasScopy(handle, n_data, data1, 1, data, 1) );
  CUBLAS_ERROR( cublasSaxpy(handle, n_data, &alpha, data2, 1, data, 1) );
  <<variance filtered data steps>>
  return sqrtf(results);
}
@ the variance algorithm can now be applied on the filtered data
<<variance filtered data steps>>=
CUBLAS_ERROR( cublasSdot(handle, n_data, data, 1, M->f, 1, &mean_data) );
mean_data /= M->nnz;
CUBLAS_ERROR( cublasSdot(handle, n_data, data, 1, data, 1, &results) );
results /= M->nnz;
results -= (mean_data*mean_data);
HANDLE_ERROR( cudaFree( data ) );
@  
Computing the standard deviation of a vector [[data]]$=x\times f$, $\sigma_{xf}=\left(\langle (xf)^2 \rangle - \langle xf \rangle^2\right)^{1/2}$ where $f$ is a filtering vector the same size than $x$ and made of 0 and 1:
<<standart deviation filtered data>>=
float stats::std(const float *data1, mask *M, int n_data) {
  float results, mean_data, *data;
  HANDLE_ERROR( cudaMalloc((void**)&data, sizeof(float)*n_data ) );
  CUBLAS_ERROR( cublasScopy(handle, n_data, data1, 1, data, 1) );
  <<variance filtered data steps>>
  return sqrtf(results);
}

@  
Computing the differential variance of 2 vectors [[data1]]$=x_1$ and [[data2]]$=x_2$, $\sigma^2_{x_1-x_2}=\langle (x_1-x_2)^2 \rangle - \langle (x_1-x_2) \rangle^2$:
<<differential variance>>=
float stats::diff_var(const float *data1, const float *data2, int n_data) {
  <<differential variance algorithm>>
  return results;
}
@ with
<<differential variance algorithm>>=
float *data;
HANDLE_ERROR( cudaMalloc((void**)&data, sizeof(float)*n_data) );
float alpha = -1;
CUBLAS_ERROR( cublasScopy(handle, n_data, data1, 1, data, 1) );
CUBLAS_ERROR( cublasSaxpy(handle, n_data, &alpha, data2, 1, data, 1) );
<<variance algorithm>>
HANDLE_ERROR( cudaFree( data ) );
@  
Computing the differential standart deviation $\sigma_{x_1-x_2}$ of vector [[data1]]$=x_1$ and [[data2]]$=x_2$:
<<differential standart deviation>>=
float stats::diff_std(const float *data1, const float *data2, int n_data) {
  <<differential variance algorithm>>
  return sqrtf(results);
}
@
The error function;
<<cublas error>>=
void CUBLAS_ERROR(cublasStatus_t status) {
  if (CUBLAS_VERBOSE) {
      printf("\nCUBLAS: ");
      if (status==CUBLAS_STATUS_SUCCESS)
	printf("the operation completed successfully\n");
      else if (status==CUBLAS_STATUS_NOT_INITIALIZED)
	printf("the library was not initialized\n");
      else if (status==CUBLAS_STATUS_ALLOC_FAILED)
	printf("the reduction buffer could not be allocated\n");
      else if (status==CUBLAS_STATUS_ARCH_MISMATCH)
	printf("the device does not support double-precision\n");
      else if (status==CUBLAS_STATUS_EXECUTION_FAILED)
	printf("the function failed to launch on the GPU\n");
    }
}

@ 
\subsection{Pupil definition}
\label{sec:pup-def}

In the following, a circular pupil is computed:
<<circular pupil>>=
__global__ void circular_pupil(char *pupil, int N)
{
  int i, j, k;
  float h,x,y,r;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  k = i*N + j;
  if ( (i<N) && (j<N) ) {
    h = (float) (N-1)/2;
    x = i - h;
    y = j - h;
    r = x*x + y*y;
    pupil[k] = (r>N*N/4) ? 0 : 1;
  }
}
@ 
Next we compute the mask of lenslets mapping the pupil:
<<valid lenslet>>=
__global__ void valid_lenslet(char *mask, int N_pupil, float threshold)
{
  int i, j, n, iL, jL, sum, ai, bi, aj, bj, kL;
  float h,x,y,r,R;
  // pixel per lenslet
  n = N_pupil/N_SIDE_LENSLET;
  // lenslet index
  iL = blockIdx.x * blockDim.x + threadIdx.x;
  jL = blockIdx.y * blockDim.y + threadIdx.y;
  if ( (iL<N_SIDE_LENSLET) & (jL<N_SIDE_LENSLET)) {

    sum = 0;
    ai = iL*n;
    bi = (iL+1)*n;
    aj = jL*n;
    bj = (jL+1)*n;
    h = (float) (N_pupil-1)/2;
    R = N_pupil*N_pupil/4;

    for (i=ai;i<bi;i++) {
      for (j=aj;j<bj;j++) {
	x = i - h;
	y = j - h;
	r = x*x + y*y;
    	sum += (r>R) ? 0 : 1;
      }
    }
 
    kL = iL*N_SIDE_LENSLET + jL;
    threshold *= n*n;
    mask[kL] = (sum>threshold) ? 1 : 0;

  }
}
@  The following routine computes the masks of valid lenslet [[lenslet_mask]] and actuators [[actuator_mask]] for a circular pupil corresponding to a square [[NL]]$\times$[[NL]] lenslet array with [[n]] pixel per lenslet.
<<Fried geometry masks>>=
char fried_geometry_setup(char *lenslet_mask, char *actuator_mask, 
			  int NL, int n, float threshold)
{
HANDLE_ERROR( cudaMemset(lenslet_mask,  0, sizeof(char)*NL*NL         ) );
HANDLE_ERROR( cudaMemset(actuator_mask, 0, sizeof(char)*(NL+1)*(NL+1) ) );
dim3 blockDim(16,16);
dim3 gridDim(NL/16+1,NL/16+1);
fried_geometry LLL gridDim,blockDim RRR (lenslet_mask, actuator_mask, NL, n, threshold);
return 1;
}
@
<<Fried geometry>>=
  __global__ void fried_geometry(char *lenslet_mask, char *actuator_mask, 
				 int NL, int n, float threshold)
{
  int i, j, iL, jL, sum, ai, bi, aj, bj, kL, kA, N_pupil;
  float h,x,y,r,R;
  // total pixel
  N_pupil = n*NL;
  // lenslet index
  iL = blockIdx.x * blockDim.x + threadIdx.x;
  jL = blockIdx.y * blockDim.y + threadIdx.y;
  if ( (iL<NL) & (jL<NL)) {

    sum = 0;
    ai = iL*n;
    bi = (iL+1)*n;
    aj = jL*n;
    bj = (jL+1)*n;
    h = (float) (N_pupil-1)/2;
    R = N_pupil*N_pupil/4;

    for (i=ai;i<bi;i++) {
      for (j=aj;j<bj;j++) {
	x = i - h;
	y = j - h;
	r = x*x + y*y;
    	sum += (r>R) ? 0 : 1;
      }
    }
 
    threshold *= n*n;

    if (sum>threshold) {

      kL = iL*NL + jL;
      lenslet_mask[kL] = 1;

      kA = lenset2actuator(iL,jL,NL, 1, 1);     
      actuator_mask[kA] = 1;
      kA = lenset2actuator(iL,jL,NL,-1, 1);     
      actuator_mask[kA] = 1;
      kA = lenset2actuator(iL,jL,NL,-1,-1);     
      actuator_mask[kA] = 1;
      kA = lenset2actuator(iL,jL,NL, 1,-1);     
      actuator_mask[kA] = 1;

    }

  }
}
@ 
The following routine computes the masks of valid lenslet [[lenslet_mask]] and actuators [[actuator_mask]] for an arbitrary pupil corresponding to a square [[NL]]$\times$[[NL]] lenslet array with [[n]] pixel per lenslet.
<<Fried geometry masks (arbitrary pupil)>>=
char fried_geometry_setup_vs_pupil(char *lenslet_mask, char *actuator_mask, 
			  int NL, int n, float threshold, char *pupil)
{
HANDLE_ERROR( cudaMemset(lenslet_mask,  0, sizeof(char)*NL*NL         ) );
HANDLE_ERROR( cudaMemset(actuator_mask, 0, sizeof(char)*(NL+1)*(NL+1) ) );
dim3 blockDim(16,16);
dim3 gridDim(NL/16+1,NL/16+1);
fried_geometry_vs_pupil LLL gridDim,blockDim RRR (lenslet_mask, actuator_mask, NL, n, threshold, pupil);
return 1;
}
@
<<Fried geometry (arbitrary pupil)>>=
__global__ void fried_geometry_vs_pupil(char *lenslet_mask, char *actuator_mask, 
				 const int NL, const int n, const float threshold, const char *pupil)
{
  int i, j, k, iL, jL, sum, ai, bi, aj, bj, kL, kA, N_pupil;
  float threshold_px;
  // total pixel
  N_pupil = n*NL;
  // lenslet index
  iL = blockIdx.x * blockDim.x + threadIdx.x;
  jL = blockIdx.y * blockDim.y + threadIdx.y;
  if ( (iL<NL) & (jL<NL)) {

    sum = 0;
    ai = iL*n;
    bi = (iL+1)*n;
    aj = jL*n;
    bj = (jL+1)*n;

    for (i=ai;i<bi;i++) {
      for (j=aj;j<bj;j++) {
        k = i*N_pupil + j;
    	sum += pupil[k];
      }
    }
 
    threshold_px = threshold*n*n;

    if (sum>threshold_px) {

      kL = iL*NL + jL;
      lenslet_mask[kL] = 1;

      kA = lenset2actuator(iL,jL,NL, 1, 1);     
      actuator_mask[kA] = 1;
      kA = lenset2actuator(iL,jL,NL,-1, 1);     
      actuator_mask[kA] = 1;
      kA = lenset2actuator(iL,jL,NL,-1,-1);     
      actuator_mask[kA] = 1;
      kA = lenset2actuator(iL,jL,NL, 1,-1);     
      actuator_mask[kA] = 1;

    }

  }
}
@
<<lenslet 2 actuator>>=
__device__ inline int lenset2actuator(int iL, int jL, int NL, int io, int jo)
{
  int iL_p, jL_p, iL_pp, jL_pp, iA, jA;

  iL_p = 2*iL + 1;
  jL_p = 2*jL + 1;
  
  iL_pp = iL_p + io;
  jL_pp = jL_p + jo;
  
  iA = iL_pp/2;
  jA = jL_pp/2;
  
  return iA*(NL+1) + jA;

}
@

\subsection{The Giant Magellan Telescope pupil}
\label{sec:gmt-pupil}

The GMT pupil is made of 7 circular segments of diameter  $D_s=8.417$m.
The clear aperture diameter is $D_{sca}=8.365$m.
There is one segment centered on the optical axis with a $D_h=1.78$m diameter hole in the middle.
The six other segments are evenly located around the center one and tilted of $\theta_s = 13.522^{\circ}$.
The distance from the optical axis to the center of an off--axis segment is $L=8.774$m.
The ASM and the FSM off--axis segments have a central hole of diameter $D_{sh}=0.559m$ and $D_{sh}=0.07$m, respectively.
<<GMT pupil>>=
__global__ void GMT_pupil(char *pupil, const int N, const float S, float _Dsh, const float c, const char v)
{
  int i, j, k, seg;
  float h,x,y,xp,yp, co_seg, so_seg, cOs, Dh, Dsca, Ds, Dsh, L;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  k = i*N + j;
  seg = blockIdx.z;
  if ( (i<N) && (j<N) ) {
    Dh   = c*2.300;
    Dsh  = _Dsh;
    Dsca = c*8.365;
    Ds   = c*8.417;
    L    = c*8.774;
    <<GMT pupil coordinates>>
    if (seg==0) {
      <<GMT pupil definition 0>>
    } else {
      <<GMT pupil definition>>
    }
  }
}
@
Lets call $x$ and $y$ the coordinates in the pupil plane.
<<GMT pupil coordinates>>=
h = S/(N-1);
x = (j - 0.5*(N-1))*h;
y = (i - 0.5*(N-1))*h;
Dsca *= Dsca;
@ 
The center segment is defined with
\begin{equation*}
   D_h^2 \le  4\left( x^2 + y^2 \right)  \le D_{sca}^2.
\end{equation*}
<<GMT pupil definition 0>>=
h = (x*x + y*y)*4.0;
Dh   *= Dh;
if ( (h>=Dh) && (h<=Dsca) ) {
  pupil[k] = v;
}
@ For the off--axis segments, the coordinates need to be projected on the tilted-planes of the segments.
The segments are tilted with respect to a line tangent to the segment at the point where the line joining the center of the segment to the optical axis crossed the segment edge.
The coordinate transformations are the following
\begin{enumerate}
\item the X--axis is aligned with the line joining the center of the segment to the optical axis:
  \begin{eqnarray*}
    x^{\prime} &=& x\cos(\theta_k) - y\sin(\theta_k) \\
    y^{\prime} &=& x\sin(\theta_k) + y\cos(\theta_k) 
  \end{eqnarray*}
where $$\theta_k=\left(k-{1\over 2}\right){\pi\over 3},\quad\forall k=1,\dots,6$$ is the angle between the X--axis and the line joining the center of the $k$th segment,
<<GMT pupil definition>>=
sincospif( (seg-0.5)/3.0, &so_seg, &co_seg);
xp = x*co_seg - y*so_seg;
yp = x*so_seg + y*co_seg;
@ \item the origin of coordinates is moved to the rotation point:
  \begin{equation*}
    x^{\prime} \leftarrow x^{\prime} - \left( L - { D_s \over 2 } \right)
  \end{equation*}
<<GMT pupil definition>>=
xp -= L - 0.5*Ds;
@ \item the coordinates are projected on the tilted planes:
  \begin{eqnarray*}
    x^{\prime} &\leftarrow & {x^{\prime} \over \cos(\theta_s) } \\
    y^{\prime} &\leftarrow &  {y^{\prime} \over \cos(\theta_s) }
  \end{eqnarray*}
<<GMT pupil definition>>=
cOs = cospif( 13.522/180.0 );
xp /= cOs;
yp /= cOs;
@ \item the projected coordinates are centered on the center of the segment
  \begin{equation*}
    x^{\prime} \leftarrow x^{\prime} - \left( { D_s \over 2 } \right)
  \end{equation*}
<<GMT pupil definition>>=
xp -= Ds*0.5;
@ \end{enumerate}
and the off--axis segment is given with
\begin{equation*}
  4\left( {x^{\prime}}^2 + {y^{\prime}}^2 \right) \le D_{sca}^2.
\end{equation*}
<<GMT pupil definition>>=
h = (xp*xp + yp*yp)*4.0;
Dsh *= Dsh;
if ( (h>=Dsh) && (h<=Dsca) ) {
  pupil[k] = v;
 }
@

\subsection{Mask structure}
\label{sec:mask-structure}

Lets define a mask structure with the following parameters:
\begin{itemize}
\item the mask [[m]] has a type of char and contains 0 and 1,
<<mask parameters>>=
char *m;  
@ \item the filter [[f]] has a type of float and contains 0 and 1,
<<mask parameters>>=
float *f;  
@ \item the total number of element [[nel]],
<<mask parameters>>=
int nel;  
@ \item the number of non zeros elements [[nnz]].
<<mask parameters>>=
float nnz;  
@ \item the surface area of the mask in $m^2$ [[mask_area]]:
<<mask parameters>>=
float area;  
@ \end{itemize}

The mask structure definition is:
<<mask structure>>=
struct mask {
  <<mask parameters>>
  void setup(int n);
  void setup_circular(int n);
  void setup_GMT(int n, float S);
  void set_filter(void);
  void cleanup(void);
};
@ 
The mask functions are:
\begin{itemize}
\item [[setup]]
  \begin{itemize}
  \item with the total number of element in the mask [[n]]:
<<mask functions>>=
void mask::setup(int n) {
  nel = n;
  area = 1.0;
  <<setup commom>>
  dim3 blockDim(256);
  dim3 gridDim(nel/256+1);
  fill_ones_char LLL gridDim,blockDim RRR (m,nel);
  set_filter();
}
@ with 
<<setup commom>>=
HANDLE_ERROR( cudaMalloc((void**)&m, sizeof(char)*nel ) );
HANDLE_ERROR( cudaMalloc((void**)&f, sizeof(float)*nel ) );
HANDLE_ERROR( cudaMemset( m, 0, sizeof(char)*nel) );
HANDLE_ERROR( cudaMemset( f, 0, sizeof(float)*nel) );
@ \item with a circular mask inside an [[n]]$\times$[[n]] array
<<mask functions>>=
void mask::setup_circular(int n) {
  nel = n*n;
  area = 1.0;
  <<setup commom>>
  dim3 blockDim(16,16);
  dim3 gridDim(n/16+1,n/16+1);
  circular_pupil LLL gridDim,blockDim RRR ( m , n );
  set_filter();
}
@ \item with the Giant Magellan Telescope mask inside an [[n]]$\times$[[n]] array of length [[S]] in meter
<<mask functions>>=
void mask::setup_GMT(int n, float S) {
  nel = n*n;
  area = 368.0;
  <<setup commom>>
  dim3 blockDim(16,16);
  dim3 gridDim(n/16+1,n/16+1,7);
  // PRIMARY + ASM
  GMT_pupil LLL gridDim,blockDim RRR ( m , n, S, 0.559 , 1.0        , 1);
  // ASM SHADOW
  GMT_pupil LLL gridDim,blockDim RRR ( m , n, S, 0.000 , 1.042/8.365, 0);
  /*
  // PRIMARY + FSM
  GMT_pupil LLL gridDim,blockDim RRR ( m , n, S, 0.070 , 1.0        , 1);
  // FSM SHADOW
  GMT_pupil LLL gridDim,blockDim RRR ( m , n, S, 0.000 , 1.049/8.365, 0);
  */
  set_filter();
}
@
\end{itemize}
\item set the filter and compute the number of non--zeros elements:
<<mask functions>>=
void mask::set_filter(void) {
  dim3 blockDim(256);
  dim3 gridDim(nel/256+1);
  fill_ones_filtered LLL gridDim,blockDim RRR (f, m, nel);
  cublasHandle_t handle;
  cublasCreate(&handle);
  CUBLAS_ERROR( cublasSasum(handle, nel, f, 1, &nnz) );
  printf("@(CEO)>mask: nnz = %.0f (density: %4.2f) \n",nnz,nnz/nel);
  cublasDestroy(handle);
}
@ \item [[cleanup]]
<<mask functions>>=
void mask::cleanup(void) {
  fprintf(stdout,"@(CEO)>mask: freeing memory!\n");
  HANDLE_ERROR( cudaFree( m ) );
  HANDLE_ERROR( cudaFree( f ) );
}
@  with the kernel
<<fill ones filtered>>=
__global__ void fill_ones_filtered(float *ones, const char* mask, int n_data) 
{
int i;
i = blockIdx.x * blockDim.x + threadIdx.x;
 if ( (i<n_data) && (mask[i]) )
       ones[i] = 1;
}
@
\end{itemize}

The python wrapper is 
<<ceo.pxd>>=
## mask structure
    cdef cppclass mask:
        char *m
        float *f
        void setup(int)
        void setup_circular(int)
        void setup_GMT(int, float)
        void cleanup()
@ 
<<ceo.pyx>>=
## mask structure
cdef class MaskAbstract:
    """ 
    Creates a mask object.

    Parameters
    ----------
    
    Returns
    -------
    out: Mask
        A Mask object.

    Examples
    --------

    """
    cdef ceo.mask *_c_mask
    cdef int n

    def __cinit__(self,int n, S=0):
	self._c_mask = new ceo.mask()
        self.n = n

    property f:
        def __get__ (self):
            x = cuFloatArray(shape=(self.n,self.n))
            x._c_gpu.dev_data = self._c_mask.f
            return x

cdef class Mask(MaskAbstract):
    """ 
    Creates a mask object.

    Parameters
    ----------
     n: an int number
       The sampling in pixel of the pupil.
    
   
    Returns
    -------
    out: Mask
        A Mask object.

    Examples
    --------

    """

    def __cinit__(self,int n):
        MaskAbstract.__init__(self,n)
        self._c_mask.setup(n*n)

    def __dealloc__(self):
        self._c_mask.cleanup()

cdef class Telescope(MaskAbstract):
    """ 
    Creates a mask object.

    Parameters
    ----------
    n: an int number
       The sampling in pixel of the pupil.
    
    Returns
    -------
    out: Mask
        A Mask object.

    Examples
    --------

    """ 
    def __cinit__(self, int n):
        MaskAbstract.__init__(self,n)
	self._c_mask.setup_circular(self.n)    

    def __dealloc__(self):
        self._c_mask.cleanup()

cdef class GMT(MaskAbstract):
    """ 
    Creates a mask object for the Giant Magellan Telescope pupil.

    Parameters
    ----------
    n: an int number
       The sampling in pixel of the pupil.
    S: a float number
       The size of the pupil in meter.
    
    Returns
    -------
    out: Mask
        A Mask object.

    Examples
    --------

    """
    def __cinit__(self, int n, float S):
        MaskAbstract.__init__(self,n)
	self._c_mask.setup_GMT(self.n,S)    

    def __dealloc__(self):
        self._c_mask.cleanup()
@ 

\subsection{Input/Output}
\label{sec:inputoutput}

In the following, the routines to write data on the device into a file are described.
Each file contains first an integer with the number of pages [[n_page]] and for each page the number of elements [[n_data]] and the data [[data]].
<<device to file>>=
void dev2file(const char* filename, float* d__data, int n_data) {
  int n_page=1;
   <<device to file common start>>
  float *data;
  data = (float*)malloc(sizeof(float)*n_data);
  HANDLE_ERROR( cudaMemcpy( data, d__data,
			  sizeof(float)*n_data,
			  cudaMemcpyDeviceToHost ) );
  fwrite(&n_data,sizeof(int),1,fid);
  fwrite(data,sizeof(float),n_data,fid);
  <<device to file common end>>
}
void dev2file(const char* filename, float* d__data, int n_data, 
	      int n_data_page, int n_page) {
   <<device to file common start>>
  float *data;
  data = (float*)malloc(sizeof(float)*n_data);
  HANDLE_ERROR( cudaMemcpy( data, d__data,
			  sizeof(float)*n_data,
			  cudaMemcpyDeviceToHost ) );
  int pos=0;
  for (int k_page=0;k_page<n_page;k_page++) {
    fwrite(&n_data_page,sizeof(int),1,fid);
    fwrite(data+pos,sizeof(float),n_data_page,fid);
    pos += n_data_page;
  }
  <<device to file common end>>
}
void dev2file(const char* filename, float* d__data, int n_data, 
	      int *n_data_page, int n_page) {
   <<device to file common start>>
  float *data;
  data = (float*)malloc(sizeof(float)*n_data);
  HANDLE_ERROR( cudaMemcpy( data, d__data,
			  sizeof(float)*n_data,
			  cudaMemcpyDeviceToHost ) );
  int pos=0;
  for (int k_page=0;k_page<n_page;k_page++) {
    fwrite(n_data_page+k_page,sizeof(int),1,fid);
    fwrite(data+pos,sizeof(float),n_data_page[k_page],fid);
    pos += n_data_page[k_page];
  }
  <<device to file common end>>
}
void dev2file(const char* filename, float2* d__data, int n_data) {
  int n_page=1;
   <<device to file common start>>
  float2 *data;
  data = (float2*)malloc(sizeof(float2)*n_data);
  HANDLE_ERROR( cudaMemcpy( data, d__data,
			  sizeof(float2)*n_data,
			  cudaMemcpyDeviceToHost ) );
  fwrite(&n_data,sizeof(int),1,fid);
  fwrite(data,sizeof(float2),n_data,fid);
  <<device to file common end>>
}
void dev2file(const char* filename, int* d__data, int n_data) {
  int n_page=1;
   <<device to file common start>>
  int *data;
  data = (int*)malloc(sizeof(int)*n_data);
  HANDLE_ERROR( cudaMemcpy( data, d__data,
			  sizeof(int)*n_data,
			  cudaMemcpyDeviceToHost ) );
  fwrite(&n_data,sizeof(int),1,fid);
  fwrite(data,sizeof(int),n_data,fid);
  <<device to file common end>>
}
void dev2file(const char* filename, char* d__data, int n_data) {
  int n_page=1;
   <<device to file common start>>
  char *data;
  data = (char*)malloc(sizeof(char)*n_data);
  HANDLE_ERROR( cudaMemcpy( data, d__data,
			  sizeof(char)*n_data,
			  cudaMemcpyDeviceToHost ) );
  fwrite(&n_data,sizeof(int),1,fid);
  fwrite(data,sizeof(char),n_data,fid);
  <<device to file common end>>
}

<<device to file common start>>=
struct stat sb;
char path[50];

if (stat("bins",&sb)!=0)
  if (mkdir("bins", S_IRWXU)==0)
    fprintf(stdout,"@(CEO)>utilities: bins directory created!\n");
  else {
    fprintf(stdout,"\n\x1B[31m@(CEO)>utilities: bins mkdir failed!\x1B[0m\n");
    return;
  }
strcpy(path,"bins/");
strcat(path,filename);
FILE *fid;
fid = fopen(path,"wb");
if (fid==NULL) {
  fprintf(stdout,"\n\x1B[31m@(CEO)>utilities: Unable to open the file: %s!\x1B[0m\n",path);
  return;
 }
fwrite(&n_page,sizeof(int),1,fid);
<<device to file common end>>=
fclose(fid);
free(data);
fprintf(stdout,"@(CEO)>utilities: Data saved to %s!\n",filename);
@

\subsubsection{Device to host}
\label{sec:dev-to-host}

<<data to host from device>>=
void dev2host( float *host_data, float *dev_data, int N) {
     HANDLE_ERROR( cudaMemcpy( host_data, dev_data, 
			       N*sizeof(float), cudaMemcpyDeviceToHost ) ) ;
     HANDLE_ERROR( cudaDeviceSynchronize() );
}
@
<<data to device from host>>=
void host2dev( float **dev_data, float *host_data, int N) {
    fprintf(stdout,"__ HOST2DEV __\n");
    HANDLE_ERROR( cudaMalloc( (void**)dev_data, N*sizeof(float)) );
    HANDLE_ERROR( cudaMemcpy( *dev_data, host_data, 
			       N*sizeof(float), cudaMemcpyHostToDevice ) ) ;
    HANDLE_ERROR( cudaDeviceSynchronize() );
}
@ 
<<free device>>=
void freedev( float **dev_data ) {
    fprintf(stdout,"__ FREEDEV __\n");
    HANDLE_ERROR( cudaFree( *dev_data) );
}
@ 
<<gpu data structure>>=
struct gpu {
  float *dev_data, *host_data;
  int N;
  stats S;
  void dev_malloc(void);
  void free_dev(void);
  void dev2host(void);
  void host2dev(void);
};
<<gpu data structure function>>=
void gpu::dev_malloc(void) {
    HANDLE_ERROR( cudaMalloc( (void**)&dev_data, N*sizeof(float)) );
}
void gpu::free_dev(void) {
    HANDLE_ERROR( cudaFree( dev_data ) );
}
void gpu::dev2host(void) {
     HANDLE_ERROR( cudaMemcpy( host_data, dev_data, 
			       N*sizeof(float), cudaMemcpyDeviceToHost ) ) ;
     HANDLE_ERROR( cudaDeviceSynchronize() ); 
}
void gpu::host2dev(void) {
    HANDLE_ERROR( cudaMemcpy( dev_data, host_data, 
			       N*sizeof(float), cudaMemcpyHostToDevice ) ) ;
    HANDLE_ERROR( cudaDeviceSynchronize() );
}
@
<<ceo.pxd>>=
## device to host
    void dev2host( float *host_data, float *dev_data, int N)
    void host2dev( float **dev_data, float *host_data, int N)
    void freedev( float **dev_data )
@ 
The cu<Type>Array class is a cython class that is a container for CUDA variables:
<<ceo.pxd>>=
cdef extern from "utilities.h":
    cdef cppclass gpu:
        float *dev_data
        float *host_data
        int N
        void dev_malloc()
        void free_dev()
        void dev2host()
        void host2dev()
@ 
<<ceo.pyx>>=
cdef class cuFloatArray:
    """
    A class to interact with a cuda float array

    Parameters
    ---------
    shape: (int,int), optional
        Number of rows and colums
    host_array: data object, optional
        Host data to copy to the device
    
    Returns
    -------
    out: cuFloatArray 
        A cuFloatArray object
    """
     
    cdef ceo.gpu *_c_gpu
    cdef public int size
    cdef public shape
    cdef dev_malloc
    cdef public np.ndarray host_data
    cdef units

    def __cinit__(self,shape=None,host_data=None,dev_malloc=False):
        self._c_gpu = new ceo.gpu()
        self.dev_malloc = dev_malloc
        if shape is not None:
            self.shape = shape
            self.size = np.prod(shape)
            self._c_gpu.N = self.size
        if self.dev_malloc:
            self._c_gpu.N = self.size
            self._c_gpu.dev_malloc()           
        if host_data is not None:
            self.host_data = np.array( host_data , dtype=np.float32 , order='C')
            self.shape = host_data.shape
            self.size = np.prod(self.shape)
            self._c_gpu.N = self.size
            if not self.dev_malloc:
                self._c_gpu.dev_malloc()
            self._c_gpu.host_data = <float *>self.host_data.data;
            self._c_gpu.host2dev()
            self.dev_malloc = True    
        self.units = {'micron': 1e6, 'nm': 1e9, 'arcsec': 180*3600/math.pi}

    def __dealloc__(self):
         if self.dev_malloc:
            self._c_gpu.free_dev()

    def host(self,units=None,zm=False,mask=None):
        """
        Copies the data from the device to the host and returns the associated ndarray
        """
        if self.shape==(0,0) or self.shape is None:
            raise ValueError("Data must have a size greater than zero!!")
        self.host_data = np.zeros(self.shape,order='c',dtype=np.float32)
        self._c_gpu.host_data = <float *>self.host_data.data;
        self._c_gpu.dev2host()
        if zm:
            if mask is None:
                self.host_data -= self.host_data.mean()
            else:
                mean_host_data = np.sum(self.host_data*mask)/np.sum(mask)
                self.host_data = mask*(self.host_data-mean_host_data)
        if units is not None:
            self.host_data = self.host_data*self.units[units]
        return self.host_data
@ 


\subsection{Atmospheric dispersion}
\label{sec:atmosph-disp}

The optical refractive index of air $n-1$ is given as a function of the wavelength [$\mu$m], the altitude [m], the temperature [$^{\circ}$C] and the humidity [\%].
It is defined with the model of Owens\cite{Owens67} (\url{http://www.astrosurf.com/prostjp/Dispersion_en.html}) given by
\begin{eqnarray*}
  \label{eq:5}
  \lefteqn{ \left(n - 1\right) \times 10^8 = } \\
  && \left[ 2371.34 + {683939.7 \over 130 - \sigma^2} + {4547.3 \over 38.9 - \sigma^2} \right]D_s + \\
  && \left[ 6487.31 + 58.05\sigma^2 - 0.71150\sigma^4 + 0.08851\sigma^6 \right]D_w,
\end{eqnarray*}
in which $\sigma=1/\lambda$, $\lambda$ is the wavelength in micron.
<<atmosphere refractive index>>=
double atmosphere_refractive_index(float wavelength, float altitude, 
				   float temperature, float humidity)
  {
    double sigma2, n_minus_one, Ds, Dw, T, Ps, Pw, H, P0;

    sigma2 = 1.0/wavelength/wavelength;
    T = temperature + 273;
    H = humidity/100.0;
    P0 = 1013.25;

    <<dry air partial pressure>>
    <<density of dry air>>
    <<water vapor partial pressure>>
    <<density of water vapor>>

    n_minus_one = ( 2371.34 + 683939.7 / ( 130.0 - sigma2) + 
		    4547.3 / ( 38.9 - sigma2 ) ) * Ds +
    ( 6487.31 + sigma2 * ( 58.05 - sigma2 * ( 0.71150 - 0.08851*sigma2 ) ) ) * Dw;

    return n_minus_one*1e-8;
  }					
@ 
$D_s$ is the density of dry air:
\begin{equation*}
  \label{eq:6}
  D_s = { P_s \over T} \left[ 1 + P_s\left( 57.90 \times 10^{-8} - { 9.3250 \times 10^{-4} \over T } + {0.25844 \over T^2} \right) \right],
\end{equation*}
<<density of dry air>>=
Ds = (Ps/T)*( 1 + Ps*( 57.90e-8 - ( 9.3250e-4  - 0.25844/T )/T ) );
@ 
$D_w$ is the density of water vapor:
\begin{eqnarray*}
  \lefteqn{ D_w =  {P_w\over T} \Bigg\{ 1 + P_w \left[ 1 + \left( 3.7\times 10^{-4} \right)P_w \right] \times }\\
  && \left[ -2.37321 \times 10^{-3} + {2.23366 \over T } - {710.792 \over T^2 } + {7.75141\times 10^4 \over T^3} \right] \Bigg\}
\end{eqnarray*}
<<density of water vapor>>=
Dw = (Pw/T)*( 1 + Pw*( 1 + 3.7e-4*Pw ) )*
    ( -2.37321e-3 + ( 2.23366  - ( 710.792 - 7.75141e4/T )/T )/T );
@ 
where $P_s$ is the dry air partial pressure
\begin{equation*}
  \label{eq:7}
  P_s = P_0\left( 1 -  (2.25577 \times 10^{-5} ) h \right)^{5.25588},
\end{equation*}
with $P_0=1013.25$mb and $h$ the altitude in meter
<<dry air partial pressure>>=
Ps = P0*pow( 1 - 2.25577e-5*altitude , 5.25588 );
@ 
and $P_w$ is the water vapor partial pressure
\begin{eqnarray*}
  P_w &=& P_{ws} { H \over 100 } \\
  P_{ws} &=& T^{-8.2}\exp\left( 77.3450 + 0.0057 T - {7235 \over T} \right)
\end{eqnarray*}
with $H$ the relative humidity in percent and $T$ is the temperature in degree Kelvin.
<<water vapor partial pressure>>=
Pw = H*exp( 77.3450 + 0.0057*T - 7235.0/T )/pow(T,8.2);
@ 
The refraction angle is given by
\begin{equation*}
  \varepsilon(\lambda) = \left[ n(\lambda)-1 \right] \tan(z)
\end{equation*}
where $z$ is the zenith angle.
The atmospheric dispersion $\Xi$ corresponding to a spectral filter of width $\Delta\lambda$ with central wavelength $\lambda_c$ is written
\begin{equation*}
  \Xi = \left[ n\left( \lambda_c - {\Delta\lambda\over2} \right) - n\left( \lambda_c + {\Delta\lambda\over2} \right) \right] \tan(z)
\end{equation*}
<<atmospheric dispersion>>=
double atmospheric_dispersion(float wavelength, float delta_wavelength,
                                   float zenith, float altitude, 
				   float temperature, float humidity)
{
double n1, n2, xi;
float lambda1, lambda2;
lambda1 = wavelength - 0.5*delta_wavelength;
lambda2 = wavelength + 0.5*delta_wavelength;
n1 =  atmosphere_refractive_index(lambda1, altitude, 
				   temperature, humidity);
n2 =  atmosphere_refractive_index(lambda2, altitude, 
				   temperature, humidity);
xi = (n1-n2)*tan(zenith);
return xi;
}
@

The python wrapper is 
<<ceo.pxd>>=
## atmosphere dispersion  
    double atmosphere_refractive_index(float wavelength, float altitude, 
                                        float temperature, float humidity)
    double atmospheric_dispersion(float wavelength, float delta_wavelength,
                                   float zenith, float altitude, 
				   float temperature, float humidity)
@ 
<<ceo.pyx>>=
## atmosphere dispersion  
cpdef double atmosphereRefractiveIndex(float wavelength, float altitude, 
                                 float temperature, float humidity ):
    return atmosphere_refractive_index(wavelength, altitude, 
                                       temperature, humidity)
cpdef double atmosphericDispersion(float wavelength, float delta_wavelength,
                                   float zenith, float altitude, 
				   float temperature, float humidity):
    return atmospheric_dispersion(wavelength, delta_wavelength,
				  zenith, altitude, 
				  temperature, humidity)
