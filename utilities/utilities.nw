% -*- mode: Noweb; noweb-code-mode: c-mode -*-
@
\subsection{The files}

\subsubsection{Header}

<<utilities.h>>=
#ifndef __UTILITIES_H__
#define __UTILITIES_H__

#include <sys/stat.h>
#include <stdio.h>
#include <cuda.h>
#include <cuda_runtime.h>
#include <curand.h>
#include <curand_kernel.h>
#include <cufft.h>
#include "cublas_v2.h"
#include "cusparse_v2.h"

#include "definitions.h"

#define PI 3.141592653589793
#define RADIAN2ARCSEC (180*3600/PI)
#define MIN(a, b)  (((a) < (b)) ? (a) : (b))
#define MAX(a, b)  (((a) > (b)) ? (a) : (b))
#define CUBLAS_VERBOSE 0

static void HandleError( cudaError_t err,
                         const char *file,
                         int line ) {
  if (err != cudaSuccess)  {
    fprintf(stderr,"\n\x1B[31m@(CEO)>ERROR: %s in %s at line %d\x1B[0m\n", 
	    cudaGetErrorString( err ), file, line );
    exit( EXIT_FAILURE );
  }
}
#define HANDLE_ERROR( err ) (HandleError( err, __FILE__, __LINE__ ))

static void HandleErrorCUFFT( cufftResult_t err,
			      const char *msg,
			      const char *file,
			      int line ) {
  if (err != CUFFT_SUCCESS)  {
    fprintf(stderr,"\n\x1B[31m@(CEO)>CUFFT ERROR: %s in %s at line %d\x1B[0m\n", 
	    msg, file, line );
    exit( EXIT_FAILURE );
  }
}
#define HANDLE_ERROR_CUFFT( err, msg ) (HandleErrorCUFFT( err, msg, __FILE__, __LINE__ ))

static void HandleErrorCUSPARSE( cusparseStatus_t err,
			      const char *msg,
			      const char *file,
			      int line ) {
  if (err != CUSPARSE_STATUS_SUCCESS)  {
    fprintf(stderr,"\n\x1B[31m@(CEO)>CUSPARSE ERROR: %s in %s at line %d\x1B[0m\n", 
	    msg, file, line );
    exit( EXIT_FAILURE );
  }
}
#define HANDLE_ERROR_CUSPARSE( err, msg ) (HandleErrorCUSPARSE( err, msg, __FILE__, __LINE__ ))   

inline float sign(float x) {
  return (float) ( (x > 0) - (x < 0) );
}

int round_up_to_nhp2(int n);

#define ARCSEC(a) (a*PI/180/3600)

<<lenslet2array>>

<<lenslet2row>>

<<threads2lenslet>>

<<tic-toc>>

void CUBLAS_ERROR(cublasStatus_t status);

<<mask structure>>
<<statistics definition>>

<<lenslet 2 actuator>>
__global__ void circular_pupil(int *pupil, int N);
//__global__ void valid_lenslet(char *mask, int N_pupil, float threshold);
__global__ void fried_geometry(char *lenslet_mask, char *actuator_mask, 
                               int NL, int n, float threshold);
char fried_geometry_setup(char *lenslet_mask, char *actuator_mask, 
                          int NL, int n, float threshold);

void dev2file(const char* filename, float* d__data, int n_data);
void dev2file(const char* filename, float* d__data, int n_data, 
              int n_data_page, int n_page);
void dev2file(const char* filename, float* d__data, int n_data, 
              int *n_data_page, int n_page);
void dev2file(const char* filename, int* d__data, int n_data);
void dev2file(const char* filename, float2* d__data, int n_data);
void dev2file(const char* filename, char* d__data, int n_data);

#endif  // __UTILITIES_H__

@
\subsubsection{Source}

<<utilities.cu>>=
#ifndef __UTILITIES_H__
#include "utilities.h"
#endif

int round_up_to_nhp2(int n) {
  int v; // compute the next highest power of 2 of 32-bit v
  v = n;
  v--;
  v |= v >> 1;
  v |= v >> 2;
  v |= v >> 4;
  v |= v >> 8;
  v |= v >> 16;
  v++;
  return v;
}

<<cublas error>>

<<fill ones>>
<<fill ones filtered>>
<<statistics functions>>
<<mask functions>>
<<circular pupil>>

<<Fried geometry masks>>
<<Fried geometry>>

<<device to file>>
@
\subsection{Functions}
\label{sec:functions}

\subsubsection{Mapping to lenslet array}
\label{sec:mapp-lensl-array}

When dealing with lenslet arrays, a thread in a given thread block correspond to a pixel coordinate $[i,j]$ in a given lenslet $[i_l,j_L]$.
The following function computes the coordinates $[i,j]$ and $[i_l,j_L]$ based on the thread and block index, the block size and the number of pixel per lenslet [[n_px_lenslet]].
<<threads2lenslet>>=
__device__ inline char threads2lenslet(dim3 threadIdx, dim3 blockIdx, dim3 blockDim, 
				      int *i_px_lenslet, int *j_px_lenslet, int n_px_lenslet, 
				       int *i_lenslet, int *j_lenslet, int n_lenslet) 
{
  <<from threads to lenslet coordinates>>
  return 1;
}
@ The pixel coordinate in the image is given by
<<from threads to lenslet coordinates>>=
*i_px_lenslet = threadIdx.x + blockIdx.x * blockDim.x;
*j_px_lenslet = threadIdx.y + blockIdx.y * blockDim.y;
@ Then the lenslet coordinate $[i_l,j_L]$ are derived from
<<from threads to lenslet coordinates>>=
*i_lenslet = *i_px_lenslet/n_px_lenslet;
if (*i_lenslet>=n_lenslet)
  return 0;
*j_lenslet = *j_px_lenslet/n_px_lenslet;
if (*j_lenslet>=n_lenslet)
  return 0;
@ and finally the pixel coordinate $[i,j]$ in lenslet $[i_l,j_L]$ is
<<from threads to lenslet coordinates>>=
*i_px_lenslet -=  *i_lenslet*n_px_lenslet;
*j_px_lenslet -=  *j_lenslet*n_px_lenslet;
@ 
Fig.~\ref{fig:1} shows the arrangements for $ 2\times2\times3$ blocks of $16\times16$ threads mapping a $6\times6$ lenslet array with $5\times5$ pixels per lenslet.
The third dimension of the block grid gives the source index.
\begin{figure}
  \centering
  \begin{tikzpicture}
    \foreach \z in {0,4,8} { 
    \begin{scope}[xshift=-\z mm,yshift=-\z mm]
      \fill[orange!50] (-2mm,-2mm) rectangle (34mm,34mm);
      \foreach \x in {0,16} { 
        \foreach \y in {0,16} {
          \begin{scope}[xshift=\x mm,yshift=\y mm]
            \fill[green!50,draw=black,thick] (0,0) rectangle (16mm,16mm);
            \draw[step=1mm,gray,thin] (0,0) grid (16mm,16mm);
          \end{scope}
        }
      }
      \draw[step=5mm,red,very thin] (0,0) grid (30mm,30mm);
    \end{scope}
}
  \end{tikzpicture}
  \caption{$2\times2\times3$ blocks of $16\times16$ threads mapping a $6\times6$ lenslet array with $5\times5$ pixels per lenslet}
  \label{fig:1}
\end{figure}
@
Once the coordinates $[i,j]$ and $[i_l,j_L]$ have been computed, the linear index in the image is computed with
<<lenslet2array>>=
__device__ inline int lenslet2array(int i_px_lenslet, int j_px_lenslet, int n_px_lenslet, 
			 int i_lenslet, int j_lenslet, int n_lenslet, 
			 int i_source, int n_source)
{
  int index;
  index = i_lenslet*n_px_lenslet + i_px_lenslet;
  index *= n_lenslet*n_px_lenslet*n_source;
  index += j_lenslet*n_px_lenslet + j_px_lenslet + i_source*n_px_lenslet*n_lenslet;
  return index;
}
@ Fig.~\ref{fig:2} shows the global coordinates of pixel $[i_g,j_g]$ in an image made of the horizontal concatenation of 3 lenslet arrays.
$i_g$ and $j_g$ are related to the coordinates $[i,j]$ and $[i_l,j_L]$ through the following relation
\begin{eqnarray}
  \label{eq:4}
  i_g &=& i_LN_L+i \\
  j_g &=& i_SN_LN_P + j_LN_L+j \\
\end{eqnarray}
where $i_S$ is the source index, $N_L$ is the size of one lenslet array and $N_P$ is the number of pixel per lenslet.
The linear global index $k_g$ is given by
\begin{equation}
  \label{eq:5}
  k_g = i_gN_LN_PN_s + j_g
\end{equation}
where $N_s$ is the number of sources.
\begin{figure}
  \centering
  \begin{tikzpicture}[x=1mm,y=1mm]
    \foreach \z in {0,30,60} { 
      \begin{scope}[xshift=\z mm]
        \fill[orange!50,draw=black,thick] (0,0) rectangle (30,30);
      \end{scope}
    }
    \draw[step=1mm,gray,thin] (0,0) grid (90,30);
    \draw[step=5mm,red,very thin] (0,0) grid (90,30);
    \fill[blue!70] (36,16) rectangle (37,17);
    \draw[blue!70] (-2,16.5) -- (36.5,16.5);
    \draw[blue!70] (36.5,-2) -- (36.5,16.5);
    \node[anchor=east] at (-2,16.5) {$i_LN_L+i$};
    \node[anchor=north] at (36.5,-2) {$i_SN_LN_P + j_LN_L+j$};
  \end{tikzpicture}
  \caption{3 $6\times6$ lenslet arrays with $5\times5$ pixels per lenslet}
  \label{fig:2}
\end{figure}

To compute the Fourier transform of the wavefront of each lenslet in a batch, all the lenslets are concatenated into a single column:
<<lenslet2row>>=
__device__ inline int lenslet2row(int i_px_lenslet, int j_px_lenslet, int n_px_lenslet, 
			 int i_lenslet, int j_lenslet, int n_lenslet, 
			 int i_source)
{
  int index;
  index = i_lenslet*n_lenslet + j_lenslet;
  index += i_source*n_lenslet*n_lenslet;
  index *= n_px_lenslet;
  index += i_px_lenslet;
  index *= n_px_lenslet;
  index += j_px_lenslet;
  return index;
}
@ Fig.~\ref{fig:3} shows the global coordinates of pixel $[i_g,j_g]$ in an image made of the vertical concatenation of all the lenslets.
$i_g$ and $j_g$ are related to the coordinates $[i,j]$ and $[i_l,j_L]$ through the following relation
\begin{eqnarray}
  \label{eq:4}
  i_g &=& (i_LN_L+j_L + i_SN_L^2)N_P + i \\
  j_g &=& j \\
\end{eqnarray}
where $i_S$ is the source index, $N_L$ is the size of one lenslet array and $N_P$ is the number of pixel per lenslet.
The linear global index $k_g$ is given by
\begin{equation}
  \label{eq:5}
  k_g = i_gN_P + j_g
\end{equation}
where $N_s$ is the number of sources.
\begin{figure}
  \centering
  \begin{tikzpicture}[x=1mm,y=1mm]
    \fill[orange!50,draw=black,thick] (0,0) rectangle (5,33);
    \draw[step=1mm,gray,thin] (0,0) grid (5,33);
    \draw[step=5mm,red,very thin] (0,0) grid (5,33);
    \fill[blue!70] (3,16) rectangle (4,17);
    \draw[blue!70] (-2,16.5) -- (3.5,16.5);
    \draw[blue!70] (3.5,-2) -- (3.5,16.5);
    \node[anchor=east] at (-2,16.5) {$(i_LN_L+j_L + i_SN_L^2)N_P + i$};
    \node[anchor=north] at (3.5,-2) {$j$};
  \end{tikzpicture}
  \caption{3 $6\times6$ lenslet arrays with $5\times5$ pixels per lenslet}
  \label{fig:3}
\end{figure}

\subsubsection{Stopwatch}
\label{sec:stopwatch}

In the following, a structure to time a chunk of CUDA code is defined:
<<tic-toc>>=
struct stopwatch{
  cudaEvent_t     start, stop;
  void tic(void) {
    HANDLE_ERROR( cudaEventCreate( &start ) );
    HANDLE_ERROR( cudaEventCreate( &stop ) );
    HANDLE_ERROR( cudaEventRecord( start, 0 ) );
  }
  void toc(void) {
    HANDLE_ERROR( cudaEventRecord( stop, 0 ) );
    HANDLE_ERROR( cudaEventSynchronize( stop ) );
    float   elapsedTime;
    HANDLE_ERROR( cudaEventElapsedTime( &elapsedTime,
                                        start, stop ) );
    printf("\x1B[33mElapsed time: %8.2E ms\x1B[0m\n", elapsedTime );
    HANDLE_ERROR( cudaEventDestroy( start ) );
    HANDLE_ERROR( cudaEventDestroy( stop ) );
  }
  void toc(char *message) {
    HANDLE_ERROR( cudaEventRecord( stop, 0 ) );
    HANDLE_ERROR( cudaEventSynchronize( stop ) );
    float   elapsedTime;
    HANDLE_ERROR( cudaEventElapsedTime( &elapsedTime,
                                        start, stop ) );
    printf("\x1B[33m%s: Elapsed time: %8.2E ms\x1B[0m\n", message, elapsedTime );
    HANDLE_ERROR( cudaEventDestroy( start ) );
    HANDLE_ERROR( cudaEventDestroy( stop ) );
  }
  void toc(float *elapsedTime, char *message) {
    HANDLE_ERROR( cudaEventRecord( stop, 0 ) );
    HANDLE_ERROR( cudaEventSynchronize( stop ) );
    HANDLE_ERROR( cudaEventElapsedTime( elapsedTime,
                                        start, stop ) );
    printf("\x1B[33m%s: Elapsed time: %8.2E ms\x1B[0m\n", message, *elapsedTime );
    HANDLE_ERROR( cudaEventDestroy( start ) );
    HANDLE_ERROR( cudaEventDestroy( stop ) );
  }
  void toc(float *elapsedTime) {
    HANDLE_ERROR( cudaEventRecord( stop, 0 ) );
    HANDLE_ERROR( cudaEventSynchronize( stop ) );
    HANDLE_ERROR( cudaEventElapsedTime( elapsedTime,
                                        start, stop ) );
    HANDLE_ERROR( cudaEventDestroy( start ) );
    HANDLE_ERROR( cudaEventDestroy( stop ) );
  }
};
@
\subsubsection{Statistics definitions}
\label{sec:stat-defin}

Statistical moment are computed with the structure [[stats]]
<<statistics definition>>=
struct stats {
  cublasHandle_t handle;
  cublasStatus_t status;
  void setup(void);
  void cleanup(void);
  float mean(const float *data, int n_data);
  float mean(const float *data, mask *M, int n_data);
  float var(const float *data, int n_data);
  float std(const float *data, int n_data);
  float diff_var(const float *data_1, const float *data_2, int n_data);
  float diff_std(const float *data_1, const float *data_2, int n_data);
  float var(const float *data1, mask *M, int n_data);
  float std(const float *data1, mask *M, int n_data);
  float diff_var(const float *data1, const float *data2, mask *M, int n_data);
  float diff_std(const float *data1, const float *data2, mask *M, int n_data);
};
<<statistics functions>>=
void stats::setup(void) {
  cublasCreate(&handle);
}
void stats::cleanup(void) {
  cublasDestroy(handle);
}
<<mean>> 
<<mean filtered data>>
<<variance>> 
<<differential variance>> 
<<standart deviation>>
<<differential standart deviation>>
<<variance filtered data>>
<<standart deviation filtered data>>
<<differential variance filtered data>>
<<differential standard deviation filtered data>>
@  
Computing the mean of a vector [[data]]$=x$, $\bar x = \langle x \rangle$:
<<mean>>=
float stats::mean(const float *data, int n_data) {
  float results, *ones;
  HANDLE_ERROR( cudaMalloc((void**)&ones, sizeof(float)*n_data ) );
  dim3 blockDim(256);
  dim3 gridDim(n_data/256+1);
  fill_ones LLL gridDim,blockDim RRR (ones, n_data);
  CUBLAS_ERROR( cublasSdot(handle, n_data, data, 1, ones, 1, &results) );
  HANDLE_ERROR( cudaFree( ones ) );
  return results/n_data;
}
@  with the kernel
<<fill ones>>=
__global__ void fill_ones(float *ones, int n_data) 
{
int i;
i = blockIdx.x * blockDim.x + threadIdx.x;
 if (i<n_data)
       ones[i] = 1.;
}

@  
Computing the mean of a vector [[data]]$=x\times f$, $\bar xf = \langle xf \rangle$ where $f$ is a filtering vector the same size than $x$ and made of 0 and 1:
<<mean filtered data>>=
float stats::mean(const float *data, mask *M, int n_data) {
  float results;
  CUBLAS_ERROR( cublasSdot(handle, n_data, data, 1, M->f, 1, &results) );
  return results/M->nnz;
}

@  
Computing the variance of a vector [[data]]$=x$, $\sigma^2_x=\langle x^2 \rangle - \langle x \rangle^2$:
<<variance>>=
float stats::var(const float *data, int n_data) {
  <<variance algorithm>>
  return results;
}
@  with 
<<variance algorithm>>=
float results, mean_data, *ones;
HANDLE_ERROR( cudaMalloc((void**)&ones, sizeof(float)*n_data ) );
dim3 blockDim(256);
dim3 gridDim(n_data/256+1);
fill_ones LLL gridDim,blockDim RRR (ones, n_data);
CUBLAS_ERROR( cublasSdot(handle, n_data, data, 1, ones, 1, &mean_data) );
HANDLE_ERROR( cudaFree( ones ) );
mean_data /= n_data;
CUBLAS_ERROR( cublasSdot(handle, n_data, data, 1, data, 1, &results) );
results /= n_data;
results -= (mean_data*mean_data);
@  
Computing the standart deviation $\sigma_x$ of a vector [[data]]$=x$:
<<standart deviation>>=
float stats::std(const float *data, int n_data) {
  <<variance algorithm>>
  return sqrtf(results);
}
@  
Computing the variance of a vector [[data]]$=x\times f$, $\sigma^2_{xf}=\langle (xf)^2 \rangle - \langle xf \rangle^2$ where $f$ is a filtering vector the same size than $x$ and made of 0 and 1:
<<variance filtered data>>=
float stats::var(const float *data1, mask *M, int n_data) {
  float results, mean_data, *data;
  HANDLE_ERROR( cudaMalloc((void**)&data, sizeof(float)*n_data ) );
  CUBLAS_ERROR( cublasScopy(handle, n_data, data1, 1, data, 1) );
  <<variance filtered data steps>>
  return results;
}
<<differential variance filtered data>>=
float stats::diff_var(const float *data1, const float *data2, mask *M, int n_data) {
  float results, mean_data, *data;
  HANDLE_ERROR( cudaMalloc((void**)&data, sizeof(float)*n_data ) );
  float alpha = -1;
  CUBLAS_ERROR( cublasScopy(handle, n_data, data1, 1, data, 1) );
  CUBLAS_ERROR( cublasSaxpy(handle, n_data, &alpha, data2, 1, data, 1) );
  <<variance filtered data steps>>
  return results;
}
<<differential standard deviation filtered data>>=
float stats::diff_std(const float *data1, const float *data2, mask *M, int n_data) {
  float results, mean_data, *data;
  HANDLE_ERROR( cudaMalloc((void**)&data, sizeof(float)*n_data ) );
  float alpha = -1;
  CUBLAS_ERROR( cublasScopy(handle, n_data, data1, 1, data, 1) );
  CUBLAS_ERROR( cublasSaxpy(handle, n_data, &alpha, data2, 1, data, 1) );
  <<variance filtered data steps>>
  return sqrtf(results);
}
@ the variance algorithm can now be applied on the filtered data
<<variance filtered data steps>>=
CUBLAS_ERROR( cublasSdot(handle, n_data, data, 1, M->f, 1, &mean_data) );
mean_data /= M->nnz;
CUBLAS_ERROR( cublasSdot(handle, n_data, data, 1, data, 1, &results) );
results /= M->nnz;
results -= (mean_data*mean_data);
HANDLE_ERROR( cudaFree( data ) );
@  
Computing the standard deviation of a vector [[data]]$=x\times f$, $\sigma_{xf}=\left(\langle (xf)^2 \rangle - \langle xf \rangle^2\right)^{1/2}$ where $f$ is a filtering vector the same size than $x$ and made of 0 and 1:
<<standart deviation filtered data>>=
float stats::std(const float *data1, mask *M, int n_data) {
  float results, mean_data, *data;
  HANDLE_ERROR( cudaMalloc((void**)&data, sizeof(float)*n_data ) );
  CUBLAS_ERROR( cublasScopy(handle, n_data, data1, 1, data, 1) );
  <<variance filtered data steps>>
  return sqrtf(results);
}

@  
Computing the differential variance of 2 vectors [[data1]]$=x_1$ and [[data2]]$=x_2$, $\sigma^2_{x_1-x_2}=\langle (x_1-x_2)^2 \rangle - \langle (x_1-x_2) \rangle^2$:
<<differential variance>>=
float stats::diff_var(const float *data1, const float *data2, int n_data) {
  <<differential variance algorithm>>
  return results;
}
@ with
<<differential variance algorithm>>=
float *data;
HANDLE_ERROR( cudaMalloc((void**)&data, sizeof(float)*n_data) );
float alpha = -1;
CUBLAS_ERROR( cublasScopy(handle, n_data, data1, 1, data, 1) );
CUBLAS_ERROR( cublasSaxpy(handle, n_data, &alpha, data2, 1, data, 1) );
<<variance algorithm>>
HANDLE_ERROR( cudaFree( data ) );
@  
Computing the differential standart deviation $\sigma_{x_1-x_2}$ of vector [[data1]]$=x_1$ and [[data2]]$=x_2$:
<<differential standart deviation>>=
float stats::diff_std(const float *data1, const float *data2, int n_data) {
  <<differential variance algorithm>>
  return sqrtf(results);
}
@
The error function;
<<cublas error>>=
void CUBLAS_ERROR(cublasStatus_t status) {
  if (CUBLAS_VERBOSE) {
      printf("\nCUBLAS: ");
      if (status==CUBLAS_STATUS_SUCCESS)
	printf("the operation completed successfully\n");
      else if (status==CUBLAS_STATUS_NOT_INITIALIZED)
	printf("the library was not initialized\n");
      else if (status==CUBLAS_STATUS_ALLOC_FAILED)
	printf("the reduction buffer could not be allocated\n");
      else if (status==CUBLAS_STATUS_ARCH_MISMATCH)
	printf("the device does not support double-precision\n");
      else if (status==CUBLAS_STATUS_EXECUTION_FAILED)
	printf("the function failed to launch on the GPU\n");
    }
}

@ 
\subsubsection{Pupil definition}
\label{sec:pup-def}

In the following, a circular pupil is computed:
<<circular pupil>>=
__global__ void circular_pupil(int *pupil, int N)
{
  int i, j, k;
  float h,x,y,r;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  k = i*N + j;
  if ( (i<N) && (j<N) ) {
    h = (float) (N-1)/2;
    x = i - h;
    y = j - h;
    r = x*x + y*y;
    pupil[k] = (r>N*N/4) ? 0 : 1;
  }
}
@ 
Next we compute the mask of lenslets mapping the pupil:
<<valid lenslet>>=
__global__ void valid_lenslet(char *mask, int N_pupil, float threshold)
{
  int i, j, n, iL, jL, sum, ai, bi, aj, bj, kL;
  float h,x,y,r,R;
  // pixel per lenslet
  n = N_pupil/N_SIDE_LENSLET;
  // lenslet index
  iL = blockIdx.x * blockDim.x + threadIdx.x;
  jL = blockIdx.y * blockDim.y + threadIdx.y;
  if ( (iL<N_SIDE_LENSLET) & (jL<N_SIDE_LENSLET)) {

    sum = 0;
    ai = iL*n;
    bi = (iL+1)*n;
    aj = jL*n;
    bj = (jL+1)*n;
    h = (float) (N_pupil-1)/2;
    R = N_pupil*N_pupil/4;

    for (i=ai;i<bi;i++) {
      for (j=aj;j<bj;j++) {
	x = i - h;
	y = j - h;
	r = x*x + y*y;
    	sum += (r>R) ? 0 : 1;
      }
    }
 
    kL = iL*N_SIDE_LENSLET + jL;
    threshold *= n*n;
    mask[kL] = (sum>threshold) ? 1 : 0;

  }
}
@  The following routine computes the masks of valid lenslet [[lenslet_mask]] and actuators [[actuator_mask]] for a circular pupil corresponding to a square [[NL]]$\times$[[NL]] lenslet array with [[n]] pixel per lenslet.
<<Fried geometry masks>>=
char fried_geometry_setup(char *lenslet_mask, char *actuator_mask, 
			  int NL, int n, float threshold)
{
HANDLE_ERROR( cudaMemset(lenslet_mask,  0, sizeof(char)*NL*NL         ) );
HANDLE_ERROR( cudaMemset(actuator_mask, 0, sizeof(char)*(NL+1)*(NL+1) ) );
dim3 blockDim(16,16);
dim3 gridDim(NL/16+1,NL/16+1);
fried_geometry LLL gridDim,blockDim RRR (lenslet_mask, actuator_mask, NL, n, threshold);
return 1;
}
<<Fried geometry>>=
  __global__ void fried_geometry(char *lenslet_mask, char *actuator_mask, 
				 int NL, int n, float threshold)
{
  int i, j, iL, jL, sum, ai, bi, aj, bj, kL, kA, N_pupil;
  float h,x,y,r,R;
  // total pixel
  N_pupil = n*NL;
  // lenslet index
  iL = blockIdx.x * blockDim.x + threadIdx.x;
  jL = blockIdx.y * blockDim.y + threadIdx.y;
  if ( (iL<NL) & (jL<NL)) {

    sum = 0;
    ai = iL*n;
    bi = (iL+1)*n;
    aj = jL*n;
    bj = (jL+1)*n;
    h = (float) (N_pupil-1)/2;
    R = N_pupil*N_pupil/4;

    for (i=ai;i<bi;i++) {
      for (j=aj;j<bj;j++) {
	x = i - h;
	y = j - h;
	r = x*x + y*y;
    	sum += (r>R) ? 0 : 1;
      }
    }
 
    threshold *= n*n;

    if (sum>threshold) {

      kL = iL*NL + jL;
      lenslet_mask[kL] = 1;

      kA = lenset2actuator(iL,jL,NL, 1, 1);     
      actuator_mask[kA] = 1;
      kA = lenset2actuator(iL,jL,NL,-1, 1);     
      actuator_mask[kA] = 1;
      kA = lenset2actuator(iL,jL,NL,-1,-1);     
      actuator_mask[kA] = 1;
      kA = lenset2actuator(iL,jL,NL, 1,-1);     
      actuator_mask[kA] = 1;

    }

  }
}

<<lenslet 2 actuator>>=
__device__ inline int lenset2actuator(int iL, int jL, int NL, int io, int jo)
{
  int iL_p, jL_p, iL_pp, jL_pp, iA, jA;

  iL_p = 2*iL + 1;
  jL_p = 2*jL + 1;
  
  iL_pp = iL_p + io;
  jL_pp = jL_p + jo;
  
  iA = iL_pp/2;
  jA = jL_pp/2;
  
  return iA*(NL+1) + jA;

}

@ 

\subsubsection{Mask structure}
\label{sec:mask-structure}

Lets define a mask structure with the following parameters:
\begin{itemize}
\item the mask [[m]] has a type of char and contains 0 and 1,
<<mask parameters>>=
char *m;  
@ \item the filter [[f]] has a type of float and contains 0 and 1,
<<mask parameters>>=
float *f;  
@ \item the total number of element [[nel]],
<<mask parameters>>=
int nel;  
@ \item the number of non zeros elements [[nnz]].
<<mask parameters>>=
float nnz;  
@ \end{itemize}

The mask structure definition is:
<<mask structure>>=
struct mask {
  <<mask parameters>>
  void setup(int n);
  void set_filter(void);
  void cleanup(void);
};
@ 
The mask functions are:
<<mask functions>>=
void mask::setup(int n) {
  nel = n;
  HANDLE_ERROR( cudaMalloc((void**)&m, sizeof(char)*nel ) );
  HANDLE_ERROR( cudaMalloc((void**)&f, sizeof(float)*nel ) );
  HANDLE_ERROR( cudaMemset( f, 0, sizeof(float)*nel) );
}
void mask::set_filter(void) {
  dim3 blockDim(256);
  dim3 gridDim(nel/256+1);
  fill_ones_filtered LLL gridDim,blockDim RRR (f, m, nel);
  cublasHandle_t handle;
  cublasCreate(&handle);
  CUBLAS_ERROR( cublasSasum(handle, nel, f, 1, &nnz) );
  printf("@(CEO)>mask: nnz = %.0f\n",nnz);
  cublasDestroy(handle);
}
void mask::cleanup(void) {
  HANDLE_ERROR( cudaFree( m ) );
  HANDLE_ERROR( cudaFree( f ) );
}
@  with the kernel
<<fill ones filtered>>=
__global__ void fill_ones_filtered(float *ones, const char* mask, int n_data) 
{
int i;
i = blockIdx.x * blockDim.x + threadIdx.x;
 if ( (i<n_data) && (mask[i]) )
       ones[i] = 1;
}

@
\subsubsection{Input/Output}
\label{sec:inputoutput}

In the following, the routines to write data on the device into a file are described.
Each file contains first an integer with the number of pages [[n_page]] and for each page the number of elements [[n_data]] and the data [[data]].
<<device to file>>=
void dev2file(const char* filename, float* d__data, int n_data) {
  int n_page=1;
   <<device to file common start>>
  float *data;
  data = (float*)malloc(sizeof(float)*n_data);
  HANDLE_ERROR( cudaMemcpy( data, d__data,
			  sizeof(float)*n_data,
			  cudaMemcpyDeviceToHost ) );
  fwrite(&n_data,sizeof(int),1,fid);
  fwrite(data,sizeof(float),n_data,fid);
  <<device to file common end>>
}
void dev2file(const char* filename, float* d__data, int n_data, 
	      int n_data_page, int n_page) {
   <<device to file common start>>
  float *data;
  data = (float*)malloc(sizeof(float)*n_data);
  HANDLE_ERROR( cudaMemcpy( data, d__data,
			  sizeof(float)*n_data,
			  cudaMemcpyDeviceToHost ) );
  int pos=0;
  for (int k_page=0;k_page<n_page;k_page++) {
    fwrite(&n_data_page,sizeof(int),1,fid);
    fwrite(data+pos,sizeof(float),n_data_page,fid);
    pos += n_data_page;
  }
  <<device to file common end>>
}
void dev2file(const char* filename, float* d__data, int n_data, 
	      int *n_data_page, int n_page) {
   <<device to file common start>>
  float *data;
  data = (float*)malloc(sizeof(float)*n_data);
  HANDLE_ERROR( cudaMemcpy( data, d__data,
			  sizeof(float)*n_data,
			  cudaMemcpyDeviceToHost ) );
  int pos=0;
  for (int k_page=0;k_page<n_page;k_page++) {
    fwrite(n_data_page+k_page,sizeof(int),1,fid);
    fwrite(data+pos,sizeof(float),n_data_page[k_page],fid);
    pos += n_data_page[k_page];
  }
  <<device to file common end>>
}
void dev2file(const char* filename, float2* d__data, int n_data) {
  int n_page=1;
   <<device to file common start>>
  float2 *data;
  data = (float2*)malloc(sizeof(float2)*n_data);
  HANDLE_ERROR( cudaMemcpy( data, d__data,
			  sizeof(float2)*n_data,
			  cudaMemcpyDeviceToHost ) );
  fwrite(&n_data,sizeof(int),1,fid);
  fwrite(data,sizeof(float2),n_data,fid);
  <<device to file common end>>
}
void dev2file(const char* filename, int* d__data, int n_data) {
  int n_page=1;
   <<device to file common start>>
  int *data;
  data = (int*)malloc(sizeof(int)*n_data);
  HANDLE_ERROR( cudaMemcpy( data, d__data,
			  sizeof(int)*n_data,
			  cudaMemcpyDeviceToHost ) );
  fwrite(&n_data,sizeof(int),1,fid);
  fwrite(data,sizeof(int),n_data,fid);
  <<device to file common end>>
}
void dev2file(const char* filename, char* d__data, int n_data) {
  int n_page=1;
   <<device to file common start>>
  char *data;
  data = (char*)malloc(sizeof(char)*n_data);
  HANDLE_ERROR( cudaMemcpy( data, d__data,
			  sizeof(char)*n_data,
			  cudaMemcpyDeviceToHost ) );
  fwrite(&n_data,sizeof(int),1,fid);
  fwrite(data,sizeof(char),n_data,fid);
  <<device to file common end>>
}

<<device to file common start>>=
struct stat sb;
char path[50];

if (stat("bins",&sb)!=0)
  if (mkdir("bins", S_IRWXU)==0)
    fprintf(stderr,"@(CEO)>utilities: bins directory created!\n");
  else {
    fprintf(stderr,"\n\x1B[31m@(CEO)>utilities: bins mkdir failed!\x1B[0m\n");
    return;
  }
strcpy(path,"bins/");
strcat(path,filename);
FILE *fid;
fid = fopen(path,"wb");
if (fid==NULL) {
  fprintf(stderr,"\n\x1B[31m@(CEO)>utilities: Unable to open the file: %s!\x1B[0m\n",path);
  return;
 }
fwrite(&n_page,sizeof(int),1,fid);
<<device to file common end>>=
fclose(fid);
free(data);
fprintf(stderr,"@(CEO)>utilities: Data saved to %s!\n",filename);
