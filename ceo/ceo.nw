% -*- mode: Noweb; noweb-code-mode: c-mode -*-
<<ceo.h>>=
#ifndef __CEO_H__
#define __CEO_H__


#include <stdio.h>
#include <cuda.h>
#include <cuda_runtime.h>
#include <curand.h>
#include <curand_kernel.h>
#include <cufft.h>
#include "cublas_v2.h"

#include "definitions.h"

#define PI 3.141592653589793
#define RADIAN2ARCSEC (180*3600/PI)
#define MIN(a, b)  (((a) < (b)) ? (a) : (b))
#define MAX(a, b)  (((a) > (b)) ? (a) : (b))

static void HandleError( cudaError_t err,
                         const char *file,
                         int line ) {
    if (err != cudaSuccess) {
        printf("\n\x1B[31m@(CEO)>ERROR: %s in %s at line %d\x1B[0m\n", 
	       cudaGetErrorString( err ), file, line );
        exit( EXIT_FAILURE );
    }
}
#define HANDLE_ERROR( err ) (HandleError( err, __FILE__, __LINE__ ))

inline float sign(float x) {
  return (float) ( (x > 0) - (x < 0) );
}

int round_up_to_nhp2(int n);

#define ARCSEC(a) (a*PI/180/3600)

<<lenslet2array>>

<<lenslet2row>>

<<threads2lenslet>>

<<tic-toc>>

<<statistics definition>>
__global__ void circular_pupil(int *pupil, int N);
__global__ void valid_lenslet(char *mask, int N_pupil, float threshold);

void dev2file(char* filename, float* d__data, int n_data);

#endif  // __CEO_H__
@
<<ceo.cu>>=
#ifndef __CEO_H__
#include "ceo.h"
#endif

int round_up_to_nhp2(int n) {
  int v; // compute the next highest power of 2 of 32-bit v
  v = n;
  v--;
  v |= v >> 1;
  v |= v >> 2;
  v |= v >> 4;
  v |= v >> 8;
  v |= v >> 16;
  v++;
  return v;
}

<<cublas error>>

<<statistics functions>>

__global__ void centroiding(float *cx, float *cy, float *flux, const float *frame)
{
  int u, k, i, ij, ij_inc, iLenslet,jLenslet;
  u = threadIdx.x;
  iLenslet = blockIdx.x;
  jLenslet = blockIdx.y;
  /* kLenslet = iLenslet*NSIDE_LENSLET + jLenslet; */
  k = blockIdx.x*N_SIDE_LENSLET*_N_SOURCE_ + blockIdx.y;
  
  __shared__ float buffer[_N_PX_CAMERA_][3];

  // CENTROIDING
  if (u<_N_PX_CAMERA_)
    {
      buffer[u][0] = buffer[u][1] = buffer[u][2] = 0.0;
      // ij = iLenslet*_N_PX_CAMERA_ + u;
      // ij *= N_SIDE_LENSLET*_N_PX_CAMERA_*_N_SOURCE_;
      // ij += jLenslet*_N_PX_CAMERA_;
      //      ij = (u+k*_N_PX_CAMERA_)*_N_PX_CAMERA_;
      ij = lenslet2array(u, 0, _N_PX_CAMERA_, 
			 iLenslet, jLenslet, N_SIDE_LENSLET, 
			 0, _N_SOURCE_);
      for (i=0;i<_N_PX_CAMERA_;i++)
	{
	  ij_inc = ij + i;
	  buffer[u][0]  += frame[ij_inc];
	  buffer[u][1]  += u*frame[ij_inc];
	  buffer[u][2]  += i*frame[ij_inc];
	}
    }
  
  __syncthreads();

  if (u<1)
  {
      flux[k]  = cx[k] = cy[k] = 0.0;
      for (i=0;i<_N_PX_CAMERA_;i++)
      {
          flux[k] += buffer[i][0];
          cx[k]   += buffer[i][1];
          cy[k]   += buffer[i][2];
      }
      if (flux[k]>0)
      {
          cx[k] /= flux[k];
          cy[k] /= flux[k];
      }
  }
}
<<circular pupil>>
<<valid lenslet>>
<<device to file>>
@
\subsection{Mapping to lenslet array}
\label{sec:mapp-lensl-array}

When dealing with lenslet arrays, a thread in a given thread block correspond to a pixel coordinate $[i,j]$ in a given lenslet $[i_l,j_L]$.
The following function computes the coordinates $[i,j]$ and $[i_l,j_L]$ based on the thread and block index, the block size and the number of pixel per lenslet [[n_px_lenslet]].
<<threads2lenslet>>=
__device__ inline void threads2lenslet(dim3 threadIdx, dim3 blockIdx, dim3 blockDim, 
				      int *i_px_lenslet, int *j_px_lenslet, int n_px_lenslet, 
				      int *i_lenslet, int *j_lenslet) 
{
  <<from threads to lenslet coordinates>>
}
@ The pixel coordinate in the image is given by
<<from threads to lenslet coordinates>>=
*i_px_lenslet = threadIdx.x + blockIdx.x * blockDim.x;
*j_px_lenslet = threadIdx.y + blockIdx.y * blockDim.y;
@ Then the lenslet coordinate $[i_l,j_L]$ are derived from
<<from threads to lenslet coordinates>>=
*i_lenslet = *i_px_lenslet/n_px_lenslet;
*j_lenslet = *j_px_lenslet/n_px_lenslet;
@ and finally the pixel coordinate $[i,j]$ in lenslet $[i_l,j_L]$ is
<<from threads to lenslet coordinates>>=
*i_px_lenslet -=  *i_lenslet*n_px_lenslet;
*j_px_lenslet -=  *j_lenslet*n_px_lenslet;
@ 
Fig.~\ref{fig:1} shows the arrangements for $ 2\times2\times3$ blocks of $16\times16$ threads mapping a $6\times6$ lenslet array with $5\times5$ pixels per lenslet.
The third dimension of the block grid gives the source index.
\begin{figure}
  \centering
  \begin{tikzpicture}
    \foreach \z in {0,4,8} { 
    \begin{scope}[xshift=-\z mm,yshift=-\z mm]
      \fill[orange!50] (-2mm,-2mm) rectangle (34mm,34mm);
      \foreach \x in {0,16} { 
        \foreach \y in {0,16} {
          \begin{scope}[xshift=\x mm,yshift=\y mm]
            \fill[green!50,draw=black,thick] (0,0) rectangle (16mm,16mm);
            \draw[step=1mm,gray,thin] (0,0) grid (16mm,16mm);
          \end{scope}
        }
      }
      \draw[step=5mm,red,very thin] (0,0) grid (30mm,30mm);
    \end{scope}
}
  \end{tikzpicture}
  \caption{$2\times2\times3$ blocks of $16\times16$ threads mapping a $6\times6$ lenslet array with $5\times5$ pixels per lenslet}
  \label{fig:1}
\end{figure}
@
Once the coordinates $[i,j]$ and $[i_l,j_L]$ have been computed, the linear index in the image is computed with
<<lenslet2array>>=
__device__ inline int lenslet2array(int i_px_lenslet, int j_px_lenslet, int n_px_lenslet, 
			 int i_lenslet, int j_lenslet, int n_lenslet, 
			 int i_source, int n_source)
{
  int index;
  index = i_lenslet*n_px_lenslet + i_px_lenslet;
  index *= n_lenslet*n_px_lenslet*n_source;
  index += j_lenslet*n_px_lenslet + j_px_lenslet + i_source*n_px_lenslet*n_lenslet;
  return index;
}
@ Fig.~\ref{fig:2} shows the global coordinates of pixel $[i_g,j_g]$ in an image made of the horizontal concatenation of 3 lenslet arrays.
$i_g$ and $j_g$ are related to the coordinates $[i,j]$ and $[i_l,j_L]$ through the following relation
\begin{eqnarray}
  \label{eq:4}
  i_g &=& i_LN_L+i \\
  j_g &=& i_SN_LN_P + j_LN_L+j \\
\end{eqnarray}
where $i_S$ is the source index, $N_L$ is the size of one lenslet array and $N_P$ is the number of pixel per lenslet.
The linear global index $k_g$ is given by
\begin{equation}
  \label{eq:5}
  k_g = i_gN_LN_PN_s + j_g
\end{equation}
where $N_s$ is the number of sources.
\begin{figure}
  \centering
  \begin{tikzpicture}[x=1mm,y=1mm]
    \foreach \z in {0,30,60} { 
      \begin{scope}[xshift=\z mm]
        \fill[orange!50,draw=black,thick] (0,0) rectangle (30,30);
      \end{scope}
    }
    \draw[step=1mm,gray,thin] (0,0) grid (90,30);
    \draw[step=5mm,red,very thin] (0,0) grid (90,30);
    \fill[blue!70] (36,16) rectangle (37,17);
    \draw[blue!70] (-2,16.5) -- (36.5,16.5);
    \draw[blue!70] (36.5,-2) -- (36.5,16.5);
    \node[anchor=east] at (-2,16.5) {$i_LN_L+i$};
    \node[anchor=north] at (36.5,-2) {$i_SN_LN_P + j_LN_L+j$};
  \end{tikzpicture}
  \caption{3 $6\times6$ lenslet arrays with $5\times5$ pixels per lenslet}
  \label{fig:2}
\end{figure}

To compute the Fourier transform of the wavefront of each lenslet in a batch, all the lenslets are concatenated into a single column:
<<lenslet2row>>=
__device__ inline int lenslet2row(int i_px_lenslet, int j_px_lenslet, int n_px_lenslet, 
			 int i_lenslet, int j_lenslet, int n_lenslet, 
			 int i_source)
{
  int index;
  index = i_lenslet*n_lenslet + j_lenslet;
  index += i_source*n_lenslet*n_lenslet;
  index *= n_px_lenslet;
  index += i_px_lenslet;
  index *= n_px_lenslet;
  index += j_px_lenslet;
  return index;
}
@ Fig.~\ref{fig:3} shows the global coordinates of pixel $[i_g,j_g]$ in an image made of the vertical concatenation of all the lenslets.
$i_g$ and $j_g$ are related to the coordinates $[i,j]$ and $[i_l,j_L]$ through the following relation
\begin{eqnarray}
  \label{eq:4}
  i_g &=& (i_LN_L+j_L + i_SN_L^2)N_P + i \\
  j_g &=& j \\
\end{eqnarray}
where $i_S$ is the source index, $N_L$ is the size of one lenslet array and $N_P$ is the number of pixel per lenslet.
The linear global index $k_g$ is given by
\begin{equation}
  \label{eq:5}
  k_g = i_gN_P + j_g
\end{equation}
where $N_s$ is the number of sources.
\begin{figure}
  \centering
  \begin{tikzpicture}[x=1mm,y=1mm]
    \fill[orange!50,draw=black,thick] (0,0) rectangle (5,33);
    \draw[step=1mm,gray,thin] (0,0) grid (5,33);
    \draw[step=5mm,red,very thin] (0,0) grid (5,33);
    \fill[blue!70] (3,16) rectangle (4,17);
    \draw[blue!70] (-2,16.5) -- (3.5,16.5);
    \draw[blue!70] (3.5,-2) -- (3.5,16.5);
    \node[anchor=east] at (-2,16.5) {$(i_LN_L+j_L + i_SN_L^2)N_P + i$};
    \node[anchor=north] at (3.5,-2) {$j$};
  \end{tikzpicture}
  \caption{3 $6\times6$ lenslet arrays with $5\times5$ pixels per lenslet}
  \label{fig:3}
\end{figure}

\subsection{Stopwatch}
\label{sec:stopwatch}

In the following, a structure to time a chunk of CUDA code is defined:
<<tic-toc>>=
struct stopwatch{
  cudaEvent_t     start, stop;
  void tic(void) {
    HANDLE_ERROR( cudaEventCreate( &start ) );
    HANDLE_ERROR( cudaEventCreate( &stop ) );
    HANDLE_ERROR( cudaEventRecord( start, 0 ) );
  }
  void toc(void) {
    HANDLE_ERROR( cudaEventRecord( stop, 0 ) );
    HANDLE_ERROR( cudaEventSynchronize( stop ) );
    float   elapsedTime;
    HANDLE_ERROR( cudaEventElapsedTime( &elapsedTime,
                                        start, stop ) );
    printf("\n\x1B[33mElapsed time: %8.2E ms\x1B[0m\n", elapsedTime );
    HANDLE_ERROR( cudaEventDestroy( start ) );
    HANDLE_ERROR( cudaEventDestroy( stop ) );
  }
  void toc(char *message) {
    HANDLE_ERROR( cudaEventRecord( stop, 0 ) );
    HANDLE_ERROR( cudaEventSynchronize( stop ) );
    float   elapsedTime;
    HANDLE_ERROR( cudaEventElapsedTime( &elapsedTime,
                                        start, stop ) );
    printf("\n\x1B[33m%s: Elapsed time: %8.2E ms\x1B[0m\n", message, elapsedTime );
    HANDLE_ERROR( cudaEventDestroy( start ) );
    HANDLE_ERROR( cudaEventDestroy( stop ) );
  }
  void toc(float *elapsedTime, char *message) {
    HANDLE_ERROR( cudaEventRecord( stop, 0 ) );
    HANDLE_ERROR( cudaEventSynchronize( stop ) );
    HANDLE_ERROR( cudaEventElapsedTime( elapsedTime,
                                        start, stop ) );
    printf("\n\x1B[33m%s: Elapsed time: %8.2E ms\x1B[0m\n", message, *elapsedTime );
    HANDLE_ERROR( cudaEventDestroy( start ) );
    HANDLE_ERROR( cudaEventDestroy( stop ) );
  }
  void toc(float *elapsedTime) {
    HANDLE_ERROR( cudaEventRecord( stop, 0 ) );
    HANDLE_ERROR( cudaEventSynchronize( stop ) );
    HANDLE_ERROR( cudaEventElapsedTime( elapsedTime,
                                        start, stop ) );
    HANDLE_ERROR( cudaEventDestroy( start ) );
    HANDLE_ERROR( cudaEventDestroy( stop ) );
  }
};
@
\subsection{Statistics definitions}
\label{sec:stat-defin}

Statistical moment are computed with the structure [[stats]]
<<statistics definition>>=
struct stats {
  cublasHandle_t handle;
  cublasStatus_t status;
  void setup(void);
  void cleanup(void);
  float mean(float *data, int n_data);
  float var(float *data, int n_data);
  float std(float *data, int n_data);
};
<<statistics functions>>=
void stats::setup(void) {
  cublasCreate(&handle);
}
void stats::cleanup(void) {
  cublasDestroy(handle);
}
<<mean>> 
<<variance>> 
<<standart deviation>>
@  
Computing the mean of a vector [[data]]$=x$, $\bar x = \langle x \rangle$:
<<mean>>=
float stats::mean(float *data, int n_data) {
  float results;
  CUBLAS_ERROR( cublasSasum(handle, n_data, data, 1, &results) );
  return results/n_data;
}
@  
Computing the variance of a vector [[data]]$=x$, $\sigma^2_x=\langle x^2 \rangle - \langle x \rangle^2$:
<<variance>>=
float stats::var(float *data, int n_data) {
  <<variance algorithm>>
  return results;
}
@  with 
<<variance algorithm>>=
float results, mean_data;
CUBLAS_ERROR( cublasSasum(handle, n_data, data, 1, &mean_data) );
mean_data /= n_data;
CUBLAS_ERROR( cublasSdot(handle, n_data, data, 1, data, 1, &results) );
results /= n_data;
results -= (mean_data*mean_data);
@  
Computing the standart deviation $\sigma_x$ of a vector [[data]]$=x$:
<<standart deviation>>=
float stats::std(float *data, int n_data) {
  <<variance algorithm>>
  return sqrtf(results);
}
@
The error function;
<<cublas error>>=
void CUBLAS_ERROR(cublasStatus_t status) {
  printf("\nCUBLAS: ");
  if (status==CUBLAS_STATUS_SUCCESS)
    printf("the operation completed successfully\n");
  else if (status==CUBLAS_STATUS_NOT_INITIALIZED)
    printf("the library was not initialized\n");
  else if (status==CUBLAS_STATUS_ALLOC_FAILED)
    printf("the reduction buffer could not be allocated\n");
  else if (status==CUBLAS_STATUS_ARCH_MISMATCH)
    printf("the device does not support double-precision\n");
  else if (status==CUBLAS_STATUS_EXECUTION_FAILED)
    printf("the function failed to launch on the GPU\n");
}

@ 
\subsection{Pupil definition}
\label{sec:pup-def}

In the following, a circular pupil is computed:
<<circular pupil>>=
__global__ void circular_pupil(int *pupil, int N)
{
  int i, j, k;
  float h,x,y,r;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  k = i*N + j;
  if ( (i<N) && (j<N) ) {
    h = (float) (N-1)/2;
    x = i - h;
    y = j - h;
    r = x*x + y*y;
    pupil[k] = (r>N*N/4) ? 0 : 1;
  }
}
@ 
Next we compute the mask of lenslets mapping the pupil:
<<valid lenslet>>=
__global__ void valid_lenslet(char *mask, int N_pupil, float threshold)
{
  int i, j, n, iL, jL, sum, ai, bi, aj, bj, kL;
  float h,x,y,r,R;
  // pixel per lenslet
  n = N_pupil/N_SIDE_LENSLET;
  // lenslet index
  iL = blockIdx.x * blockDim.x + threadIdx.x;
  jL = blockIdx.y * blockDim.y + threadIdx.y;
  if ( (iL<N_SIDE_LENSLET) & (jL<N_SIDE_LENSLET)) {

    sum = 0;
    ai = iL*n;
    bi = (iL+1)*n;
    aj = jL*n;
    bj = (jL+1)*n;
    h = (float) (N_pupil-1)/2;
    R = N_pupil*N_pupil/4;

    for (i=ai;i<bi;i++) {
      for (j=aj;j<bj;j++) {
	x = i - h;
	y = j - h;
	r = x*x + y*y;
    	sum += (r>R) ? 0 : 1;
      }
    }
 
    kL = iL*N_SIDE_LENSLET + jL;
    threshold *= n*n;
    mask[kL] = (sum>threshold) ? 1 : 0;

  }
}


@
\subsection{Input/Output}
\label{sec:inputoutput}

The next routine write data on the device into a file
<<device to file>>=
void dev2file(char* filename, float* d__data, int n_data) {
  float *data;
  data = (float*)malloc(sizeof(float)*n_data);
  HANDLE_ERROR( cudaMemcpy( data, d__data,
			  sizeof(float)*n_data,
			  cudaMemcpyDeviceToHost ) );
  FILE *fid;
  fid = fopen(filename,"wb");
  fwrite(data,sizeof(float),n_data,fid);
  fclose(fid);
  free(data);
}
